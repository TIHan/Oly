namespace Evergreen.Graphics.Backend.Vulkan

open System
open System.Text
open System.Numerics
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open System.Diagnostics
open TerraFX.Interop.Vulkan
open Evergreen.Graphics.Backend.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan
open static Evergreen.Graphics.Backend.Interop.VulkanMemoryAllocator

private alias Array = OlyPrelude.Array
private alias Unsafe = OlyPrelude.Unsafe

#[open]
internal module Helpers =

    internal fixed(o: object): GCHandle =
        GCHandle.Alloc(o, GCHandleType.Pinned)

    internal fixedCopyUTF8(str: string): GCHandle =
        fixed(UTF8Encoding.UTF8.GetBytes(str))

    internal fixedCopy(strs: string[]): PtrPtrHandle =
        let bytePtrs = Array.ZeroCreate<byte*>(strs.Length)
        let handles = Array.ZeroCreate(strs.Length)

        let mutable i = 0
        while (i < handles.Length)
            let mutable gcHandle = fixedCopyUTF8(strs[i])
            handles[i] <- gcHandle
            bytePtrs[i] <- Unsafe.AsPointer(gcHandle.AddrOfPinnedObject())
            i <- i + 1

        let gcHandle = GCHandle.Alloc(bytePtrs, GCHandleType.Pinned)
        PtrPtrHandle(handles, gcHandle)

alias VkExtent2D = TerraFX.Interop.Vulkan.VkExtent2D
alias VkPipelineBindPoint = TerraFX.Interop.Vulkan.VkPipelineBindPoint
alias VkImageLayout = TerraFX.Interop.Vulkan.VkImageLayout
alias VkBufferUsageFlags = TerraFX.Interop.Vulkan.VkBufferUsageFlags
alias VmaAllocationCreateFlags = Evergreen.Graphics.Backend.Interop.VulkanMemoryAllocator.VmaAllocationCreateFlags
alias VkDescriptorType = TerraFX.Interop.Vulkan.VkDescriptorType
alias VkShaderStageFlags = TerraFX.Interop.Vulkan.VkShaderStageFlags
alias VkDescriptorSetLayout = TerraFX.Interop.Vulkan.VkDescriptorSetLayout
alias VkDescriptorSet = TerraFX.Interop.Vulkan.VkDescriptorSet
alias VkDescriptorPool = TerraFX.Interop.Vulkan.VkDescriptorPool
alias VkCullModeFlags = TerraFX.Interop.Vulkan.VkCullModeFlags
alias VkFrontFace = TerraFX.Interop.Vulkan.VkFrontFace
alias VkFormat = TerraFX.Interop.Vulkan.VkFormat
alias VkImageUsageFlags = TerraFX.Interop.Vulkan.VkImageUsageFlags
alias VkImageAspectFlags = TerraFX.Interop.Vulkan.VkImageAspectFlags
alias VkFramebuffer = TerraFX.Interop.Vulkan.VkFramebuffer
alias VkPipeline = TerraFX.Interop.Vulkan.VkPipeline
alias VkPipelineLayout = TerraFX.Interop.Vulkan.VkPipelineLayout
alias VkRenderPass = TerraFX.Interop.Vulkan.VkRenderPass
alias VkShaderModule = TerraFX.Interop.Vulkan.VkShaderModule
alias VkImage = TerraFX.Interop.Vulkan.VkImage
alias VkImageView = TerraFX.Interop.Vulkan.VkImageView
alias VkSampler = TerraFX.Interop.Vulkan.VkSampler
alias VkVertexInputBindingDescription = TerraFX.Interop.Vulkan.VkVertexInputBindingDescription
alias VkVertexInputAttributeDescription = TerraFX.Interop.Vulkan.VkVertexInputAttributeDescription

class VulkanSwapChainOutOfDateException =
    inherits Exception

    internal new() = base()

class VulkanSwapChainCreationFailedException =
    inherits Exception

    internal new() = base()

class VulkanValidationException =
    inherits Exception

    internal new(msg: string) = base(msg)

class VulkanApplication =
    ValidationLayersEnabled: bool get
    Instance: VkInstance get
    Surface: VkSurfaceKHR get
    PhysicalDevice: VkPhysicalDevice get
    PhysicalDeviceProperties: VkPhysicalDeviceProperties get
    Device: VkDevice get
    GraphicsQueue: VkQueue get
    GraphicsQueueFamilyIndex: uint32 get
    GraphicsCommandPool: VkCommandPool get
    ComputeQueue: VkQueue get
    ComputeQueueFamilyIndex: uint32 get
    ComputeCommandPool: VkCommandPool get
    TransferQueue: VkQueue get
    TransferQueueFamilyIndex: uint32 get
    TransferCommandPool: VkCommandPool get
    PresentQueue: VkQueue get
    PresentQueueFamilyIndex: uint32 get
    DebugMessenger: VkDebugUtilsMessengerEXT get
    ImageAvailableSemaphores: VkSemaphore[] get
    RenderFinishedSemaphores: VkSemaphore[] get
    InFlightFences: VkFence[] get
    Allocator: VmaAllocator get

    internal mutable field currentFrame: int32
    internal mutable field previousFrame: int32
    internal mutable field framebufferResized: bool

    MaxFramesInFlight: int32 get() = this.InFlightFences.Length
    CurrentFrame: int32 get() = this.currentFrame
    PreviousFrame: int32 get() = this.previousFrame

    GetDeviceName(): string =
        let mutable deviceProperties = default
        vkGetPhysicalDeviceProperties(this.PhysicalDevice, &&deviceProperties)
        String(Unsafe.AsPointer(&&deviceProperties.deviceName): int8*)
        // TODO: This should work: "String(Unsafe.AsPointer(&&deviceProperties.deviceName))"
        // Fix language bug.

    new(validationLayersEnabled: bool, instance: VkInstance, surface: VkSurfaceKHR, physicalDevice: VkPhysicalDevice, device: VkDevice, graphicsQueue: VkQueue, graphicsQueueFamilyIndex: uint32, computeQueue: VkQueue, computeQueueFamilyIndex: uint32, transferQueue: VkQueue, transferQueueFamilyIndex: uint32, presentQueue: VkQueue, presentQueueFamilyIndex: uint32, debugMessenger: VkDebugUtilsMessengerEXT, imageAvailableSemaphores: VkSemaphore[], renderFinishedSemaphores: VkSemaphore[], inFlightFences: VkFence[], allocator: VmaAllocator) =
        let graphicsCommandPool = Vk.createCommandPool(device, graphicsQueueFamilyIndex)
        let computeCommandPool = Vk.createCommandPool(device, computeQueueFamilyIndex)
        let transferCommandPool = Vk.createCommandPool(device, transferQueueFamilyIndex)
        {
            ValidationLayersEnabled = validationLayersEnabled
            Instance = instance
            Surface = surface
            PhysicalDevice = physicalDevice
            PhysicalDeviceProperties = Vk.getPhysicalDeviceProperties(physicalDevice)
            Device = device
            GraphicsQueue = graphicsQueue
            GraphicsQueueFamilyIndex = graphicsQueueFamilyIndex
            GraphicsCommandPool = graphicsCommandPool
            ComputeQueue = computeQueue
            ComputeQueueFamilyIndex = computeQueueFamilyIndex
            ComputeCommandPool = computeCommandPool
            TransferQueue = transferQueue
            TransferQueueFamilyIndex = transferQueueFamilyIndex
            TransferCommandPool = transferCommandPool
            PresentQueue = presentQueue
            PresentQueueFamilyIndex = presentQueueFamilyIndex
            DebugMessenger = debugMessenger
            ImageAvailableSemaphores = imageAvailableSemaphores
            RenderFinishedSemaphores = renderFinishedSemaphores
            InFlightFences = inFlightFences
            currentFrame = 0
            previousFrame = 0
            framebufferResized = false
            Allocator = allocator
        }

class VulkanSwapChainSupportDetails =
    public field Capabilities: VkSurfaceCapabilitiesKHR
    Formats: VkSurfaceFormatKHR[] get
    PresentModes: VkPresentModeKHR[] get

    new(capabilities: VkSurfaceCapabilitiesKHR, formats: VkSurfaceFormatKHR[], presentModes: VkPresentModeKHR[]) =
        {
            Capabilities = capabilities
            Formats = formats
            PresentModes = presentModes
        }

class VulkanSwapChain =
    SwapChain: VkSwapchainKHR get
    Images: VkImage[] get
    ImageViews: VkImageView[] get
    DepthImages: VulkanImage[] get
    DepthImageViews: VkImageView[] get
    Extent: VkExtent2D get
    Viewport: VkViewport get
    Scissor: VkRect2D get
    ImageFormat: VkFormat get
    DepthFormat: VkFormat get
    SupportDetails: VulkanSwapChainSupportDetails get

    new(swapChain: VkSwapchainKHR, images: VkImage[], imageViews: VkImageView[], depthImages: VulkanImage[], depthImageViews: VkImageView[], extent: VkExtent2D, viewport: VkViewport, scissor: VkRect2D, imageFormat: VkFormat, depthFormat: VkFormat, supportDetails: VulkanSwapChainSupportDetails) =
        {
            SwapChain = swapChain
            Images = images
            ImageViews = imageViews
            DepthImages = depthImages
            DepthImageViews = depthImageViews
            Extent = extent
            Viewport = viewport
            Scissor = scissor
            ImageFormat = imageFormat
            DepthFormat = depthFormat
            SupportDetails = supportDetails
        }

class VulkanApplicationOptions =
    MaxFramesInFlight: int32 set, get = 2
    ValidationEnabled: bool set, get = false

    class VulkanDescriptorBindingInfo =
        Binding: uint32 get
        DescriptorType: VkDescriptorType get
        StageFlags: VkShaderStageFlags get
    
        new(binding: uint32, descriptorType: VkDescriptorType, stageFlags: VkShaderStageFlags) =
            {
                Binding = binding
                DescriptorType = descriptorType
                StageFlags = stageFlags
            }

class VulkanDescriptorBindingInfo =
    Binding: uint32 get
    DescriptorType: VkDescriptorType get
    StageFlags: VkShaderStageFlags get

    new(binding: uint32, descriptorType: VkDescriptorType, stageFlags: VkShaderStageFlags) =
        {
            Binding = binding
            DescriptorType = descriptorType
            StageFlags = stageFlags
        }

class VulkanBuffer =
    Buffer: VkBuffer get
    Allocation: VmaAllocation get
    AllocationInfo: VmaAllocationInfo get
    Size: uint64 get
    Flags: VkMemoryPropertyFlags get

    new(buffer: VkBuffer, allocation: VmaAllocation, allocInfo: VmaAllocationInfo, size: uint64, flags: VkMemoryPropertyFlags) =
        {
            Buffer = buffer
            Allocation = allocation
            AllocationInfo = allocInfo
            Size = size
            Flags = flags
        }

class VulkanImage =
    Image: VkImage get
    Allocation: VmaAllocation get
    Width: uint32 get
    Height: uint32 get
    Format: VkFormat get

    new(image: VkImage, allocation: VmaAllocation, width: uint32, height: uint32, format: VkFormat) =
        {
            Image = image
            Allocation = allocation
            Width = width
            Height = height
            Format = format
        }

/// Runtime alias for 'VkCommandBuffer'.
newtype VulkanCommandBuffer =
    internal field CommandBuffer: VkCommandBuffer

    Begin(): () =
        let mutable beginInfo = default: VkCommandBufferBeginInfo
        beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
        beginInfo.flags <- default // Optional
        beginInfo.pInheritanceInfo <- nullptr // Optional

        if (vkBeginCommandBuffer(this.CommandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
            fail("Failed to begin recording command buffer.")

    BeginRenderPass(renderPass: VkRenderPass, framebuffer: VkFramebuffer, extent: VkExtent2D): () =
        let mutable renderPassInfo = default: VkRenderPassBeginInfo
        renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
        renderPassInfo.renderPass <- renderPass
        renderPassInfo.framebuffer <- framebuffer
        renderPassInfo.renderArea.offset.x <- 0
        renderPassInfo.renderArea.offset.y <- 0
        renderPassInfo.renderArea.extent <- extent

        let mutable clearValue = default: VkClearValue
        let mutable clearColorValue = default: VkClearColorValue

        let clearColorValue0 = &clearColorValue.float32.FixedElementField
        let clearColorValue1 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&clearColorValue0, nuint(4))
        let clearColorValue2 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&clearColorValue0, nuint(8))
        let clearColorValue3 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&clearColorValue0, nuint(12))

        clearColorValue0 <- 0
        clearColorValue1 <- 0
        clearColorValue2 <- 0
        clearColorValue3 <- 1

        clearValue.color <- clearColorValue

        let mutable clearDepthValue = default: VkClearValue
        let mutable clearDepthStencilValue = default: VkClearDepthStencilValue

        clearDepthStencilValue.depth <- 1
        clearDepthStencilValue.stencil <- 0

        clearDepthValue.depthStencil <- clearDepthStencilValue

        // TODO: Fix GC allocation.
        let clearValues = [clearValue;clearDepthValue]

        let mutable clearValuesHandle = fixed(clearValues)

        renderPassInfo.clearValueCount <- uint32(clearValues.Length)
        renderPassInfo.pClearValues <- Unsafe.AsPointer(clearValuesHandle.AddrOfPinnedObject())

        vkCmdBeginRenderPass(this.CommandBuffer, &&renderPassInfo, VkSubpassContents.VK_SUBPASS_CONTENTS_INLINE)

        clearValuesHandle.Free()

    BindPipeline(pipeline: VkPipeline, pipelineBindPoint: VkPipelineBindPoint): () =
        vkCmdBindPipeline(this.CommandBuffer, pipelineBindPoint, pipeline)

    SetViewport(mutable viewport: VkViewport): () =
        vkCmdSetViewport(this.CommandBuffer, 0, 1, &&viewport)

    SetScissor(mutable scissor: VkRect2D): () =
        vkCmdSetScissor(this.CommandBuffer, 0, 1, &&scissor)

    Draw(vertexCount: uint32, instanceCount: uint32): () =
        vkCmdDraw(this.CommandBuffer, vertexCount, instanceCount, 0, 0)

    DrawIndexed(indexCount: uint32, instanceCount: uint32): () =
        vkCmdDrawIndexed(this.CommandBuffer, indexCount, instanceCount, 0, 0, 0)

    BindVertexBuffers(mutable rosVertexBuffers: ReadOnlySpan<VulkanBuffer>): () =
        let vertexBuffers = Array.ZeroCreate<VkBuffer>(rosVertexBuffers.Length)
        let mutable i = 0
        while (i < vertexBuffers.Length)
            vertexBuffers[i] <- rosVertexBuffers[i].Buffer
            i <- i + 1
        let mutable vertexBuffersHandle = fixed(vertexBuffers)

        let offsets = Array.ZeroCreate<uint64>(rosVertexBuffers.Length)
        let mutable i = 0
        while (i < offsets.Length)
            offsets[i] <- 0
            i <- i + 1
        let mutable offsetsHandle = fixed(offsets)

        vkCmdBindVertexBuffers(this.CommandBuffer, 0, 1, Unsafe.AsPointer(vertexBuffersHandle.AddrOfPinnedObject()), Unsafe.AsPointer(offsetsHandle.AddrOfPinnedObject()))

        // Cleanup
        offsetsHandle.Free()
        vertexBuffersHandle.Free()

    BindVertexBuffers(vertexBuffers: VulkanBuffer[||]): () =
        this.BindVertexBuffers(ReadOnlySpan(vertexBuffers))

    BindVertexBuffers(vertexBuffers: VulkanBuffer[]): () =
        this.BindVertexBuffers(ReadOnlySpan(Unsafe.AsMutable(vertexBuffers)))

    BindVertexBuffer(vertexBuffer: VulkanBuffer): () =
        this.BindVertexBuffers([vertexBuffer])

    BindIndexBuffer(indexBuffer: VulkanBuffer): () =
        vkCmdBindIndexBuffer(this.CommandBuffer, indexBuffer.Buffer, 0, VkIndexType.VK_INDEX_TYPE_UINT32)

    BindDescriptorSet(pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, mutable descriptorSet: VkDescriptorSet): () =
        vkCmdBindDescriptorSets(this.CommandBuffer, pipelineBindPoint, layout, 0, 1, &&descriptorSet, 0, nullptr)

    EndRenderPass(): () =
        vkCmdEndRenderPass(this.CommandBuffer)

    End(): () =
        if (vkEndCommandBuffer(this.CommandBuffer) != VkResult.VK_SUCCESS)
            fail("Failed to record command buffer.")

//

internal class PtrPtrHandle =
    implements IDisposable

    private mutable field handles: GCHandle[||]
    private mutable field ptrPtr: GCHandle

    new(handles: GCHandle[||], ptrPtr: GCHandle) =
        {
            handles = handles
            ptrPtr = ptrPtr
        }

    Pointer: void* get() = Unsafe.AsPointer(this.ptrPtr.AddrOfPinnedObject())

    Dispose(): () =
        let mutable i = 0
        while (i < this.handles.Length)
            let mutable handle = this.handles[i]
            handle.Free()
            i <- i + 1
        this.ptrPtr.Free()

module Vk =

    // ---------------------------------------------------------------------

    private validateOptions(options: VulkanApplicationOptions): () =
        if (options.MaxFramesInFlight <= 0)
            fail("'MaxFramesInFlight' cannot be less than or equal to zero.")

    Initialize(hwnd: nint, hinstance: nint, options: VulkanApplicationOptions): VulkanApplication =
        validateOptions(options)

        let maxFramesInFlight = options.MaxFramesInFlight
        let enableValidationLayers = options.ValidationEnabled
        
        let validationLayers = if (enableValidationLayers) ["VK_LAYER_KHRONOS_validation"] else []

        let instance = createInstance(enableValidationLayers, validationLayers)

        let mutable debugMessenger = default
        setupDebugMessenger(enableValidationLayers, instance, &&debugMessenger)

        let surface = createSurface(instance, hwnd, hinstance)

        let physicalDevices = getPhysicalDevices(instance)
        let physicalDevice = findSuitableDevice(physicalDevices)

        let queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(physicalDevice)
        let graphicsFamilyIndex = Array.FindIndex(queueFamilyProperties, x -> (x.queueFlags & VkQueueFlags.VK_QUEUE_GRAPHICS_BIT) == VkQueueFlags.VK_QUEUE_GRAPHICS_BIT)
        let computeFamilyIndex = Array.FindIndex(queueFamilyProperties, x -> (x.queueFlags & VkQueueFlags.VK_QUEUE_COMPUTE_BIT) == VkQueueFlags.VK_QUEUE_COMPUTE_BIT)
        let transferFamilyIndex = Array.FindIndex(queueFamilyProperties, x -> (x.queueFlags & VkQueueFlags.VK_QUEUE_TRANSFER_BIT) == VkQueueFlags.VK_QUEUE_TRANSFER_BIT)
        let presentFamilyIndex = 
            Array.FindIndex(queueFamilyProperties, 
                (i, x) ->
                    let mutable isPresentSupported = VkBool32.FALSE
                    if (vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, uint32(i), surface, &&isPresentSupported) != VkResult.VK_SUCCESS)
                        fail("Failed to get physical device surface support.")
                    isPresentSupported == VkBool32.TRUE
            )

        let device = createDevice(enableValidationLayers, validationLayers, physicalDevice, graphicsFamilyIndex, computeFamilyIndex, transferFamilyIndex, presentFamilyIndex)

        let mutable graphicsQueue = default
        vkGetDeviceQueue(device, uint32(graphicsFamilyIndex), uint32(graphicsFamilyIndex), &&graphicsQueue)

        let mutable computeQueue = default
        vkGetDeviceQueue(device, uint32(computeFamilyIndex), uint32(computeFamilyIndex), &&computeQueue)

        let mutable transferQueue = default
        vkGetDeviceQueue(device, uint32(transferFamilyIndex), uint32(transferFamilyIndex), &&transferQueue)

        let mutable presentQueue = default
        vkGetDeviceQueue(device, uint32(presentFamilyIndex), uint32(presentFamilyIndex), &&presentQueue)

        // Sync objects
        let mutable semaphoreInfo = default: VkSemaphoreCreateInfo
        semaphoreInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO

        let mutable fenceInfo = default: VkFenceCreateInfo
        fenceInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
        fenceInfo.flags <- VkFenceCreateFlags.VK_FENCE_CREATE_SIGNALED_BIT

        let inFlightFences = Array.ZeroCreate(maxFramesInFlight)
        let imageAvailableSemaphores = Array.ZeroCreate(inFlightFences.Length)
        let renderFinishedSemaphores = Array.ZeroCreate(inFlightFences.Length)

        let mutable i = 0
        while (i < inFlightFences.Length)
            let imageAvailableSemaphore = &imageAvailableSemaphores[i]
            let renderFinishedSemaphore = &renderFinishedSemaphores[i]
            let inFlightFence = &inFlightFences[i]

            if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&imageAvailableSemaphore) != VkResult.VK_SUCCESS)
                fail("Failed to create semaphore.")

            if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&renderFinishedSemaphore) != VkResult.VK_SUCCESS)
                fail("Failed to create semaphore.")

            if (vkCreateFence(device, &&fenceInfo, nullptr, &&inFlightFence) != VkResult.VK_SUCCESS)
                fail("Failed to create fence.")

            i <- i + 1

        let mutable vulkanFunctions = default: VmaVulkanFunctions
        vulkanFunctions.vkGetInstanceProcAddr <- &&vkGetInstanceProcAddr
        vulkanFunctions.vkGetDeviceProcAddr <- &&vkGetDeviceProcAddr

        let mutable allocatorCreateInfo = default: VmaAllocatorCreateInfo
        allocatorCreateInfo.vulkanApiVersion <- VK_API_VERSION_1_3
        allocatorCreateInfo.physicalDevice <- physicalDevice
        allocatorCreateInfo.device <- device
        allocatorCreateInfo.instance <- instance
        allocatorCreateInfo.pVulkanFunctions <- &&vulkanFunctions

        let mutable allocator = default: VmaAllocator
        if (vmaCreateAllocator(&&allocatorCreateInfo, &&allocator) != VkResult.VK_SUCCESS)
            fail("Failed to create allocator.")

        VulkanApplication(enableValidationLayers, instance, surface, physicalDevice, device, graphicsQueue, uint32(graphicsFamilyIndex), computeQueue, uint32(computeFamilyIndex), transferQueue, uint32(transferFamilyIndex), presentQueue, uint32(presentFamilyIndex), debugMessenger, Unsafe.AsImmutable(imageAvailableSemaphores), Unsafe.AsImmutable(renderFinishedSemaphores), Unsafe.AsImmutable(inFlightFences), allocator)

    CreateSwapChain(app: VulkanApplication, format: VkFormat): VulkanSwapChain =
        createSwapChain(app, format)

    DestroySwapChain(app: VulkanApplication, swapChain: VulkanSwapChain): () =
        let mutable i = 0
        while (i < swapChain.ImageViews.Length)
            vkDestroyImageView(app.Device, swapChain.ImageViews[i], nullptr)
            i <- i + 1
        let mutable i = 0
        while (i < swapChain.DepthImageViews.Length)
            vkDestroyImageView(app.Device, swapChain.DepthImageViews[i], nullptr)
            i <- i + 1
        let mutable i = 0
        while (i < swapChain.DepthImages.Length)
            DestroyImage(app, swapChain.DepthImages[i])
            i <- i + 1
        vkDestroySwapchainKHR(app.Device, swapChain.SwapChain, nullptr)

    Destroy(app: VulkanApplication): () =

        vmaDestroyAllocator(app.Allocator)

        let mutable i = 0
        while (i < app.InFlightFences.Length)
            vkDestroyFence(app.Device, app.InFlightFences[i], nullptr)
            vkDestroySemaphore(app.Device, app.ImageAvailableSemaphores[i], nullptr)
            vkDestroySemaphore(app.Device, app.RenderFinishedSemaphores[i], nullptr)
            i <- i + 1
        
        vkDestroyCommandPool(app.Device, app.GraphicsCommandPool, nullptr)
        vkDestroyCommandPool(app.Device, app.ComputeCommandPool, nullptr)
        vkDestroyCommandPool(app.Device, app.TransferCommandPool, nullptr)
        vkDestroyDevice(app.Device, nullptr)

        vkDestroySurfaceKHR(app.Instance, app.Surface, nullptr)

        if (app.ValidationLayersEnabled)
            destroyDebugUtilsMessengerEXT(app.Instance, app.DebugMessenger, nullptr)

        vkDestroyInstance(app.Instance, nullptr)

    CreateShaderModule(app: VulkanApplication, byteCode: ReadOnlySpan<byte>): VkShaderModule =
        createShaderModule(app.Device, byteCode)

    DestroyShaderModule(app: VulkanApplication, shaderModule: VkShaderModule): () =
        vkDestroyShaderModule(app.Device, shaderModule, nullptr)

    CreatePipelineLayout(app: VulkanApplication, setLayouts: VkDescriptorSetLayout[]): VkPipelineLayout =
        createPipelineLayout(app.Device, setLayouts)

    DestroyPipelineLayout(app: VulkanApplication, pipelineLayout: VkPipelineLayout): () =
        vkDestroyPipelineLayout(app.Device, pipelineLayout, nullptr)

    CreateRenderPass(app: VulkanApplication, swapChain: VulkanSwapChain): VkRenderPass =
        createRenderPass(app.Device, swapChain.ImageFormat, swapChain.DepthFormat)

    DestroyRenderPass(app: VulkanApplication, renderPass: VkRenderPass): () =
        vkDestroyRenderPass(app.Device, renderPass, nullptr)

    CreateGraphicsPipeline(app: VulkanApplication, swapChain: VulkanSwapChain, vertexBindingDescriptions: VkVertexInputBindingDescription[], vertexAttributeDescriptions: VkVertexInputAttributeDescription[], pipelineLayout: VkPipelineLayout, renderPass: VkRenderPass, cullMode: VkCullModeFlags, frontFace: VkFrontFace, vertexShaderModule: VkShaderModule, fragmentShaderModule: VkShaderModule): VkPipeline =
        let stages =
            [|
                createShaderStageInfo(vertexShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT);
                createShaderStageInfo(fragmentShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT)
            |]
        createGraphicsPipeline(app.Device, pipelineLayout, renderPass, stages, cullMode, frontFace, vertexBindingDescriptions, vertexAttributeDescriptions, swapChain.Extent)

    DestroyPipeline(app: VulkanApplication, pipeline: VkPipeline): () =
        vkDestroyPipeline(app.Device, pipeline, nullptr)

    CreateSwapChainFramebuffers(app: VulkanApplication, swapChain: VulkanSwapChain, renderPass: VkRenderPass): VkFramebuffer[] =
        Array.MapIndex(swapChain.ImageViews, 
            (i, x) -> createFramebuffer(app.Device, renderPass, x, swapChain.DepthImageViews[i], swapChain.Extent.width, swapChain.Extent.height)
        )

    CreateFramebuffer(app: VulkanApplication, renderPass: VkRenderPass, imageView: VkImageView, depthImageView: VkImageView, width: uint32, height: uint32): VkFramebuffer =
        createFramebuffer(app.Device, renderPass, imageView, depthImageView, width, height)

    DestroyFramebuffer(app: VulkanApplication, framebuffer: VkFramebuffer): () =
        vkDestroyFramebuffer(app.Device, framebuffer, nullptr)

    DestroyFramebuffers(app: VulkanApplication, mutable framebuffers: ReadOnlySpan<VkFramebuffer>): () =
        let mutable i = 0
        while (i < framebuffers.Length)
            DestroyFramebuffer(app, framebuffers[i])
            i <- i + 1

    DestroyFramebuffers(app: VulkanApplication, framebuffers: VkFramebuffer[||]): () =
        DestroyFramebuffers(app, ReadOnlySpan(framebuffers))

    DestroyFramebuffers(app: VulkanApplication, framebuffers: VkFramebuffer[]): () =
        DestroyFramebuffers(app, Unsafe.AsMutable(framebuffers))

    CreateGraphicsCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
        VulkanCommandBuffer(createCommandBuffer(app.Device, app.GraphicsCommandPool))

    CreateComputeCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
        VulkanCommandBuffer(createCommandBuffer(app.Device, app.ComputeCommandPool))

    CreateTransferCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
        VulkanCommandBuffer(createCommandBuffer(app.Device, app.TransferCommandPool))

    ResetCommandBuffer(app: VulkanApplication, commandBuffer: VulkanCommandBuffer): () =
        if (vkResetCommandBuffer(commandBuffer.CommandBuffer, default) != VkResult.VK_SUCCESS)
            fail("Failed to reset command buffer.!")

    ResizeFramebuffer(app: VulkanApplication): () =
        app.framebufferResized <- true

    CreateVertexBindingDescription<T>(binding: uint32, isInstance: bool): VkVertexInputBindingDescription where T: unmanaged =
        createVertexInputBindingDescription<T>(binding, isInstance)

    CreateVertexAttributeDescriptions<T>(binding: uint32): VkVertexInputAttributeDescription[] where T: unmanaged =
        createVertexInputAttributeDescriptions<T>(binding)

    CreateBuffer(app: VulkanApplication, size: uint64, mutable usage: VkBufferUsageFlags, flags: VmaAllocationCreateFlags): VulkanBuffer =
        let size =
            if (usage & VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT == VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT)
                if (size < app.PhysicalDeviceProperties.limits.minUniformBufferOffsetAlignment)
                    app.PhysicalDeviceProperties.limits.minUniformBufferOffsetAlignment
                else
                    size
            else
                size 

        let mutable allocInfo = default: VmaAllocationInfo
        match (createBuffer(app.Allocator, size, usage, flags, &&allocInfo))
        | (buffer, allocation) =>
            let mutable memPropFlags = default: VkMemoryPropertyFlags
            vmaGetAllocationMemoryProperties(app.Allocator, allocation, &&memPropFlags)
            VulkanBuffer(buffer, allocation, allocInfo, size, memPropFlags)
        | _ =>
            fail("Should not happen")

    UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, mutable bufferData: ReadOnlySpan<T>): () where T: unmanaged =
        let memPropFlags = buffer.Flags
        
        if ((memPropFlags & VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            let mutable pData = buffer.AllocationInfo.pMappedData
            let notMapped = nint(pData) == nint(0)

            if (notMapped)
                if (vmaMapMemory(app.Allocator, buffer.Allocation, &&pData) != VkResult.VK_SUCCESS)
                    fail("Failed to map memory.")

            bufferData.CopyTo(Span(pData, bufferData.Length))
        
            if (notMapped)
                vmaUnmapMemory(app.Allocator, buffer.Allocation)
        else
            let mutable allocationInfo = default
            let stagingBuffer = 
                createBuffer(
                    app.Allocator, 
                    buffer.Size, 
                    VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                    VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT,
                    &&allocationInfo
                )
            match (stagingBuffer)
            | (stagingBuffer, stagingAllocation) =>
                let bufferSpan = Span<T>(allocationInfo.pMappedData, bufferData.Length)
                bufferData.CopyTo(bufferSpan)
                if (vmaFlushAllocation(app.Allocator, stagingAllocation, 0, VK_WHOLE_SIZE) != VkResult.VK_SUCCESS)
                    fail("Failed to flush allocation.")
                
                let mutable bufferCopy = default: VkBufferCopy
                bufferCopy.srcOffset <- 0
                bufferCopy.dstOffset <- 0
                bufferCopy.size <- uint64(sizeof<T> * bufferData.Length)

                let mutable commandBuffer = createCommandBuffer(app.Device, app.TransferCommandPool)

                let mutable beginInfo = default: VkCommandBufferBeginInfo
                beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
                beginInfo.flags <- default // Optional
                beginInfo.pInheritanceInfo <- nullptr // Optional

                if (vkBeginCommandBuffer(commandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
                    fail("Failed to begin command buffer.")

                vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer.Buffer, 1, &&bufferCopy)

                if (vkEndCommandBuffer(commandBuffer) != VkResult.VK_SUCCESS)
                    fail("Failed to end command buffer.")
                
                let mutable submitInfo = default: VkSubmitInfo
                submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
                submitInfo.commandBufferCount <- 1
                submitInfo.pCommandBuffers <- &&commandBuffer

                if (vkQueueSubmit(app.TransferQueue, 1, &&submitInfo, default) != VkResult.VK_SUCCESS)
                    fail("Failed to submit queue.")

                if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
                    fail("Failed to wait idle on device.")

                vkFreeCommandBuffers(app.Device, app.TransferCommandPool, 1, &&commandBuffer)

                vmaDestroyBuffer(app.Allocator, stagingBuffer, stagingAllocation)
            | _ =>
                fail("should not happen")

    UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, bufferData: T[||]): () where T: unmanaged =
        UpdateBuffer<T>(app, buffer, ReadOnlySpan(bufferData))

    UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, bufferData: T[]): () where T: unmanaged =
        UpdateBuffer<T>(app, buffer, ReadOnlySpan<T>(Unsafe.AsMutable(bufferData)))

    DestroyBuffer(app: VulkanApplication, buffer: VulkanBuffer): () =
        vmaDestroyBuffer(app.Allocator, buffer.Buffer, buffer.Allocation)

    CreateImage(app: VulkanApplication, width: uint32, height: uint32, imageFormat: VkFormat, usageFlags: VkImageUsageFlags): VulkanImage =
        let mutable allocInfo = default: VmaAllocationInfo
        match (createImage(app.Allocator, width, height, imageFormat, usageFlags, VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT, &&allocInfo))
        | (image, allocation) =>
            VulkanImage(image, allocation, width, height, imageFormat)
        | _ =>
            fail("Should not happen")

    CreateImage(app: VulkanApplication, width: uint32, height: uint32, imageFormat: VkFormat): VulkanImage =
        CreateImage(app, width, height, imageFormat, default)

    TransitionImageLayout(app: VulkanApplication, image: VkImage, width: uint32, height: uint32, format: VkFormat, targetLayout: VkImageLayout): () =
        let size = uint64(width) * uint64(height) * 4
        let mutable allocationInfo = default
        let stagingBuffer = 
            createBuffer(
                app.Allocator, 
                size, 
                VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT,
                &&allocationInfo
            )
        match (stagingBuffer)
        | (stagingBuffer, stagingAllocation) =>
            let mutable imageCopy = default: VkBufferImageCopy
            imageCopy.bufferOffset <- 0
            imageCopy.bufferRowLength <- 0
            imageCopy.bufferImageHeight <- 0

            if (targetLayout == VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
                imageCopy.imageSubresource.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_DEPTH_BIT
            else
                imageCopy.imageSubresource.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
            imageCopy.imageSubresource.mipLevel <- 0
            imageCopy.imageSubresource.baseArrayLayer <- 0
            imageCopy.imageSubresource.layerCount <- 1

            imageCopy.imageOffset <- default // {0, 0, 0}
            imageCopy.imageExtent <-
                let mutable extent = default: VkExtent3D
                extent.width <- width
                extent.height <- height
                extent.depth <- 1
                extent

            let mutable commandBuffer = createCommandBuffer(app.Device, app.TransferCommandPool)

            let mutable beginInfo = default: VkCommandBufferBeginInfo
            beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
            beginInfo.flags <- default // Optional
            beginInfo.pInheritanceInfo <- nullptr // Optional

            if (vkBeginCommandBuffer(commandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
                fail("Failed to begin command buffer.")

            let oldLayout = VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
            let newLayout = 
                if (targetLayout == VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
                    VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                else
                    VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL

            transitionImageLayout(commandBuffer, image, format, oldLayout, newLayout)

            if (targetLayout != VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
                vkCmdCopyBufferToImage(
                    commandBuffer,
                    stagingBuffer,
                    image,
                    newLayout,
                    1,
                    &&imageCopy
                )
                transitionImageLayout(commandBuffer, image, format, newLayout, targetLayout)

            if (vkEndCommandBuffer(commandBuffer) != VkResult.VK_SUCCESS)
                fail("Failed to end command buffer.")

            let mutable submitInfo = default: VkSubmitInfo
            submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
            submitInfo.commandBufferCount <- 1
            submitInfo.pCommandBuffers <- &&commandBuffer

            if (vkQueueSubmit(app.TransferQueue, 1, &&submitInfo, default) != VkResult.VK_SUCCESS)
                fail("Failed to submit queue.")

            if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
                fail("Failed to wait idle on device.")

            vkFreeCommandBuffers(app.Device, app.TransferCommandPool, 1, &&commandBuffer)

            vmaDestroyBuffer(app.Allocator, stagingBuffer, stagingAllocation)
        | _ =>
            fail("Failed to create staging buffer.")

    UpdateImage(app: VulkanApplication, image: VulkanImage, mutable imageData: ReadOnlySpan<byte>): () =
        let mutable memPropFlags = default: VkMemoryPropertyFlags
        vmaGetAllocationMemoryProperties(app.Allocator, image.Allocation, &&memPropFlags)

        if ((memPropFlags & VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
            throw NotSupportedException("'VulkanImage' cannot use CPU/GPU shared memory.")
        else
            let size = uint64(image.Width) * uint64(image.Height) * 4
            let mutable allocationInfo = default
            let stagingBuffer = 
                createBuffer(
                    app.Allocator, 
                    size, 
                    VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                    VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT,
                    &&allocationInfo
                )
            match (stagingBuffer)
            | (stagingBuffer, stagingAllocation) =>
                let imageSpan = Span<byte>(allocationInfo.pMappedData, imageData.Length)
                imageData.CopyTo(imageSpan)
                if (vmaFlushAllocation(app.Allocator, stagingAllocation, 0, VK_WHOLE_SIZE) != VkResult.VK_SUCCESS)
                    fail("Failed to flush allocation.")

                let mutable imageCopy = default: VkBufferImageCopy
                imageCopy.bufferOffset <- 0
                imageCopy.bufferRowLength <- 0
                imageCopy.bufferImageHeight <- 0

                imageCopy.imageSubresource.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
                imageCopy.imageSubresource.mipLevel <- 0
                imageCopy.imageSubresource.baseArrayLayer <- 0
                imageCopy.imageSubresource.layerCount <- 1

                imageCopy.imageOffset <- default // {0, 0, 0}
                imageCopy.imageExtent <-
                    let mutable extent = default: VkExtent3D
                    extent.width <- image.Width
                    extent.height <- image.Height
                    extent.depth <- 1
                    extent

                let mutable commandBuffer = createCommandBuffer(app.Device, app.TransferCommandPool)

                let mutable beginInfo = default: VkCommandBufferBeginInfo
                beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
                beginInfo.flags <- default // Optional
                beginInfo.pInheritanceInfo <- nullptr // Optional

                if (vkBeginCommandBuffer(commandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
                    fail("Failed to begin command buffer.")

                let oldLayout = VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
                let newLayout = VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL

                transitionImageLayout(commandBuffer, image.Image, image.Format, oldLayout, newLayout)
                vkCmdCopyBufferToImage(
                    commandBuffer,
                    stagingBuffer,
                    image.Image,
                    newLayout,
                    1,
                    &&imageCopy
                )
                transitionImageLayout(commandBuffer, image.Image, image.Format, newLayout, VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)

                if (vkEndCommandBuffer(commandBuffer) != VkResult.VK_SUCCESS)
                    fail("Failed to end command buffer.")
                
                let mutable submitInfo = default: VkSubmitInfo
                submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
                submitInfo.commandBufferCount <- 1
                submitInfo.pCommandBuffers <- &&commandBuffer

                if (vkQueueSubmit(app.TransferQueue, 1, &&submitInfo, default) != VkResult.VK_SUCCESS)
                    fail("Failed to submit queue.")

                if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
                    fail("Failed to wait idle on device.")

                vkFreeCommandBuffers(app.Device, app.TransferCommandPool, 1, &&commandBuffer)

                vmaDestroyBuffer(app.Allocator, stagingBuffer, stagingAllocation)
            | _ =>
                fail("should not happen")

    DestroyImage(app: VulkanApplication, image: VulkanImage): () =
        vmaDestroyImage(app.Allocator, image.Image, image.Allocation)

    CreateImageView(app: VulkanApplication, image: VulkanImage, aspectMask: VkImageAspectFlags): VkImageView =
        createImageView(app.Device, image.Image, image.Format, aspectMask)

    DestroyImageView(app: VulkanApplication, imageView: VkImageView): () =
        vkDestroyImageView(app.Device, imageView, nullptr)

    CreateSampler(app: VulkanApplication): VkSampler =
        createSampler(app.Device, 1)//app.PhysicalDeviceProperties.limits.maxSamplerAnisotropy)

    DestroySampler(app: VulkanApplication, sampler: VkSampler): () =
        vkDestroySampler(app.Device, sampler, nullptr)

    CreateDescriptorSetLayout(app: VulkanApplication, bindingInfos: ReadOnlySpan<VulkanDescriptorBindingInfo>): VkDescriptorSetLayout =
        createDescriptorSetLayout(app.Device, bindingInfos)

    DestroyDescriptorSetLayout(app: VulkanApplication, descriptorSetLayout: VkDescriptorSetLayout): () =
        vkDestroyDescriptorSetLayout(app.Device, descriptorSetLayout, nullptr)

    CreateDescriptorPool(app: VulkanApplication, descriptorTypes: ReadOnlySpan<VkDescriptorType>, descriptorCount: uint32): VkDescriptorPool =
        createDescriptorPool(app.Device, descriptorTypes, descriptorCount)

    DestroyDescriptorPool(app: VulkanApplication, descriptorPool: VkDescriptorPool): () =
        vkDestroyDescriptorPool(app.Device, descriptorPool, nullptr)

    CreateDescriptorSets(app: VulkanApplication, descriptorPool: VkDescriptorPool, descriptorSetCount: uint32, setLayout: VkDescriptorSetLayout): VkDescriptorSet[] =
        createDescriptorSets(app.Device, descriptorPool, descriptorSetCount, setLayout)

    UpdateDescriptorSet(app: VulkanApplication, binding: uint32, descriptorSet: VkDescriptorSet, buffer: VulkanBuffer, descriptorType: VkDescriptorType): () =
        updateDescriptorSet(app.Device, binding, descriptorSet, buffer.Buffer, 0, buffer.Size, descriptorType)

    UpdateDescriptorSet(app: VulkanApplication, binding: uint32, descriptorSet: VkDescriptorSet, imageLayout: VkImageLayout, imageView: VkImageView, sampler: VkSampler, descriptorType: VkDescriptorType): () =
        updateDescriptorSet(app.Device, binding, descriptorSet, imageLayout, imageView, sampler, descriptorType)

    GetDepthFormat(app: VulkanApplication): VkFormat =
        findSupportedFormat(
            app.PhysicalDevice,
            [VkFormat.VK_FORMAT_D32_SFLOAT;VkFormat.VK_FORMAT_D32_SFLOAT_S8_UINT;VkFormat.VK_FORMAT_D24_UNORM_S8_UINT],
            VkImageTiling.VK_IMAGE_TILING_OPTIMAL,
            VkFormatFeatureFlags.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
        )
    
    Draw(app: VulkanApplication, swapChain: VulkanSwapChain, acquireCommandBuffer: (framebufferIndex: int32, frame: int32) -> VulkanCommandBuffer): () =
        let currentFrame = app.currentFrame

        let mutable inFlightFence = app.InFlightFences[currentFrame]
        let imageAvailableSemaphore = app.ImageAvailableSemaphores[currentFrame]
        let renderFinishedSemaphore = app.RenderFinishedSemaphores[currentFrame]

        if (vkWaitForFences(app.Device, 1, &&inFlightFence, VkBool32.TRUE, uint64.MaxValue) != VkResult.VK_SUCCESS)
            fail("Failed to wait for fences.")

        if (vkResetFences(app.Device, 1, &&inFlightFence) != VkResult.VK_SUCCESS)
            fail("Failed to reset fences.")

        let mutable imageIndex = default
        let result = vkAcquireNextImageKHR(app.Device, swapChain.SwapChain, uint64.MaxValue, imageAvailableSemaphore, VkFence.NULL, &&imageIndex)

        if (result == VkResult.VK_ERROR_OUT_OF_DATE_KHR)
            throw VulkanSwapChainOutOfDateException()
        else if (result != VkResult.VK_SUCCESS)
            fail("Failed to acquire next image.")
        else
            let commandBuffer = acquireCommandBuffer(int32(imageIndex), currentFrame)

            let result = draw(swapChain.SwapChain, app.GraphicsQueue, app.PresentQueue, commandBuffer, imageIndex, imageAvailableSemaphore, renderFinishedSemaphore, inFlightFence)

            if (result == VkResult.VK_ERROR_OUT_OF_DATE_KHR || result == VkResult.VK_SUBOPTIMAL_KHR || app.framebufferResized)
                app.framebufferResized <- false
                throw VulkanSwapChainOutOfDateException()
            else if (result != VkResult.VK_SUCCESS)
                fail("Failed to present.")

            app.previousFrame <- currentFrame
            app.currentFrame <- (app.currentFrame + 1) % app.InFlightFences.Length

    WaitForIdle(app: VulkanApplication): () =
        if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
            fail("Failed to wait for idle on device.")
            
    ResetCurrentFrame(app: VulkanApplication): () =
        app.currentFrame <- 0

    // ---------------------------------------------------------------------

    private alias PFN_vkCreateDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerCreateInfoEXT*, VkAllocationCallbacks*, VkDebugUtilsMessengerEXT*) -> VkResult
    private alias PFN_vkDestroyDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerEXT, VkAllocationCallbacks*) -> ()

    private createDebugUtilsMessengerEXT(
            instance: VkInstance, 
            pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT*,
            pAllocator: VkAllocationCallbacks*,
            pDebugMessenger: VkDebugUtilsMessengerEXT*
            ): VkResult =

        let pName = "vkCreateDebugUtilsMessengerEXT"
        let mutable pNameHandle = fixedCopyUTF8(pName)
        let func = nint(vkGetInstanceProcAddr(instance, Unsafe.AsPointer(pNameHandle.AddrOfPinnedObject())))
        pNameHandle.Free()
        if (func != nint(0))
            let func: PFN_vkCreateDebugUtilsMessengerEXT = Unsafe.AsFunctionPointer(func)
            func(instance, pCreateInfo, pAllocator, pDebugMessenger)
        else
            VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

    private destroyDebugUtilsMessengerEXT(instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT, pAllocator: VkAllocationCallbacks*): () =
        let pName = "vkDestroyDebugUtilsMessengerEXT"
        let mutable pNameHandle = fixedCopyUTF8(pName)
        let func = nint(vkGetInstanceProcAddr(instance, Unsafe.AsPointer(pNameHandle.AddrOfPinnedObject())))
        pNameHandle.Free()
        if (func != nint(0))
            let func: PFN_vkDestroyDebugUtilsMessengerEXT = Unsafe.AsFunctionPointer(func)
            func(instance, debugMessenger, pAllocator)

    private getRequiredExtensions(enableValidationLayers: bool): string[] =
        if (enableValidationLayers)
            [
                Encoding.UTF8.GetString(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
                Encoding.UTF8.GetString(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
                "VK_KHR_surface";
                "VK_KHR_win32_surface"
            ]
        else
            [
                "VK_KHR_surface";
                "VK_KHR_win32_surface"
            ]

    private getRequiredDeviceExtensions(): string[] =
        [
            "VK_KHR_swapchain"
        ]

    #[blittable]
    #[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>])]
    #[DebuggerHidden()]
    private debugCallback(messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT*, pUserData: void*): VkBool32 =
        if ((messageSeverity & VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) == VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)
            let callback = *pCallbackData
            let str = String(callback.pMessage)
            throw VulkanValidationException(str)

        print("validation layer: ")
        let callback = *pCallbackData
        let str = String(callback.pMessage)
        printLine(str)
        VkBool32.FALSE

    private populateDebugMessengerCreateInfo(createInfo: byref<VkDebugUtilsMessengerCreateInfoEXT>): () =
        createInfo <- default
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
        createInfo.messageSeverity <- VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
        createInfo.messageType <- VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
        createInfo.pfnUserCallback <- &&debugCallback

    private setupDebugMessenger(enableValidationLayers: bool, instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT*): () =
        if (enableValidationLayers)
            let mutable createInfo = default: VkDebugUtilsMessengerCreateInfoEXT
            populateDebugMessengerCreateInfo(&createInfo)

            if (createDebugUtilsMessengerEXT(instance, &&createInfo, nullptr, debugMessenger) != VkResult.VK_SUCCESS)
                fail("Failed to set up debug messenger.")

    private createInstance(enableValidationLayers: bool, validationLayers: string[]): VkInstance =
        if (enableValidationLayers && !checkValidationLayerSupport(validationLayers))
            fail("Validation layers were requested, but not available.")

        let appName = "Vulkan Application"
        let engineName = "Vulkan Engine"

        let mutable appNameHandle = fixed(appName)
        let mutable engineNameHandle = fixed(engineName)

        let mutable appInfo = default: VkApplicationInfo
        appInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO
        appInfo.pApplicationName <- Unsafe.AsPointer(appNameHandle.AddrOfPinnedObject())
        appInfo.applicationVersion <- VK_MAKE_VERSION(1, 0, 0)
        appInfo.pEngineName <- Unsafe.AsPointer(engineNameHandle.AddrOfPinnedObject())
        appInfo.engineVersion <- VK_MAKE_VERSION(1, 0, 0)
        appInfo.apiVersion <- VK_API_VERSION_1_3
        
      //  if (enableValidationLayers)
     //      Environment.SetEnvironmentVariable("VK_LAYER_ENABLES", "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT")

        let mutable enables = VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT
        let mutable features = default: VkValidationFeaturesEXT
        if (enableValidationLayers)           
            features.sType <- VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
            features.enabledValidationFeatureCount <- 1
            features.pEnabledValidationFeatures <- &&enables

        let mutable createInfo = default: VkInstanceCreateInfo
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
        createInfo.pApplicationInfo <- &&appInfo

        if (enableValidationLayers)
            createInfo.pNext <- Unsafe.AsPointer(&&features)

        let extensions = getRequiredExtensions(enableValidationLayers)
        let extensionsHandle = fixedCopy(extensions)
        let validationLayersHandle = fixedCopy(validationLayers)

        createInfo.enabledExtensionCount <- uint32(extensions.Length)
        createInfo.ppEnabledExtensionNames <- Unsafe.AsPointer(extensionsHandle.Pointer)

        if (enableValidationLayers)
            createInfo.enabledLayerCount <- uint32(validationLayers.Length)
            createInfo.ppEnabledLayerNames <- Unsafe.AsPointer(validationLayersHandle.Pointer)

            let mutable debugCreateInfo = default: VkDebugUtilsMessengerCreateInfoEXT
            populateDebugMessengerCreateInfo(&debugCreateInfo)
            createInfo.pNext <- Unsafe.AsPointer(&&debugCreateInfo)
        else
            createInfo.enabledLayerCount <- 0
            createInfo.pNext <- nullptr

        let mutable instance = default

        if (vkCreateInstance(&&createInfo, nullptr, &&instance) != VkResult.VK_SUCCESS)
            fail("Failed to create instance.")

        // Cleanup
        appNameHandle.Free()
        engineNameHandle.Free()
        validationLayersHandle.Dispose()
        extensionsHandle.Dispose()

        instance

    private createSurface(instance: VkInstance, hwnd: nint, hinstance: nint): VkSurfaceKHR =
        let mutable surface = default: VkSurfaceKHR

        let mutable createInfo = default: VkWin32SurfaceCreateInfoKHR
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
        createInfo.hwnd <- hwnd
        createInfo.hinstance <- hinstance

        let mutable instanceImports = default: VkInstanceManualImports
        let pName = "vkCreateWin32SurfaceKHR"
        let mutable pNameHandle = fixedCopyUTF8(pName)
        let func = nint(vkGetInstanceProcAddr(instance, Unsafe.AsPointer(pNameHandle.AddrOfPinnedObject())))
        pNameHandle.Free()
        if (func == nint(0))
            fail("Failed to query instance function.")
        instanceImports.vkCreateWin32SurfaceKHR <- Unsafe.AsFunctionPointer(func)
        if (instanceImports.vkCreateWin32SurfaceKHR(instance, &&createInfo, nullptr, &&surface) != VkResult.VK_SUCCESS)
            fail("Failed to create window surface.")
        surface

    private createDevice(enableValidationLayers: bool, validationLayers: string[], physicalDevice: VkPhysicalDevice, graphicsFamilyIndex: int32, computeFamilyIndex: int32, transferFamilyIndex: int32, presentFamilyIndex: int32): VkDevice =
        // Graphics Queue
        let mutable graphicsQueuePriority = 1.0: float32
        let mutable graphicsQueueCreateInfo = default: VkDeviceQueueCreateInfo
        graphicsQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
        graphicsQueueCreateInfo.queueFamilyIndex <- uint32(graphicsFamilyIndex)
        graphicsQueueCreateInfo.queueCount <- 1
        graphicsQueueCreateInfo.pQueuePriorities <- &&graphicsQueuePriority

        // Compute Queue
        let mutable computeQueuePriority = 1.0: float32
        let mutable computeQueueCreateInfo = default: VkDeviceQueueCreateInfo
        computeQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
        computeQueueCreateInfo.queueFamilyIndex <- uint32(computeFamilyIndex)
        computeQueueCreateInfo.queueCount <- 1
        computeQueueCreateInfo.pQueuePriorities <- &&computeQueuePriority

        // Transfer Queue
        let mutable transferQueuePriority = 1.0: float32
        let mutable transferQueueCreateInfo = default: VkDeviceQueueCreateInfo
        transferQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
        transferQueueCreateInfo.queueFamilyIndex <- uint32(transferFamilyIndex)
        transferQueueCreateInfo.queueCount <- 1
        transferQueueCreateInfo.pQueuePriorities <- &&transferQueuePriority

        // Present Queue
        let mutable presentQueuePriority = 1.0: float32
        let mutable presentQueueCreateInfo = default: VkDeviceQueueCreateInfo
        presentQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
        presentQueueCreateInfo.queueFamilyIndex <- uint32(presentFamilyIndex)
        presentQueueCreateInfo.queueCount <- 1
        presentQueueCreateInfo.pQueuePriorities <- &&presentQueuePriority

        let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

        let mutable createInfo = default: VkDeviceCreateInfo
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO

        // Queues
        let queueCreateInfos = [graphicsQueueCreateInfo;computeQueueCreateInfo;transferQueueCreateInfo;presentQueueCreateInfo]
        let queueCreateInfos = Array.DistinctBy(queueCreateInfos, x -> x.queueFamilyIndex)
        let mutable queueCreateInfosHandle = fixed(queueCreateInfos)
        createInfo.queueCreateInfoCount <- uint32(queueCreateInfos.Length)
        createInfo.pQueueCreateInfos <- Unsafe.AsPointer(queueCreateInfosHandle.AddrOfPinnedObject())
        createInfo.pEnabledFeatures <- &&deviceFeatures

        let validationLayersHandle = fixedCopy(validationLayers)
        if (enableValidationLayers)
            createInfo.enabledLayerCount <- uint32(validationLayers.Length)
            createInfo.ppEnabledLayerNames <- Unsafe.AsPointer(validationLayersHandle.Pointer)
        else
            createInfo.enabledLayerCount <- 0

        let deviceExtensions = getRequiredDeviceExtensions()
        if (!checkExtensionsSupport(physicalDevice, deviceExtensions))
            fail("Failed to validate device extensions.")
        
        createInfo.enabledExtensionCount <- uint32(deviceExtensions.Length)
        let requiredDeviceExtensionsHandle = fixedCopy(deviceExtensions)
        createInfo.ppEnabledExtensionNames <- Unsafe.AsPointer(requiredDeviceExtensionsHandle.Pointer)  

        let mutable device = default
        if (vkCreateDevice(physicalDevice, &&createInfo, nullptr, &&device) != VkResult.VK_SUCCESS)
            fail("Failed to create device.")

        // Cleanup
        queueCreateInfosHandle.Free()
        requiredDeviceExtensionsHandle.Dispose()

        device

    private createSwapChainSupportDetails(device: VkPhysicalDevice, surface: VkSurfaceKHR): VulkanSwapChainSupportDetails =
        let mutable capabilities = default: VkSurfaceCapabilitiesKHR
        let throwAwayResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &&capabilities)

        let mutable formatCount = 0: uint32

        let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, nullptr)

        let formats = Array.ZeroCreate<VkSurfaceFormatKHR>(int32(formatCount))
        let mutable formatsHandle = fixed(formats)
        let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, Unsafe.AsPointer(formatsHandle.AddrOfPinnedObject()))
        formatsHandle.Free()

        let mutable presentModeCount = 0: uint32

        let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, nullptr)

        let presentModes = Array.ZeroCreate<VkPresentModeKHR>(int32(presentModeCount))
        let mutable presentModesHandle = fixed(presentModes)
        let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, Unsafe.AsPointer(presentModesHandle.AddrOfPinnedObject()))
        presentModesHandle.Free()

        VulkanSwapChainSupportDetails(capabilities, Unsafe.AsImmutable(formats), Unsafe.AsImmutable(presentModes))

    private findSwapSurfaceFormat(formats: VkSurfaceFormatKHR[], format: VkFormat): VkSurfaceFormatKHR =
        Array.Find(formats, 
            x ->
                if (x.format == format)
                    match (format)
                    | VkFormat.VK_FORMAT_B8G8R8A8_SRGB =>
                        x.colorSpace == VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
                    | VkFormat.VK_FORMAT_B8G8R8A8_UNORM =>
                        x.colorSpace == VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
                    | _ =>
                        false
                else
                    false
        )

    private findSupportedFormat(physicalDevice: VkPhysicalDevice, formats: VkFormat[], tiling: VkImageTiling, features: VkFormatFeatureFlags): VkFormat =
        Array.Find(formats, 
            x -> 
                let mutable props = default: VkFormatProperties
                vkGetPhysicalDeviceFormatProperties(physicalDevice, x, &&props)

                match (tiling)
                | VkImageTiling.VK_IMAGE_TILING_LINEAR when ((props.linearTilingFeatures & features) == features) =>
                    true
                | VkImageTiling.VK_IMAGE_TILING_OPTIMAL when ((props.optimalTilingFeatures & features) == features) =>
                    true
                | _ =>
                    false
        )

    private hasStencilComponent(format: VkFormat): bool =
        format == VkFormat.VK_FORMAT_D32_SFLOAT_S8_UINT || format == VkFormat.VK_FORMAT_D24_UNORM_S8_UINT

    private findSwapPresentMode(presentModes: VkPresentModeKHR[]): VkPresentModeKHR =
        Array.Find(presentModes, x -> x == VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR)

    private findSwapExtent(capabilities: inref<VkSurfaceCapabilitiesKHR>): VkExtent2D =
        if (capabilities.currentExtent.width != uint32.MaxValue)
            capabilities.currentExtent
        else
            fail("Invalid swap-extent.")
    //     VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
    //     if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
    //         return capabilities.currentExtent;
    //     } else {
    //         int width, height;
    //         glfwGetFramebufferSize(window, &width, &height);

    //         VkExtent2D actualExtent = {
    //             static_cast<uint32_t>(width),
    //             static_cast<uint32_t>(height)
    //         };

    //         actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
    //         actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

    //         return actualExtent;
    //     }
    // }

    private createSwapChain(app: VulkanApplication, format: VkFormat): VulkanSwapChain =
        let physicalDevice = app.PhysicalDevice
        let device = app.Device
        let surface = app.Surface
        let graphicsFamilyIndex = app.GraphicsQueueFamilyIndex
        let presentFamilyIndex = app.PresentQueueFamilyIndex
        let maxFramesInFlight = uint32(app.MaxFramesInFlight)

        let details = createSwapChainSupportDetails(physicalDevice, surface)

        let swapChainAdequate =
            details.Formats.Length > 0 && details.PresentModes.Length > 0

        if (!swapChainAdequate)
            fail("Swap chain is not adequate.")

        let surfaceFormat = findSwapSurfaceFormat(details.Formats, format)
        let presentMode = findSwapPresentMode(details.PresentModes)
        let extent = findSwapExtent(&details.Capabilities)

        // Request at least more than one image.
        let mutable imageCount = details.Capabilities.minImageCount + 1

        if (details.Capabilities.maxImageCount > 0 && imageCount > details.Capabilities.maxImageCount)
            imageCount <- details.Capabilities.maxImageCount   

        imageCount <- Math.Max(imageCount, maxFramesInFlight)

        if (imageCount > details.Capabilities.maxImageCount)
            fail("'MaxFramesInFlight' exceeds maximum swap-chain images.")

        let mutable createInfo = default: VkSwapchainCreateInfoKHR
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
        createInfo.surface <- surface
        createInfo.minImageCount <- imageCount
        createInfo.imageFormat <- surfaceFormat.format
        createInfo.imageColorSpace <- surfaceFormat.colorSpace
        createInfo.imageExtent <- extent
        createInfo.imageArrayLayers <- 1
        createInfo.imageUsage <- VkImageUsageFlags.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT

        let queueFamilyIndices = [graphicsFamilyIndex;presentFamilyIndex]
        let mutable queueFamilyIndicesHandle = fixed(queueFamilyIndices)
        if (graphicsFamilyIndex != presentFamilyIndex)
            createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_CONCURRENT
            createInfo.queueFamilyIndexCount <- 2
            createInfo.pQueueFamilyIndices <- Unsafe.AsPointer(queueFamilyIndicesHandle.AddrOfPinnedObject())
        else
            createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_EXCLUSIVE
            createInfo.queueFamilyIndexCount <- 0 // Optional
            createInfo.pQueueFamilyIndices <- nullptr // Optional

        createInfo.preTransform <- details.Capabilities.currentTransform
        createInfo.compositeAlpha <- VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR

        createInfo.presentMode <- presentMode
        createInfo.clipped <- VkBool32.TRUE
        createInfo.oldSwapchain <- VkSwapchainKHR.NULL

        if (createInfo.preTransform == (default: VkSurfaceTransformFlagsKHR))
            throw VulkanSwapChainCreationFailedException()

        let mutable swapChain = default
        if (vkCreateSwapchainKHR(device, &&createInfo, nullptr, &&swapChain) != VkResult.VK_SUCCESS)
            fail("Failed to create swap chain.")

        // Getting images
        let images = getSwapChainImages(device, swapChain)
        let imageViews = Array.Map(images, x -> createImageView(device, x, surfaceFormat.format, VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT))

        let depthFormat = GetDepthFormat(app)

        let depthImages = 
            Array.Initialize(images.Length, 
                i -> CreateImage(app, extent.width, extent.height, depthFormat, VkImageUsageFlags.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)
            )
        let depthImageViews = 
            Array.Map(depthImages, 
                x -> createImageView(device, x.Image, x.Format, VkImageAspectFlags.VK_IMAGE_ASPECT_DEPTH_BIT)
            )

        let mutable viewport = default: VkViewport
        viewport.x <- 0
        viewport.y <- 0
        viewport.width <- float32(extent.width)
        viewport.height <- float32(extent.height)
        viewport.minDepth <- 0
        viewport.maxDepth <- 1

        let mutable scissor = default: VkRect2D
        scissor.offset <- default
        scissor.extent <- extent

        VulkanSwapChain(swapChain, images, imageViews, depthImages, depthImageViews, extent, viewport, scissor, surfaceFormat.format, depthFormat, details)

    private createImageView(device: VkDevice, image: VkImage, imageFormat: VkFormat, aspectMask: VkImageAspectFlags): VkImageView =
        let mutable createInfo = default: VkImageViewCreateInfo
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
        createInfo.image <- image
        createInfo.viewType <- VkImageViewType.VK_IMAGE_VIEW_TYPE_2D
        createInfo.format <- imageFormat
        createInfo.components.r <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
        createInfo.components.g <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
        createInfo.components.b <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
        createInfo.components.a <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY

        createInfo.subresourceRange.aspectMask <- aspectMask
        createInfo.subresourceRange.baseMipLevel <- 0
        createInfo.subresourceRange.levelCount <- 1
        createInfo.subresourceRange.baseArrayLayer <- 0
        createInfo.subresourceRange.layerCount <- 1

        let mutable imageView = default: VkImageView
        if (vkCreateImageView(device, &&createInfo, nullptr, &&imageView) != VkResult.VK_SUCCESS)
            fail("Failed to create image view.")
        
        imageView

    private createShaderModule(device: VkDevice, mutable byteCode: ReadOnlySpan<byte>): VkShaderModule =
        let byteCodeRef = &byteCode.GetPinnableReference()

        let mutable createInfo = default: VkShaderModuleCreateInfo
        createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
        createInfo.codeSize <- nuint(byteCode.Length)
        createInfo.pCode <- Unsafe.AsPointer(&&byteCodeRef)

        let mutable shaderModule = default: VkShaderModule
        if (vkCreateShaderModule(device, &&createInfo, nullptr, &&shaderModule) != VkResult.VK_SUCCESS)
            fail("Failed to create shader module.")
            
        shaderModule

    private createShaderStageInfo(shaderModule: VkShaderModule, stage: VkShaderStageFlags): VkPipelineShaderStageCreateInfo =
        if (shaderModule == VkShaderModule.NULL)
            fail("VkShaderModule is null.")
            
        let mutable shaderStageInfo = default: VkPipelineShaderStageCreateInfo
        shaderStageInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
        shaderStageInfo.stage <- stage
        shaderStageInfo.`module` <- shaderModule
        shaderStageInfo

    private createPipelineLayout(device: VkDevice, setLayouts: VkDescriptorSetLayout[]): VkPipelineLayout =
        let mutable setLayoutsHandle = fixed(setLayouts)

        let mutable pipelineLayoutInfo = default: VkPipelineLayoutCreateInfo
        pipelineLayoutInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
        pipelineLayoutInfo.setLayoutCount <- uint32(setLayouts.Length)
        pipelineLayoutInfo.pSetLayouts <- Unsafe.AsPointer(setLayoutsHandle.AddrOfPinnedObject())
        pipelineLayoutInfo.pushConstantRangeCount <- 0 // Optional
        pipelineLayoutInfo.pPushConstantRanges <- nullptr // Optional

        let mutable pipelineLayout = default
        if (vkCreatePipelineLayout(device, &&pipelineLayoutInfo, nullptr, &&pipelineLayout) != VkResult.VK_SUCCESS)
            fail("Failed to create pipeline layout.")

        setLayoutsHandle.Free()

        pipelineLayout

    private createGraphicsPipeline(
            device: VkDevice, 
            pipelineLayout: VkPipelineLayout, 
            renderPass: VkRenderPass, 
            stages: VkPipelineShaderStageCreateInfo[||],
            cullMode: VkCullModeFlags,
            frontFace: VkFrontFace,
            vertexBindingDescriptions: VkVertexInputBindingDescription[],
            vertexAttributeDescriptions: VkVertexInputAttributeDescription[], 
            swapChainExtent: VkExtent2D): VkPipeline =
        let dynamicStates =
            [
                VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT;
                VkDynamicState.VK_DYNAMIC_STATE_SCISSOR
            ]

        let mutable dynamicStatesHandle = fixed(dynamicStates)

        let mutable dynamicState = default: VkPipelineDynamicStateCreateInfo
        dynamicState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
        dynamicState.dynamicStateCount <- uint32(dynamicStates.Length)
        dynamicState.pDynamicStates <- Unsafe.AsPointer(dynamicStatesHandle.AddrOfPinnedObject())

        let mutable vertexBindingDescriptionsHandle = fixed(vertexBindingDescriptions)
        let mutable vertexAttributeDescriptionsHandle = fixed(vertexAttributeDescriptions)

        let mutable vertexInputInfo = default: VkPipelineVertexInputStateCreateInfo
        vertexInputInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
        vertexInputInfo.vertexBindingDescriptionCount <- uint32(vertexBindingDescriptions.Length)
        vertexInputInfo.pVertexBindingDescriptions <- Unsafe.AsPointer(vertexBindingDescriptionsHandle.AddrOfPinnedObject())
        vertexInputInfo.vertexAttributeDescriptionCount <- uint32(vertexAttributeDescriptions.Length)
        vertexInputInfo.pVertexAttributeDescriptions <- Unsafe.AsPointer(vertexAttributeDescriptionsHandle.AddrOfPinnedObject())

        let mutable inputAssembly = default: VkPipelineInputAssemblyStateCreateInfo
        inputAssembly.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
        inputAssembly.topology <- VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
        inputAssembly.primitiveRestartEnable <- VkBool32.FALSE

        let mutable viewport = default: VkViewport
        viewport.x <- 0
        viewport.y <- 0
        viewport.width <- float32(swapChainExtent.width)
        viewport.height <- float32(swapChainExtent.height)
        viewport.minDepth <- 0
        viewport.maxDepth <- 1

        let mutable scissor = default: VkRect2D
        scissor.offset <- default
        scissor.extent <- swapChainExtent

        let mutable viewportState = default: VkPipelineViewportStateCreateInfo
        viewportState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
        viewportState.viewportCount <- 1
        viewportState.pViewports <- &&viewport
        viewportState.scissorCount <- 1
        viewportState.pScissors <- &&scissor

        let mutable rasterizer = default: VkPipelineRasterizationStateCreateInfo
        rasterizer.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
        rasterizer.depthClampEnable <- VkBool32.FALSE
        rasterizer.rasterizerDiscardEnable <- VkBool32.FALSE
        rasterizer.polygonMode <- VkPolygonMode.VK_POLYGON_MODE_FILL
        rasterizer.lineWidth <- 1
        rasterizer.cullMode <- cullMode
        rasterizer.frontFace <- frontFace

        // TODO: We will want to enable this at some point.
        rasterizer.depthBiasEnable <- VkBool32.FALSE
        rasterizer.depthBiasConstantFactor <- 0 // Optional
        rasterizer.depthBiasClamp <- 0 // Optional
        rasterizer.depthBiasSlopeFactor <- 0 // Optional

        let mutable multisampling = default: VkPipelineMultisampleStateCreateInfo
        multisampling.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
        multisampling.sampleShadingEnable <- VkBool32.FALSE
        multisampling.rasterizationSamples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
        multisampling.minSampleShading <- 1 // Optional
        multisampling.pSampleMask <- nullptr // Optional
        multisampling.alphaToCoverageEnable <- VkBool32.FALSE // Optional
        multisampling.alphaToOneEnable <- VkBool32.FALSE // Optional

        let mutable colorBlendAttachment = default: VkPipelineColorBlendAttachmentState
        colorBlendAttachment.colorWriteMask <- VkColorComponentFlags.VK_COLOR_COMPONENT_R_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_G_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_B_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_A_BIT
        colorBlendAttachment.blendEnable <- VkBool32.FALSE
        colorBlendAttachment.srcColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
        colorBlendAttachment.dstColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
        colorBlendAttachment.colorBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional
        colorBlendAttachment.srcAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
        colorBlendAttachment.dstAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
        colorBlendAttachment.alphaBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional

        let mutable colorBlending = default: VkPipelineColorBlendStateCreateInfo
        colorBlending.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
        colorBlending.logicOpEnable <- VkBool32.FALSE
        colorBlending.logicOp <- VkLogicOp.VK_LOGIC_OP_COPY // Optional
        colorBlending.attachmentCount <- 1
        colorBlending.pAttachments <- &&colorBlendAttachment

        let colorBlendingValue0 = &colorBlending.blendConstants.FixedElementField
        let colorBlendingValue1 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&colorBlendingValue0, nuint(4))
        let colorBlendingValue2 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&colorBlendingValue0, nuint(8))
        let colorBlendingValue3 = &System.Runtime.CompilerServices.Unsafe.AddByteOffset(&colorBlendingValue0, nuint(12))

        colorBlendingValue0 <- 0 // Optional
        colorBlendingValue1 <- 0 // Optional
        colorBlendingValue2 <- 0 // Optional
        colorBlendingValue3 <- 0 // Optional

        let mutable depthStencil = default: VkPipelineDepthStencilStateCreateInfo
        depthStencil.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
        depthStencil.depthTestEnable <- VkBool32.TRUE
        depthStencil.depthWriteEnable <- VkBool32.TRUE
        depthStencil.depthCompareOp <- VkCompareOp.VK_COMPARE_OP_LESS
        depthStencil.depthBoundsTestEnable <- VkBool32.FALSE
        depthStencil.minDepthBounds <- 0 // Optional
        depthStencil.maxDepthBounds <- 1 // Optional
        depthStencil.stencilTestEnable <- VkBool32.FALSE
        depthStencil.front <- default // Optional
        depthStencil.back <- default // Optional

        let pName = "main"
        let mutable pNameHandle = fixedCopyUTF8(pName)
        let stageCount = stages.Length
        let mutable i = 0
        while (i < stageCount)
            stages[i].pName <- Unsafe.AsPointer(pNameHandle.AddrOfPinnedObject())
            i <- i + 1
        let mutable stagesHandle = fixed(stages)

        let mutable pipelineInfo = default: VkGraphicsPipelineCreateInfo
        pipelineInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
        pipelineInfo.stageCount <- uint32(stageCount)
        pipelineInfo.pStages <- Unsafe.AsPointer(stagesHandle.AddrOfPinnedObject())
        pipelineInfo.pVertexInputState <- &&vertexInputInfo
        pipelineInfo.pInputAssemblyState <- &&inputAssembly
        pipelineInfo.pViewportState <- &&viewportState
        pipelineInfo.pRasterizationState <- &&rasterizer
        pipelineInfo.pMultisampleState <- &&multisampling
        pipelineInfo.pDepthStencilState <- &&depthStencil
        pipelineInfo.pColorBlendState <- &&colorBlending
        pipelineInfo.pDynamicState <- &&dynamicState
        pipelineInfo.layout <- pipelineLayout
        pipelineInfo.renderPass <- renderPass
        pipelineInfo.subpass <- 0
        pipelineInfo.basePipelineHandle <- VkPipeline.NULL // Optional
        pipelineInfo.basePipelineIndex <- -1 // Optional

        let mutable graphicsPipeline = default
        if (vkCreateGraphicsPipelines(device, VkPipelineCache.NULL, 1, &&pipelineInfo, nullptr, &&graphicsPipeline) != VkResult.VK_SUCCESS)
            fail("Failed to create graphics pipeline.")

        // Cleanup
        stagesHandle.Free()
        pNameHandle.Free()
        dynamicStatesHandle.Free()
        
        graphicsPipeline

    private createRenderPass(device: VkDevice, swapChainImageFormat: VkFormat, depthFormat: VkFormat): VkRenderPass =
        let mutable colorAttachment = default: VkAttachmentDescription
        colorAttachment.format <- swapChainImageFormat
        colorAttachment.samples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
        colorAttachment.loadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR
        colorAttachment.storeOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_STORE
        colorAttachment.stencilLoadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE
        colorAttachment.stencilStoreOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE
        colorAttachment.initialLayout <- VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
        colorAttachment.finalLayout <- VkImageLayout.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR

        let mutable colorAttachmentRef = default: VkAttachmentReference
        colorAttachmentRef.attachment <- 0
        colorAttachmentRef.layout <- VkImageLayout.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL

        let mutable depthAttachment = default: VkAttachmentDescription
        depthAttachment.format <- depthFormat
        depthAttachment.samples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
        depthAttachment.loadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR
        depthAttachment.storeOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE
        depthAttachment.stencilLoadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE
        depthAttachment.stencilStoreOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE
        depthAttachment.initialLayout <- VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
        depthAttachment.finalLayout <- VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL

        let mutable depthAttachmentRef = default: VkAttachmentReference
        depthAttachmentRef.attachment <- 1
        depthAttachmentRef.layout <- VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL

        let mutable subpass = default: VkSubpassDescription
        subpass.pipelineBindPoint <- VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS
        subpass.colorAttachmentCount <- 1
        subpass.pColorAttachments <- &&colorAttachmentRef
        subpass.pDepthStencilAttachment <- &&depthAttachmentRef

        let mutable dependency = default: VkSubpassDependency
        dependency.srcSubpass <- VK_SUBPASS_EXTERNAL
        dependency.dstSubpass <- 0
        dependency.srcStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VkPipelineStageFlags.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
        dependency.srcAccessMask <- default
        dependency.dstStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VkPipelineStageFlags.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
        dependency.dstAccessMask <- VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VkAccessFlags.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT

        let attachments = [colorAttachment;depthAttachment]

        let mutable attachmentsHandle = fixed(attachments)

        let mutable renderPassInfo = default: VkRenderPassCreateInfo
        renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
        renderPassInfo.attachmentCount <- uint32(attachments.Length)
        renderPassInfo.pAttachments <- Unsafe.AsPointer(attachmentsHandle.AddrOfPinnedObject())
        renderPassInfo.subpassCount <- 1
        renderPassInfo.pSubpasses <- &&subpass
        renderPassInfo.dependencyCount <- 1
        renderPassInfo.pDependencies <- &&dependency

        let mutable renderPass = default
        if (vkCreateRenderPass(device, &&renderPassInfo, nullptr, &&renderPass) != VkResult.VK_SUCCESS)
            fail("Failed to create render pass.")

        attachmentsHandle.Free()
        
        renderPass

    private createFramebuffer(device: VkDevice, renderPass: VkRenderPass, imageView: VkImageView, depthImageView: VkImageView, width: uint32, height: uint32): VkFramebuffer =
        let attachments = [imageView;depthImageView]

        let mutable attachmentsHandle = fixed(attachments)

        let mutable framebufferInfo = default: VkFramebufferCreateInfo
        framebufferInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
        framebufferInfo.renderPass <- renderPass
        framebufferInfo.attachmentCount <- uint32(attachments.Length)
        framebufferInfo.pAttachments <- Unsafe.AsPointer(attachmentsHandle.AddrOfPinnedObject())
        framebufferInfo.width <- width
        framebufferInfo.height <- height
        framebufferInfo.layers <- 1

        let mutable framebuffer = default
        if (vkCreateFramebuffer(device, &&framebufferInfo, nullptr, &&framebuffer) != VkResult.VK_SUCCESS)
            fail("Failed to create framebuffer.")

        attachmentsHandle.Free()
        
        framebuffer

    internal createCommandPool(device: VkDevice, queueFamilyIndex: uint32): VkCommandPool =
        let mutable poolInfo = default: VkCommandPoolCreateInfo
        poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
        poolInfo.flags <- VkCommandPoolCreateFlags.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
        poolInfo.queueFamilyIndex <- queueFamilyIndex

        let mutable commandPool = default
        if (vkCreateCommandPool(device, &&poolInfo, nullptr, &&commandPool) != VkResult.VK_SUCCESS)
            fail("Failed to create command pool.")

        commandPool

    private createCommandBuffer(device: VkDevice, commandPool: VkCommandPool): VkCommandBuffer =
        let mutable allocInfo = default: VkCommandBufferAllocateInfo
        allocInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
        allocInfo.commandPool <- commandPool
        allocInfo.level <- VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_PRIMARY
        allocInfo.commandBufferCount <- 1

        let mutable commandBuffer = default
        if (vkAllocateCommandBuffers(device, &&allocInfo, &&commandBuffer) != VkResult.VK_SUCCESS)
            fail("Failed to allocate command buffer.")

        commandBuffer

    private createBuffer(allocator: VmaAllocator, size: uint64, usage: VkBufferUsageFlags, flags: VmaAllocationCreateFlags, pAllocationInfo: VmaAllocationInfo*): (VkBuffer, VmaAllocation) =
        let mutable bufferInfo = default: VkBufferCreateInfo
        bufferInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
        bufferInfo.size <- size
        bufferInfo.usage <- usage

        let mutable allocInfo = default: VmaAllocationCreateInfo
        allocInfo.usage <- VmaMemoryUsage.VMA_MEMORY_USAGE_AUTO
        allocInfo.flags <- flags

        let mutable buffer = default: VkBuffer
        let mutable allocation = default: VmaAllocation
        if (vmaCreateBuffer(allocator, &&bufferInfo, &&allocInfo, &&buffer, &&allocation, pAllocationInfo) != VkResult.VK_SUCCESS)
            fail("Failed to create buffer.")

        (buffer, allocation)

    private createImage(allocator: VmaAllocator, width: uint32, height: uint32, imageFormat: VkFormat, usageFlags: VkImageUsageFlags, flags: VmaAllocationCreateFlags, pAllocationInfo: VmaAllocationInfo*): (VkImage, VmaAllocation) =
        let mutable imageInfo = default: VkImageCreateInfo
        imageInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
        imageInfo.imageType <- VkImageType.VK_IMAGE_TYPE_2D
        imageInfo.extent.width <- width
        imageInfo.extent.height <- height
        imageInfo.extent.depth <- 1
        imageInfo.mipLevels <- 1
        imageInfo.arrayLayers <- 1
        imageInfo.format <- imageFormat
        imageInfo.tiling <- VkImageTiling.VK_IMAGE_TILING_OPTIMAL
        imageInfo.initialLayout <- VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
        imageInfo.usage <- VkImageUsageFlags.VK_IMAGE_USAGE_TRANSFER_DST_BIT | VkImageUsageFlags.VK_IMAGE_USAGE_SAMPLED_BIT | usageFlags
        imageInfo.samples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
        imageInfo.sharingMode <- VkSharingMode.VK_SHARING_MODE_EXCLUSIVE

        let mutable allocInfo = default: VmaAllocationCreateInfo
        allocInfo.usage <- VmaMemoryUsage.VMA_MEMORY_USAGE_AUTO
        allocInfo.flags <- flags
        allocInfo.priority <- 1

        let mutable image = default: VkImage
        let mutable allocation = default: VmaAllocation
        if (vmaCreateImage(allocator, &&imageInfo, &&allocInfo, &&image, &&allocation, pAllocationInfo) != VkResult.VK_SUCCESS)
            fail("Failed to create image.")

        (image, allocation)

    private createVertexInputBindingDescription<T>(binding: uint32, isInstance: bool): VkVertexInputBindingDescription where T: unmanaged =
        let mutable bindingDescription = default: VkVertexInputBindingDescription
        bindingDescription.binding <- binding
        bindingDescription.stride <- uint32(sizeof<T>)
        bindingDescription.inputRate <- if (isInstance) VkVertexInputRate.VK_VERTEX_INPUT_RATE_INSTANCE else VkVertexInputRate.VK_VERTEX_INPUT_RATE_VERTEX
        bindingDescription

    private createVertexInputAttributeDescriptions<T>(binding: uint32): VkVertexInputAttributeDescription[] where T: unmanaged =
        let ty = typeof<T>
        let size = sizeof<T>
        let fields = Unsafe.AsImmutable(ty.GetFields())
        let fields = Array.Filter(fields, x -> !x.IsStatic)

        let create(location, offset, fld: System.Reflection.FieldInfo) =
            let mutable attributeDescription = default: VkVertexInputAttributeDescription
            attributeDescription.binding <- binding
            attributeDescription.location <- location
            attributeDescription.offset <- offset

            if (fld.FieldType === typeof<Vector2>)
                attributeDescription.format <- VkFormat.VK_FORMAT_R32G32_SFLOAT
                (attributeDescription, uint32(sizeof<Vector2>))
            else if (fld.FieldType === typeof<Vector3>)
                attributeDescription.format <- VkFormat.VK_FORMAT_R32G32B32_SFLOAT
                (attributeDescription, uint32(sizeof<Vector3>))
            else
                throw NotSupportedException(fld.FieldType.ToString())

        let attributeDescriptions = Array.ZeroCreate(fields.Length)
        let mutable i = 0
        let mutable currentOffset = 0: uint32
        while (i < fields.Length)
            match (create(uint32(i), currentOffset, fields[i]))
            | (attributeDescription, size) =>
                currentOffset <- currentOffset + size
                attributeDescriptions[i] <- attributeDescription
            | _ =>
                fail("should not happen")
            i <- i + 1
        Unsafe.AsImmutable(attributeDescriptions)

    private createDescriptorSetLayout(device: VkDevice, mutable bindingInfos: ReadOnlySpan<VulkanDescriptorBindingInfo>): VkDescriptorSetLayout =

        let layoutBindings = Array.ZeroCreate(bindingInfos.Length)

        let mutable i = 0
        while (i < layoutBindings.Length)
            let info = bindingInfos[i]

            let mutable layoutBinding = default: VkDescriptorSetLayoutBinding
            layoutBinding.binding <- info.Binding
            layoutBinding.descriptorType <- info.DescriptorType
            layoutBinding.descriptorCount <- 1
            layoutBinding.stageFlags <- info.StageFlags
            layoutBinding.pImmutableSamplers <- nullptr

            layoutBindings[i] <- layoutBinding
            i <- i + 1

        let mutable layoutBindingsHandle = fixed(layoutBindings)

        let mutable layoutInfo = default: VkDescriptorSetLayoutCreateInfo
        layoutInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
        layoutInfo.bindingCount <- uint32(layoutBindings.Length)
        layoutInfo.pBindings <- Unsafe.AsPointer(layoutBindingsHandle.AddrOfPinnedObject())

        let mutable descriptorSetLayout = default: VkDescriptorSetLayout
        if (vkCreateDescriptorSetLayout(device, &&layoutInfo, nullptr, &&descriptorSetLayout) != VkResult.VK_SUCCESS)
            fail("Failed to create descriptor set layout.")

        layoutBindingsHandle.Free()

        descriptorSetLayout

    private createDescriptorPool(device: VkDevice, mutable descriptorTypes: ReadOnlySpan<VkDescriptorType>, descriptorCount: uint32): VkDescriptorPool =

        let poolSizes = Array.ZeroCreate(descriptorTypes.Length)

        let mutable i = 0
        while (i < poolSizes.Length)
            let descriptorType = descriptorTypes[i]

            let mutable poolSize = default: VkDescriptorPoolSize
            poolSize.`type` <- descriptorType
            poolSize.descriptorCount <- descriptorCount

            poolSizes[i] <- poolSize
            i <- i + 1

        let mutable poolSizesHandle = fixed(poolSizes)

        let mutable poolInfo = default: VkDescriptorPoolCreateInfo
        poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
        poolInfo.poolSizeCount <- uint32(poolSizes.Length)
        poolInfo.pPoolSizes <- Unsafe.AsPointer(poolSizesHandle.AddrOfPinnedObject())
        poolInfo.maxSets <- descriptorCount

        let mutable descriptorPool = default: VkDescriptorPool
        if (vkCreateDescriptorPool(device, &&poolInfo, nullptr, &&descriptorPool) != VkResult.VK_SUCCESS)
            fail("Failed to create descriptor pool.")

        poolSizesHandle.Free()

        descriptorPool

    private createDescriptorSets(device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: uint32, setLayout: VkDescriptorSetLayout): VkDescriptorSet[] =
        let setLayouts = Array.Initialize(int32(descriptorSetCount), i -> setLayout)
        let mutable setLayoutsHandle = fixed(setLayouts)

        let mutable allocInfo = default: VkDescriptorSetAllocateInfo
        allocInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
        allocInfo.descriptorPool <- descriptorPool
        allocInfo.descriptorSetCount <- descriptorSetCount
        allocInfo.pSetLayouts <- Unsafe.AsPointer(setLayoutsHandle.AddrOfPinnedObject())

        let mutable descriptorSets = Array.ZeroCreate<VkDescriptorSet>(int32(descriptorSetCount))
        let mutable descriptorSetsHandle = fixed(descriptorSets)
        let descriptorSetsPtr = Unsafe.AsPointer(descriptorSetsHandle.AddrOfPinnedObject())
        if (vkAllocateDescriptorSets(device, &&allocInfo, descriptorSetsPtr) != VkResult.VK_SUCCESS)
            fail("Failed to allocate descriptor sets.")

        setLayoutsHandle.Free()
        descriptorSetsHandle.Free()

        Unsafe.AsImmutable(descriptorSets)

    private updateDescriptorSet(device: VkDevice, binding: uint32, descriptorSet: VkDescriptorSet, buffer: VkBuffer, offset: uint64, size: uint64, descriptorType: VkDescriptorType): () =
        let mutable bufferInfo = default: VkDescriptorBufferInfo
        bufferInfo.offset <- offset
        bufferInfo.buffer <- buffer
        bufferInfo.range <- size

        let mutable descriptorWrite = default: VkWriteDescriptorSet
        descriptorWrite.sType <- VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
        descriptorWrite.dstSet <- descriptorSet
        descriptorWrite.dstBinding <- binding
        descriptorWrite.dstArrayElement <- 0

        descriptorWrite.descriptorType <- descriptorType
        descriptorWrite.descriptorCount <- 1

        descriptorWrite.pBufferInfo <- &&bufferInfo
        descriptorWrite.pImageInfo <- nullptr // Optional
        descriptorWrite.pTexelBufferView <- nullptr // Optional

        vkUpdateDescriptorSets(device, 1, &&descriptorWrite, 0, nullptr)

    private updateDescriptorSet(device: VkDevice, binding: uint32, descriptorSet: VkDescriptorSet, imageLayout: VkImageLayout, imageView: VkImageView, sampler: VkSampler, descriptorType: VkDescriptorType): () =
        let mutable imageInfo = default: VkDescriptorImageInfo
        imageInfo.imageLayout <- imageLayout
        imageInfo.imageView <- imageView
        imageInfo.sampler <- sampler

        let mutable descriptorWrite = default: VkWriteDescriptorSet
        descriptorWrite.sType <- VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
        descriptorWrite.dstSet <- descriptorSet
        descriptorWrite.dstBinding <- binding
        descriptorWrite.dstArrayElement <- 0

        descriptorWrite.descriptorType <- descriptorType
        descriptorWrite.descriptorCount <- 1

        descriptorWrite.pBufferInfo <- nullptr
        descriptorWrite.pImageInfo <- &&imageInfo
        descriptorWrite.pTexelBufferView <- nullptr

        vkUpdateDescriptorSets(device, 1, &&descriptorWrite, 0, nullptr)

    // -----------------------------------------------------------------------

    private getInstanceLayerProperties(): VkLayerProperties[] =
        let mutable layerCount = 0: uint32

        if (vkEnumerateInstanceLayerProperties(&&layerCount, nullptr) != VkResult.VK_SUCCESS)
            fail("Failed to enumerate instance layer properties.")

        let availableLayers = Array.ZeroCreate<VkLayerProperties>(int32(layerCount))
        let mutable availableLayersHandle = fixed(availableLayers)
        if (vkEnumerateInstanceLayerProperties(&&layerCount, Unsafe.AsPointer(availableLayersHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
            fail("Failed to enumerate instance layer properties.")
        availableLayersHandle.Free()

        Unsafe.AsImmutable(availableLayers)

    private getPhysicalDevices(instance: VkInstance): VkPhysicalDevice[] =
        let mutable deviceCount = 0: uint32

        if (vkEnumeratePhysicalDevices(instance, &&deviceCount, nullptr) != VkResult.VK_SUCCESS)
            fail("Failed to enumerate physical devices.")

        let availableDevices = Array.ZeroCreate<VkPhysicalDevice>(int32(deviceCount))
        let mutable availableDevicesHandle = fixed(availableDevices)
        if (vkEnumeratePhysicalDevices(instance, &&deviceCount, Unsafe.AsPointer(availableDevicesHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
            fail("Failed to enumerate physical devices.")
        availableDevicesHandle.Free()

        Unsafe.AsImmutable(availableDevices)

    private getPhysicalDeviceQueueFamilyProperties(device: VkPhysicalDevice): VkQueueFamilyProperties[] =
        let mutable queueFamilyCount = 0: uint32

        vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, nullptr)

        let queueFamilies = Array.ZeroCreate<VkQueueFamilyProperties>(int32(queueFamilyCount))
        let mutable queueFamiliesHandle = fixed(queueFamilies)
        vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, Unsafe.AsPointer(queueFamiliesHandle.AddrOfPinnedObject()))
        queueFamiliesHandle.Free()

        Unsafe.AsImmutable(queueFamilies)

    private getDeviceExtensionProperties(device: VkPhysicalDevice): VkExtensionProperties[] =
        let mutable extensionCount = 0: uint32

        let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, nullptr)

        let extensions = Array.ZeroCreate<VkExtensionProperties>(int32(extensionCount))
        let mutable extensionsHandle = fixed(extensions)
        let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, Unsafe.AsPointer(extensionsHandle.AddrOfPinnedObject()))
        extensionsHandle.Free()

        Unsafe.AsImmutable(extensions)

    private getSwapChainImages(device: VkDevice, swapChain: VkSwapchainKHR): VkImage[] =
        let mutable imageCount = 0: uint32
        let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, nullptr)
        
        let images = Array.ZeroCreate<VkImage>(int32(imageCount))
        let mutable imagesHandle = fixed(images)
        let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, Unsafe.AsPointer(imagesHandle.AddrOfPinnedObject()))
        imagesHandle.Free()

        Unsafe.AsImmutable(images)

    // -----------------------------------------------------------------------

    private findSuitableDevice(devices: VkPhysicalDevice[]): VkPhysicalDevice =
        Array.MaxByUInt32(devices, getDeviceSuitableScore)

    private getDeviceSuitableScore(device: VkPhysicalDevice): uint32 =
        let mutable deviceProperties = default: VkPhysicalDeviceProperties
        let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

        vkGetPhysicalDeviceProperties(device, &&deviceProperties)
        vkGetPhysicalDeviceFeatures(device, &&deviceFeatures)

        let score =
            match (deviceProperties.deviceType)
            | VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU when (deviceFeatures.geometryShader == VkBool32.TRUE) =>
                1000 + deviceProperties.limits.maxImageDimension2D
            | _ =>
                0

        score

    internal getPhysicalDeviceProperties(device: VkPhysicalDevice): VkPhysicalDeviceProperties =
        let mutable deviceProperties = default: VkPhysicalDeviceProperties
        vkGetPhysicalDeviceProperties(device, &&deviceProperties)
        deviceProperties

    private checkValidationLayerSupport(validationLayers: string[]): bool =
        if (validationLayers.Length == 0)
            true
        else
            let availableLayers = getInstanceLayerProperties()

            let mutable found = true

            let mutable i = 0
            while (i < validationLayers.Length)
                let mutable foundLayer = false

                let mutable j = 0
                while (j < availableLayers.Length)
                    let layerProperties = availableLayers[j]
                    let layerName = String(Unsafe.AsPointer(&&layerProperties.layerName): int8*)
                    if (layerName == validationLayers[i])
                        foundLayer <- true
                    j <- j + 1

                if (!foundLayer)
                    found <- false

                i <- i + 1

            found

    private checkExtensionsSupport(device: VkPhysicalDevice, deviceExtensions: string[]): bool =
        if (deviceExtensions.Length == 0)
            true
        else
            let availableExtensions = getDeviceExtensionProperties(device)

            let mutable found = true

            let mutable i = 0
            while (i < deviceExtensions.Length)
                let mutable foundExtension = false

                let mutable j = 0
                while (j < availableExtensions.Length)
                    let extensionProperties = availableExtensions[j]
                    let extensionName = String(Unsafe.AsPointer(&&extensionProperties.extensionName): int8*)
                    if (extensionName == deviceExtensions[i])
                        foundExtension <- true
                    j <- j + 1

                if (!foundExtension)
                    found <- false

                i <- i + 1

            found

    private transitionImageLayout(commandBuffer: VkCommandBuffer, image: VkImage, format: VkFormat, oldLayout: VkImageLayout, newLayout: VkImageLayout): () =
        let mutable barrier = default: VkImageMemoryBarrier
        barrier.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
        barrier.oldLayout <- oldLayout
        barrier.newLayout <- newLayout
        barrier.srcQueueFamilyIndex <- VK_QUEUE_FAMILY_IGNORED
        barrier.dstQueueFamilyIndex <- VK_QUEUE_FAMILY_IGNORED
        barrier.image <- image
        barrier.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
        barrier.subresourceRange.baseMipLevel <- 0
        barrier.subresourceRange.levelCount <- 1
        barrier.subresourceRange.baseArrayLayer <- 0
        barrier.subresourceRange.layerCount <- 1

        // Default transition
        barrier.srcAccessMask <- default
        barrier.dstAccessMask <- VkAccessFlags.VK_ACCESS_TRANSFER_WRITE_BIT
        let mutable sourceStage = VkPipelineStageFlags.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
        let mutable destinationStage = VkPipelineStageFlags.VK_PIPELINE_STAGE_TRANSFER_BIT

        if (newLayout == VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
            barrier.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_DEPTH_BIT
        
            if (hasStencilComponent(format))
                barrier.subresourceRange.aspectMask <- barrier.subresourceRange.aspectMask | VkImageAspectFlags.VK_IMAGE_ASPECT_STENCIL_BIT
        else
            barrier.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT

        match (oldLayout, newLayout)
        | VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED, VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL => ()

        | VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED, VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL =>
            barrier.dstAccessMask <- VkAccessFlags.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VkAccessFlags.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
            sourceStage <- VkPipelineStageFlags.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
            destinationStage <- VkPipelineStageFlags.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT

        | VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL =>
            barrier.srcAccessMask <- VkAccessFlags.VK_ACCESS_TRANSFER_WRITE_BIT
            barrier.dstAccessMask <- VkAccessFlags.VK_ACCESS_SHADER_READ_BIT
            sourceStage <- VkPipelineStageFlags.VK_PIPELINE_STAGE_TRANSFER_BIT
            destinationStage <- VkPipelineStageFlags.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT

        | _ =>
            ()
            //fail("Invalid image layout transition.")

        vkCmdPipelineBarrier(
            commandBuffer,
            sourceStage, destinationStage,
            default,
            0, nullptr,
            0, nullptr,
            1, &&barrier
        )

    private createSampler(device: VkDevice, maxAnisotropy: float32): VkSampler =
        let mutable samplerInfo = default: VkSamplerCreateInfo
        samplerInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
        samplerInfo.magFilter <- VkFilter.VK_FILTER_NEAREST
        samplerInfo.minFilter <- VkFilter.VK_FILTER_NEAREST
        samplerInfo.addressModeU <- VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_REPEAT
        samplerInfo.addressModeV <- VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_REPEAT
        samplerInfo.addressModeW <- VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_REPEAT
        samplerInfo.anisotropyEnable <- if (maxAnisotropy == 1) VkBool32.FALSE else VkBool32.TRUE
        samplerInfo.maxAnisotropy <- maxAnisotropy
        samplerInfo.borderColor <- VkBorderColor.VK_BORDER_COLOR_INT_OPAQUE_BLACK
        samplerInfo.unnormalizedCoordinates <- VkBool32.FALSE
        samplerInfo.compareEnable <- VkBool32.FALSE
        samplerInfo.compareOp <- VkCompareOp.VK_COMPARE_OP_ALWAYS
        samplerInfo.mipmapMode <- VkSamplerMipmapMode.VK_SAMPLER_MIPMAP_MODE_LINEAR
        samplerInfo.mipLodBias <- 0
        samplerInfo.minLod <- 0
        samplerInfo.maxLod <- 0

        let mutable sampler = default
        if (vkCreateSampler(device, &&samplerInfo, nullptr, &&sampler) != VkResult.VK_SUCCESS)
            fail("Failed to create sampler.")

        sampler
    // -----------------------------------------------------------------------

    private draw(mutable swapChain: VkSwapchainKHR, graphicsQueue: VkQueue, presentQueue: VkQueue, commandBuffer: VkCommandBuffer, mutable imageIndex: uint32, imageAvailableSemaphore: VkSemaphore, renderFinishedSemaphore: VkSemaphore, inFlightFence: VkFence): VkResult =
        let mutable submitInfo = default: VkSubmitInfo
        submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO

        let mutable waitSemaphore = imageAvailableSemaphore
        let mutable waitStage = VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT

        submitInfo.waitSemaphoreCount <- 1
        submitInfo.pWaitSemaphores <- &&waitSemaphore
        submitInfo.pWaitDstStageMask <- &&waitStage
        submitInfo.commandBufferCount <- 1
        submitInfo.pCommandBuffers <- &&commandBuffer

        let mutable signalSemaphore = renderFinishedSemaphore
        
        submitInfo.signalSemaphoreCount <- 1
        submitInfo.pSignalSemaphores <- &&signalSemaphore

        if (vkQueueSubmit(graphicsQueue, 1, &&submitInfo, inFlightFence) != VkResult.VK_SUCCESS)
            fail("Failed to submit draw command buffer.")

        let mutable presentInfo = default: VkPresentInfoKHR
        presentInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR

        presentInfo.waitSemaphoreCount <- 1
        presentInfo.pWaitSemaphores <- &&signalSemaphore

        presentInfo.swapchainCount <- 1
        presentInfo.pSwapchains <- &&swapChain

        presentInfo.pImageIndices <- &&imageIndex
        presentInfo.pResults <- nullptr // Optional

        vkQueuePresentKHR(presentQueue, &&presentInfo)