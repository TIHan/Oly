namespace Evergreen.Graphics.Rendering.UI

open System
open System.Numerics
open System.Collections.Generic
open System.Threading
open Evergreen
open Evergreen.Graphics.Rendering

private alias Array = OlyPrelude.Array

private module Span =

    TryFindIndex<T>(mutable span: Span<T>, predicate: T -> bool): int32 =
        let mutable isFound = false
        let mutable i = 0
        while (i < span.Length && !isFound)
            let item = span[i]
            if (predicate(item))
                isFound <- true
            else
                i <- i + 1
        if (isFound)
            i
        else
            -1

// abstract class UIModel =

//     IsEnabled: bool get, set = true
//     Size: Vector2 get, set = Vector2.Zero

// class CheckboxModel =
//     inherits UIModel

//     Label: string get, set = string.Empty
//     IsChecked: bool get, set = false

// class ComboBoxModel =
//     inherits UIModel

//     Label: string get, set = string.Empty
//     SelectedItemIndex: int32 get, set = 0
//     Items: mutable string[] get, set = mutable []
//     ItemCount: int32 get, set = 0

abstract class View =

    static field NextId: uint64 = 0
    field Tag: int32
    internal field Id: uint64

    IsEnabled: bool get, set
    Size: Vector2 get, set

    internal new(tag: int32) = 
        { 
            Tag = tag
            Id = Interlocked.Increment(&NextId)
            IsEnabled = true
            Size = Vector2.Zero
        }

    pattern Window(view: View): WindowView when (view.Tag == 0) =>
        Unsafe.Cast<WindowView>(view)

    pattern Button(view: View): ButtonView when (view.Tag == 1) =>
        Unsafe.Cast<ButtonView>(view)

    pattern TextInput(view: View): TextInputView when (view.Tag == 2) =>
        Unsafe.Cast<TextInputView>(view)

    pattern Label(view: View): LabelView when (view.Tag == 3) =>
        Unsafe.Cast<LabelView>(view)

    pattern Image(view: View): ImageView when (view.Tag == 4) =>
        Unsafe.Cast<ImageView>(view)

    // internal class Checkbox =
    //     inherits UINode

    //     State: CheckboxModel get
    //     OnChanged: () -> () get

    //     new(state: CheckboxModel, onChanged: () -> ()) =
    //         base (10) with {
    //             State = state
    //             OnChanged = onChanged
    //         }

    // pattern Checkbox(node: UINode): (state: CheckboxModel, onChanged: () -> ()) when (node.Tag == 10) =>
    //     let node = Unsafe.Cast<Checkbox>(node)
    //     (node.State, node.OnChanged)

    // internal class ComboBox =
    //     inherits UINode

    //     State: ComboBoxModel get
    //     OnChanged: () -> () get

    //     new(state: ComboBoxModel, onChanged: () -> ()) =
    //         base (11) with {
    //             State = state
    //             OnChanged = onChanged
    //         }

    // pattern ComboBox(node: UINode): (state: ComboBoxModel, onChanged: () -> ()) when (node.Tag == 11) =>
    //     let node = Unsafe.Cast<ComboBox>(node)
    //     (node.State, node.OnChanged)

    // internal class DemoWindow =
    //     inherits UINode

    //     new() = base(100)

    // pattern DemoWindow(node: UINode): () when (node.Tag == 100) =>
    //     ()

class WindowView =
    inherits View

    new() = 
        base(0) with {
            Children = List()

            IsOpen = true
            Position = Vector2.Zero

            titleBuffer = Array.ZeroCreate(256)
            titleBufferLength = 0
            title = ""
        }

    Children: List<View> get

    IsOpen: bool get, set
    Position: Vector2 get, set

    field titleBuffer: mutable byte[]
    mutable field titleBufferLength: int32
    mutable field title: string
    internal TitleSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.titleBuffer, 0, this.titleBufferLength)
    Title: string
        get() = this.title
        set(mutable value) =
            // if (string.IsNullOrWhiteSpace(value))
            //     value <- "##"
            this.title <- value
            this.titleBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.title, 0, this.title.Length, this.titleBuffer, 0)

class ButtonView =
    inherits View

    new() =
        base(1) with {
            labelBuffer = Array.ZeroCreate(256)
            labelBufferLength = 0
            label = ""

            OnClick = () -> ()
        }

    field labelBuffer: mutable byte[]
    mutable field labelBufferLength: int32
    mutable field label: string
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(mutable value) =
            // if (string.IsNullOrWhiteSpace(value))
            //     value <- "##"
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    OnClick: () -> () get, set

class TextInputView =
    inherits View

    new() =
        base(2) with {
            labelBuffer = Array.ZeroCreate(256)
            labelBufferLength = 0
            label = ""

            textBuffer = Array.ZeroCreate(256)
            text = string.Empty

            OnTextChanged = () -> ()
        }

    field labelBuffer: mutable byte[]
    mutable field labelBufferLength: int32
    mutable field label: string
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(mutable value) =
            // if (string.IsNullOrWhiteSpace(value))
            //     value <- "##"
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    field textBuffer: mutable byte[]
    mutable field text: string
    internal TextSpan: Span<byte> get() = Span(this.textBuffer, 0, this.textBuffer.Length)
    Text: string
        get() = this.text
        set(value) = 
            this.text <- value
            let byteCount = System.Text.Encoding.UTF8.GetBytes(this.text, 0, this.text.Length, this.textBuffer, 0)

    OnTextChanged: () -> () get, set

class LabelView =
    inherits View

    new() =
        base(3) with {
            labelBuffer = Array.ZeroCreate(256)
            labelBufferLength = 0
            label = ""

            textBuffer = Array.ZeroCreate(256)
            text = string.Empty
        }

    field labelBuffer: mutable byte[]
    mutable field labelBufferLength: int32
    mutable field label: string
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(mutable value) =
            // if (string.IsNullOrWhiteSpace(value))
            //     value <- "##"
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    field textBuffer: mutable byte[]
    mutable field text: string
    internal TextSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.textBuffer, 0, this.textBuffer.Length)
    Text: string
        get() = this.text
        set(value) = 
            this.text <- value
            let byteCount = System.Text.Encoding.UTF8.GetBytes(this.text, 0, this.text.Length, this.textBuffer, 0)

class ImageView =
    inherits View

    new() =
        base(4) with {
            descriptorSet = Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL
            gpuImage = unchecked default
            isDirty = false
        }

    internal mutable field isDirty: bool
    internal mutable field descriptorSet: Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet
    internal mutable field gpuImage: GpuImage
    GpuImage: GpuImage 
        get() = this.gpuImage
        set(value) =
            this.gpuImage <- value 
            this.isDirty <- true

class UIContext =

    internal Gpu: Gpu get
    internal GpuProgramUI: GpuProgramUI get

    internal ImGuiContext: ImGui.ImGuiContext get() = this.GpuProgramUI.ImGuiContext

    internal new(gpu: Gpu, gpuProgramUI: GpuProgramUI) =
        {
            Gpu = gpu
            GpuProgramUI = gpuProgramUI
        }

module UI =

    private MakeNode(context: UIContext, view: View): () =
        ImGui.PushId(context.ImGuiContext, Unsafe.Cast(view.Id))
        ImGui.BeginDisabled(context.ImGuiContext, !view.IsEnabled)
        match (view)
        | View.Window(view) =>
            ImGui.SetWindowSize(context.ImGuiContext, view.Size)
            ImGui.SetWindowPosition(context.ImGuiContext, view.Position)
            MakeWindow(context, view)
        
        | View.Button(view) =>
            MakeButton(context, view)

        | View.TextInput(view) =>
            MakeTextInput(context, view)

        | View.Label(view) =>
            MakeLabel(context, view)

        | View.Image(view) =>
            MakeImage(context, view)

        // | UINode.DemoWindow =>
        //     ImGui.ShowDemoWindow(context)

        // | UINode.Int32Input(state, onChanged) =>
        //     MakeInt32Input(state, onChanged)

        // | UINode.Checkbox(state, onChanged) =>
        //     MakeCheckbox(state, onChanged)

        // | UINode.ComboBox(state, onChanged) =>
        //     MakeComboBox(state, onChanged)

        | _ =>
            ()

        ImGui.EndDisabled(context.ImGuiContext)
        ImGui.PopId(context.ImGuiContext)

    private MakeWindow(context: UIContext, view: WindowView): () =
        let mutable isOpen = view.IsOpen
        if (isOpen && ImGui.Begin(context.ImGuiContext, &isOpen, true, view.TitleSpan))
            let mutable i = 0
            while (i < view.Children.Count)
                MakeNode(context, view.Children[i])
                i <- i + 1
            ImGui.End(context.ImGuiContext)
        view.IsOpen <- isOpen

    private MakeButton(context: UIContext, view: ButtonView): () =
        if (ImGui.Button(context.ImGuiContext, view.LabelSpan, view.Size))
            context.ImGuiContext.Callbacks.Enqueue(view.OnClick)

    private MakeTextInput(context: UIContext, view: TextInputView): () =
        if (ImGui.InputText(context.ImGuiContext, view.LabelSpan, view.TextSpan))
            let mutable textSpan = view.TextSpan
            let indexZero = Span.TryFindIndex(textSpan, x -> x == 0)
            let textSpan = 
                if (indexZero == -1)
                    textSpan
                else
                    textSpan.Slice(0, indexZero)
            view.Text <- System.Text.Encoding.UTF8.GetString(Span<_>.op_Implicit(textSpan))
            context.ImGuiContext.Callbacks.Enqueue(view.OnTextChanged)

    private MakeLabel(context: UIContext, view: LabelView): () =
        ImGui.LabelText(context.ImGuiContext, view.LabelSpan, view.TextSpan)

    private MakeImage(context: UIContext, view: ImageView): () =
        if (view.isDirty)
            view.isDirty <- false
            
            if (view.descriptorSet != Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL)
                ImGui.DestroyTexture(context.ImGuiContext, view.descriptorSet)
            view.descriptorSet <-
                context.Gpu.Sync(view.gpuImage)
                ImGui.CreateTexture(context.ImGuiContext, view.gpuImage.VkSampler, view.gpuImage.VkImageView, Evergreen.Graphics.Backend.Vulkan.VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                    () ->
                        view.descriptorSet <- Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL
                        view.isDirty <- true
                )

        if (view.descriptorSet != Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL)
            ImGui.Image(context.ImGuiContext, view.descriptorSet, view.Size, Vector2.Zero, Vector2.One)

    // private MakeInt32Input(state: Int32InputViewModel, onChanged: Int32InputViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.InputInt(state.Label, &state.Value))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeCheckbox(state: CheckboxViewModel, onChanged: CheckboxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Checkbox(state.Label, &state.IsChecked))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeComboBox(state: ComboBoxViewModel, onChanged: ComboBoxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Combo(state.Label, &state.SelectedItemIndex, state.Items, state.ItemCount))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    NewFrame(context: UIContext): () =
        ImGui.NewFrame(context.ImGuiContext)

    Show(context: UIContext, view: View): () =
        MakeNode(context, view)
        let mutable callback = unchecked default
        while (context.ImGuiContext.Callbacks.TryDequeue(&callback))
            callback()

    Draw(context: UIContext, commandBuffer: TerraFX.Interop.Vulkan.VkCommandBuffer, pipeline: TerraFX.Interop.Vulkan.VkPipeline): () =
        ImGui.Draw(context.ImGuiContext, commandBuffer, pipeline)
