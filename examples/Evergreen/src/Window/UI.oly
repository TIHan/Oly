namespace Evergreen.UI

open System
open System.Numerics
open System.Collections.Generic
open Evergreen
open Evergreen.Graphics

private alias Array = OlyPrelude.Array

private module Span =

    TryFindIndex<T>(mutable span: Span<T>, predicate: T -> bool): int32 =
        let mutable isFound = false
        let mutable i = 0
        while (i < span.Length && !isFound)
            let item = span[i]
            if (predicate(item))
                isFound <- true
            else
                i <- i + 1
        if (isFound)
            i
        else
            -1

abstract class UIModel =

    IsEnabled: bool get, set = true
    Size: Vector2 get, set = Vector2.Zero

class WindowModel =
    inherits UIModel

    IsOpen: bool get, set = true
    Position: Vector2 get, set = Vector2.Zero

    field titleBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field titleBufferLength: int32 = 0
    mutable field title: string = string.Empty
    internal TitleSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.titleBuffer, 0, this.titleBufferLength)
    Title: string
        get() = this.title
        set(value) =
            this.title <- value
            this.titleBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.title, 0, this.title.Length, this.titleBuffer, 0)

class ButtonModel =
    inherits UIModel

    field labelBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field labelBufferLength: int32 = 0
    mutable field label: string = string.Empty
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(value) =
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

class TextInputModel =
    inherits UIModel

    field labelBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field labelBufferLength: int32 = 0
    mutable field label: string = string.Empty
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(value) =
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    field textBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field text: string = string.Empty
    internal TextSpan: Span<byte> get() = Span(this.textBuffer, 0, this.textBuffer.Length)
    Text: string
        get() = this.text
        set(value) = 
            this.text <- value
            let byteCount = System.Text.Encoding.UTF8.GetBytes(this.text, 0, this.text.Length, this.textBuffer, 0)

class Int32InputModel =
    inherits UIModel

    Label: string get, set = string.Empty
    Value: int32 get, set = 0

class LabelModel =
    inherits UIModel
    
    field labelBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field labelBufferLength: int32 = 0
    mutable field label: string = string.Empty
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(value) =
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    field textBuffer: mutable byte[] = Array.ZeroCreate(256)
    mutable field text: string = string.Empty
    internal TextSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.textBuffer, 0, this.textBuffer.Length)
    Text: string
        get() = this.text
        set(value) = 
            this.text <- value
            let byteCount = System.Text.Encoding.UTF8.GetBytes(this.text, 0, this.text.Length, this.textBuffer, 0)

class ImageModel =
    inherits UIModel

    internal mutable field descriptorSet: Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet = Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL
    internal mutable field gpuImage: Evergreen.Game.Rendering.GpuImage = unchecked default
    GpuImage: Evergreen.Game.Rendering.GpuImage get() = this.gpuImage

class CheckboxModel =
    inherits UIModel

    Label: string get, set = string.Empty
    IsChecked: bool get, set = false

class ComboBoxModel =
    inherits UIModel

    Label: string get, set = string.Empty
    SelectedItemIndex: int32 get, set = 0
    Items: mutable string[] get, set = mutable []
    ItemCount: int32 get, set = 0

abstract class View =

    field Tag: int32

    IsEnabled: bool get, set
    Size: Vector2 get, set

    internal new(tag: int32) = 
        { 
            Tag = tag
            IsEnabled = true
            Size = Vector2.Zero
        }

    pattern Window(view: View): WindowView when (view.Tag == 0) =>
        Unsafe.Cast<WindowView>(view)

    // internal class Button =
    //     inherits UINode

    //     State: ButtonModel get
    //     OnClick: () -> () get

    //     new(state: ButtonModel, onClick: () -> ()) =
    //         base(1) with {
    //             State = state
    //             OnClick = onClick
    //         }

    // pattern Button(node: UINode): (state: ButtonModel, onClick: () -> ()) when (node.Tag == 1) =>
    //     let node = Unsafe.Cast<Button>(node)
    //     (node.State, node.OnClick)

    // internal class TextInput =
    //     inherits UINode

    //     State: TextInputModel get
    //     OnTextChanged: () -> () get

    //     new(state: TextInputModel, onTextChanged: () -> ()) =
    //         base(2) with {
    //             State = state
    //             OnTextChanged = onTextChanged
    //         }

    // pattern TextInput(node: UINode): (state: TextInputModel, onTextChanged: () -> ()) when (node.Tag == 2) =>
    //     let node = Unsafe.Cast<TextInput>(node)
    //     (node.State, node.OnTextChanged)

    // internal class Int32Input =
    //     inherits UINode

    //     State: Int32InputModel get
    //     OnChanged: () -> () get

    //     new(state: Int32InputModel, onChanged: () -> ()) =
    //         base(3) with {
    //             State = state
    //             OnChanged = onChanged
    //         }

    // pattern Int32Input(node: UINode): (state: Int32InputModel, onChanged: () -> ()) when (node.Tag == 3) =>
    //     let node = Unsafe.Cast<Int32Input>(node)
    //     (node.State, node.OnChanged)

    // internal class Label =
    //     inherits UINode

    //     State: LabelModel get

    //     new(state: LabelModel) =
    //         base(4) with {
    //             State = state
    //         }

    // pattern Label(node: UINode): LabelModel when (node.Tag == 4) =>
    //     let node = Unsafe.Cast<Label>(node)
    //     node.State

    // internal class Image =
    //     inherits UINode

    //     State: ImageModel get

    //     new(state: ImageModel) =
    //         base(5) with {
    //             State = state
    //         }

    // pattern Image(node: UINode): ImageModel when (node.Tag == 5) =>
    //     let node = Unsafe.Cast<Image>(node)
    //     node.State

    // internal class Checkbox =
    //     inherits UINode

    //     State: CheckboxModel get
    //     OnChanged: () -> () get

    //     new(state: CheckboxModel, onChanged: () -> ()) =
    //         base (10) with {
    //             State = state
    //             OnChanged = onChanged
    //         }

    // pattern Checkbox(node: UINode): (state: CheckboxModel, onChanged: () -> ()) when (node.Tag == 10) =>
    //     let node = Unsafe.Cast<Checkbox>(node)
    //     (node.State, node.OnChanged)

    // internal class ComboBox =
    //     inherits UINode

    //     State: ComboBoxModel get
    //     OnChanged: () -> () get

    //     new(state: ComboBoxModel, onChanged: () -> ()) =
    //         base (11) with {
    //             State = state
    //             OnChanged = onChanged
    //         }

    // pattern ComboBox(node: UINode): (state: ComboBoxModel, onChanged: () -> ()) when (node.Tag == 11) =>
    //     let node = Unsafe.Cast<ComboBox>(node)
    //     (node.State, node.OnChanged)

    // internal class DemoWindow =
    //     inherits UINode

    //     new() = base(100)

    // pattern DemoWindow(node: UINode): () when (node.Tag == 100) =>
    //     ()

class WindowView =
    inherits View

    new() = 
        base(0) with {
            Children = List()

            IsOpen = true
            Position = Vector2.Zero

            titleBuffer = Array.ZeroCreate(256)
            titleBufferLength = 0
            title = string.Empty
        }

    Children: List<View> get

    IsOpen: bool get, set
    Position: Vector2 get, set

    field titleBuffer: mutable byte[]
    mutable field titleBufferLength: int32
    mutable field title: string
    internal TitleSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.titleBuffer, 0, this.titleBufferLength)
    Title: string
        get() = this.title
        set(value) =
            this.title <- value
            this.titleBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.title, 0, this.title.Length, this.titleBuffer, 0)

module UI =

    private MakeNode(context: ImGui.ImGuiContext, view: View): () =
        match (view)
        | View.Window(view) =>
            ImGui.SetWindowSize(context, view.Size)
            ImGui.SetWindowPosition(context, view.Position)
            ImGui.BeginDisabled(context, !view.IsEnabled)
            MakeWindow(context, view)
            ImGui.EndDisabled(context)
        
        // | UINode.Button(state, onClick) =>
        //     ImGui.BeginDisabled(context, !state.IsEnabled)
        //     MakeButton(context, state, onClick)
        //     ImGui.EndDisabled(context)

        // | UINode.TextInput(state, onChanged) =>
        //     ImGui.BeginDisabled(context, !state.IsEnabled)
        //     MakeTextInput(context, state, onChanged)
        //     ImGui.EndDisabled(context)

        // | UINode.Label(state) =>
        //     ImGui.BeginDisabled(context, !state.IsEnabled)
        //     MakeLabel(context, state)
        //     ImGui.EndDisabled(context)

        // | UINode.Image(state) =>
        //     ImGui.BeginDisabled(context, !state.IsEnabled)
        //     MakeImage(context, state)
        //     ImGui.EndDisabled(context)

        // | UINode.DemoWindow =>
        //     ImGui.ShowDemoWindow(context)

        // | UINode.Int32Input(state, onChanged) =>
        //     MakeInt32Input(state, onChanged)

        // | UINode.Checkbox(state, onChanged) =>
        //     MakeCheckbox(state, onChanged)

        // | UINode.ComboBox(state, onChanged) =>
        //     MakeComboBox(state, onChanged)

        | _ =>
            ()

    private MakeWindow(context: ImGui.ImGuiContext, view: WindowView): () =
        let mutable isOpen = view.IsOpen
        if (isOpen && ImGui.Begin(context, &isOpen, true, view.TitleSpan))
            let mutable i = 0
            while (i < view.Children.Count)
                MakeNode(context, view.Children[i])
                i <- i + 1
            ImGui.End(context)
        view.IsOpen <- isOpen

    private MakeButton(context: ImGui.ImGuiContext, state: ButtonModel, onClick: () -> ()): () =
        if (ImGui.Button(context, state.LabelSpan, state.Size))
            context.Callbacks.Enqueue(onClick)

    private MakeTextInput(context: ImGui.ImGuiContext, state: TextInputModel, onTextChanged: () -> ()): () =
        if (ImGui.InputText(context, state.LabelSpan, state.TextSpan))
            let mutable textSpan = state.TextSpan
            let indexZero = Span.TryFindIndex(textSpan, x -> x == 0)
            let textSpan = 
                if (indexZero == -1)
                    textSpan
                else
                    textSpan.Slice(0, indexZero)
            state.Text <- System.Text.Encoding.UTF8.GetString(Span<_>.op_Implicit(textSpan))
            context.Callbacks.Enqueue(onTextChanged)

    private MakeLabel(context: ImGui.ImGuiContext, state: LabelModel): () =
        ImGui.LabelText(context, state.LabelSpan, state.TextSpan)

    private MakeImage(context: ImGui.ImGuiContext, state: ImageModel): () =
        if (state.descriptorSet == Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL)
            state.descriptorSet <-
                ImGui.CreateTexture(context, state.gpuImage.VkSampler, state.gpuImage.VkImageView, Evergreen.Graphics.Backend.Vulkan.VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                    () ->
                        state.descriptorSet <- Evergreen.Graphics.Backend.Vulkan.VkDescriptorSet.NULL
                )

        ImGui.Image(context, state.descriptorSet, state.Size, Vector2.Zero, Vector2.One)

    // private MakeInt32Input(state: Int32InputViewModel, onChanged: Int32InputViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.InputInt(state.Label, &state.Value))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeCheckbox(state: CheckboxViewModel, onChanged: CheckboxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Checkbox(state.Label, &state.IsChecked))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeComboBox(state: ComboBoxViewModel, onChanged: ComboBoxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Combo(state.Label, &state.SelectedItemIndex, state.Items, state.ItemCount))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    NewFrame(context: ImGui.ImGuiContext): () =
        ImGui.NewFrame(context)

    Show(context: ImGui.ImGuiContext, view: View): () =
        MakeNode(context, view)
        let mutable callback = unchecked default
        while (context.Callbacks.TryDequeue(&callback))
            callback()

    Draw(context: ImGui.ImGuiContext, commandBuffer: TerraFX.Interop.Vulkan.VkCommandBuffer, pipeline: TerraFX.Interop.Vulkan.VkPipeline): () =
        ImGui.Draw(context, commandBuffer, pipeline)
