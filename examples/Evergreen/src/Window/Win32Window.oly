namespace Evergreen.Window

open System
open System.Text
open System.Numerics
open System.Diagnostics
open System.Collections.Generic
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open Evergreen.Window
open static TerraFX.Interop.Windows.Windows
open static TerraFX.Interop.Windows.CS
open static TerraFX.Interop.Windows.GWLP
open static TerraFX.Interop.Windows.PM
open static TerraFX.Interop.Windows.WM
open static TerraFX.Interop.Windows.WS
open static TerraFX.Interop.Windows.SW

private alias Unsafe = OlyPrelude.Unsafe

internal class Marker

internal module Win32 =

    #[open]
    private module Helpers =

        fixed(o: object): GCHandle =
            GCHandle.Alloc(o, GCHandleType.Pinned)

        fixedCopyUTF8(str: string): GCHandle =
            fixed(UTF8Encoding.UTF8.GetBytes(str))

    WindowLookup: System.Collections.Concurrent.ConcurrentDictionary<HWND, Win32Window> get = System.Collections.Concurrent.ConcurrentDictionary()

    RegisterRawMouseInput(): () =
        let mutable rawMouse = default: RAWINPUTDEVICE
        rawMouse.usUsagePage <- 0x01
        rawMouse.usUsage <- 0x02
        rawMouse.dwFlags <- 0
        rawMouse.hwndTarget <- HWND.NULL
        if (RegisterRawInputDevices(&&rawMouse, 1, uint32(sizeof<RAWINPUTDEVICE>)) == BOOL.FALSE)
            fail("Failed to register raw input device.")

    GetRawMouseInput(hrawinput: HRAWINPUT): RAWMOUSE =
        let mutable inp = default: RAWINPUT
        let pData = Unsafe.AsPointer(&&inp)
        let mutable size = uint32(sizeof<RAWINPUT>)
        let bytesCopied = GetRawInputData(hrawinput, 0x10000003, pData, &&size, uint32(sizeof<RAWINPUTHEADER>))
        inp.`data`.mouse

    IsMouseRelative(rawMouse: RAWMOUSE): bool =
        (rawMouse.usFlags & 0x01) == 0

    GetDisplayModes(): DisplayMode[] =
        let displayModes = List()
        let hash = HashSet()

        let mutable mode = default: DEVMODEA
        mode.dmSize <- uint16(sizeof<DEVMODEA>)
        mode.dmDriverExtra <- 0
        let mutable i = 0: uint32
        while (EnumDisplaySettingsA(nullptr, i, &&mode) == BOOL.TRUE)
            if (mode.dmBitsPerPel == 32)
                let displayMode =
                    DisplayMode(int32(mode.dmPelsWidth), int32(mode.dmPelsHeight), int32(mode.dmDisplayFrequency))

                if (hash.Add(displayMode))
                    displayMode.devmodea <- mode
                    displayModes.Add(displayMode)
            i <- i + 1

        let displayModes = System.Linq.Enumerable.OrderBy(displayModes, x -> x.RefreshRate)
        let displayModes = System.Linq.Enumerable.OrderBy(displayModes, x -> x.Height * x.Width)
        let displayModes = System.Linq.Enumerable.ToArray(displayModes)
        Unsafe.AsImmutable(displayModes)

    // GetCurrentDisplayMode(): DisplayMode =
    //     let mutable info = default: MONITORINFO
    //     if (GetMonitorInfo(HMONITOR.NULL, &&info) == BOOL.FALSE)
    //         fail("Failed to get monitor info.")

    //     let mutable requiredPaths = 0: uint32
    //     let mutable requiredModes = 0: uint32

    //     if (GetDisplayConfigBufferSizes(uint32(QDC_ONLY_ACTIVE_PATHS), &&requiredPaths, &&requiredModes) != 0)
    //         fail("Failed to get display config buffer sizes.")

    //     let paths = 
        
    //     if (QueryDisplayConfig(uint32(QDC_ONLY_ACTIVE_PATHS), &&requiredPaths, x, &&requiredModes, x, nullptr) != 0)
    //         fail("Failed to query display config.")
    //                           // using the CCD get the associated path and display configuration
    //                         //   UINT32 requiredPaths, requiredModes;
    //                         //   if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &requiredPaths, &requiredModes) == ERROR_SUCCESS)
    //                         //   {
    //                         //          std::vector<DISPLAYCONFIG_PATH_INFO> paths(requiredPaths);
    //                         //          std::vector<DISPLAYCONFIG_MODE_INFO> modes2(requiredModes);
    //                         //          if (QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &requiredPaths, paths.data(), &requiredModes, modes2.data(), nullptr) == ERROR_SUCCESS)
    //                         //          {
    //                         //                 // iterate through all the paths until find the exact source to match
    //                         //                 for (auto& p : paths) {
    //                         //                        DISPLAYCONFIG_SOURCE_DEVICE_NAME sourceName;
    //                         //                        sourceName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
    //                         //                        sourceName.header.size = sizeof(sourceName);
    //                         //                        sourceName.header.adapterId = p.sourceInfo.adapterId;
    //                         //                        sourceName.header.id = p.sourceInfo.id;
    //                         //                        if (DisplayConfigGetDeviceInfo(&sourceName.header) == ERROR_SUCCESS)
    //                         //                        {
    //                         //                               // find the matched device which is associated with current device 
    //                         //                               // there may be the possibility that display may be duplicated and windows may be one of them in such scenario
    //                         //                               // there may be two callback because source is same target will be different
    //                         //                               // as window is on both the display so either selecting either one is ok
    //                         //                               if (wcscmp(info.szDevice, sourceName.viewGdiDeviceName) == 0) {
    //                         //                                      // get the refresh rate
    //                         //                                      UINT numerator = p.targetInfo.refreshRate.Numerator;
    //                         //                                      UINT denominator = p.targetInfo.refreshRate.Denominator;
    //                         //                                      double refrate = (double)numerator / (double)denominator;
    //                         //                                      *outRefreshRate = refrate;
    //                         //                                      break;
    //                         //                               }
    //                         //                        }
    //                         //                 }

    //     let displayMode = info.
        

    #[blittable]
    #[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>])]
    wndProc(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT =
        if (Evergreen.ImGui.ImGuiContext.InputContext !== unchecked default &&
                Evergreen.ImGui.Win32ProcHandler(hWnd, msg, wParam, lParam))
            LRESULT(nint(1))
        else
            match (int32(msg))
            | WM_DESTROY =>
                let mutable window = unchecked default
                let result = Win32.WindowLookup.TryRemove(hWnd, &window)
                PostQuitMessage(0)
                default
            | _ =>
                DefWindowProc(hWnd, msg, wParam, lParam)

    CreateWindow(title: string): (HWND, HINSTANCE) =
        Win32.RegisterRawMouseInput()
        let m = typeof<Marker>().Module
        let hInstance = HINSTANCE.op_Explicit(Marshal.GetHINSTANCE(m))
        let mutable wc = default: WNDCLASSW

        let mutable example = "Win32Window"
        let mutable windowName = title
        let mutable gc = GCHandle.Alloc(example, GCHandleType.Pinned)
        let mutable gc2 = GCHandle.Alloc(windowName, GCHandleType.Pinned)
        let addr = Unsafe.AsPointer(gc.AddrOfPinnedObject())
        let addr2 = Unsafe.AsPointer(gc2.AddrOfPinnedObject())
        wc.hInstance <- hInstance
        wc.lpfnWndProc <- &&wndProc
        wc.lpszClassName <- addr

        let result = RegisterClass(&&wc)
        if (result == 0)
            (HWND.NULL, hInstance)
        else
            let hwnd =
                CreateWindowEx(
                    0, 
                    wc.lpszClassName, 
                    addr2,
                    uint32(WS_OVERLAPPEDWINDOW),
                    CW_USEDEFAULT, 
                    CW_USEDEFAULT, 
                    CW_USEDEFAULT, 
                    CW_USEDEFAULT, 
                    HWND.NULL, 
                    HMENU.NULL, 
                    hInstance, 
                    default
                )

            gc.Free()
            gc2.Free()
            (hwnd, hInstance)

    ShowWindow(hwnd: HWND): () =
        let result = ShowWindow(hwnd, SW_SHOWNORMAL)
        let result = UpdateWindow(hwnd)
        let result = SetFocus(hwnd)

    HideWindow(hwnd: HWND): () =
        let result = ShowWindow(hwnd, SW_HIDE)

    MinimizeWindow(hwnd: HWND): () =
        let result = CloseWindow(hwnd) 

    TranslateKey(c: char): Key =
        match (c)
        | 'A' => Key.A
        | 'B' => Key.B
        | 'C' => Key.C
        | 'D' => Key.D
        | 'E' => Key.E
        | 'F' => Key.F
        | 'G' => Key.G
        | 'H' => Key.H
        | 'I' => Key.I
        | 'J' => Key.J
        | 'K' => Key.K
        | 'L' => Key.L
        | 'M' => Key.M
        | 'N' => Key.N
        | 'O' => Key.O
        | 'P' => Key.P
        | 'Q' => Key.Q
        | 'R' => Key.R
        | 'S' => Key.S
        | 'T' => Key.T
        | 'U' => Key.U
        | 'V' => Key.V
        | 'W' => Key.W
        | 'X' => Key.X
        | 'Y' => Key.Y
        | 'Z' => Key.Z
        | x =>
            match (uint16(x))
            | 27 => Key.Esc
            | 192 => Key.Tilde
            | _ => Key.Unknown

internal class Win32Window =
    implements IWindow

    mutable field title: string
    mutable field hwnd: HWND
    mutable field hinstance: HINSTANCE
    mutable field isCursorHidden: bool
    mutable field mouseInfo: MouseInfo
    mutable field keyEvents: List<KeyEvent>
    mutable field keysDown: HashSet<Key>
    mutable field isDisposed: bool
    mutable field isClosed: bool
    mutable field currentDisplayMode: DisplayMode

    Title: string get() = this.title
    HWND: nint get() = nint(this.hwnd.Value)
    HINSTANCE: nint get() = nint(this.hinstance.Value)

    IsClosed: bool 
        get() = 
            if (this.isDisposed)
                true
            else if (this.isClosed)
                true
            else
                IsWindow(this.hwnd) == BOOL.FALSE

    IsHidden: bool 
        get() = 
            if (this.isDisposed)
                true
            else if (this.isClosed)
                true
            else
                IsWindowVisible(this.hwnd) == BOOL.FALSE

    Size: Vector2
        get() =
            let mutable rect = default: RECT
            if (GetClientRect(this.hwnd, &&rect) == BOOL.TRUE)
                let width = rect.right - rect.left
                let height = rect.bottom - rect.top
                Vector2(float32(width), float32(height))
            else
                Vector2.Zero
        
        set(value) =
            let width = int32(value.X)
            let height = int32(value.Y)

            let mutable rect = default: RECT
            rect.top <- 0
            rect.bottom <- height
            rect.left <- 0
            rect.right <- width
            let result = AdjustWindowRect(&&rect, uint32(GetWindowLong(this.hwnd, GWL.GWL_STYLE)), BOOL.FALSE)
            let width = rect.right - rect.left
            let height = rect.bottom - rect.top

            let result = SetWindowPos(this.hwnd, HWND.NULL, 0, 0, width, height, uint32(SWP.SWP_NOMOVE | SWP.SWP_NOOWNERZORDER | SWP.SWP_NOZORDER))


    Position: Vector2
        get() =
            let mutable rect = default: RECT
            if (GetWindowRect(this.hwnd, &&rect) == BOOL.TRUE)
                let x = rect.left
                let y = rect.top
                Vector2(float32(x), float32(y))
            else
                Vector2.Zero

        set(value) =
            let x = int32(value.X)
            let y = int32(value.Y)
            let result = SetWindowPos(this.hwnd, HWND.NULL, x, y, 0, 0, uint32(SWP.SWP_NOSIZE | SWP.SWP_NOOWNERZORDER | SWP.SWP_NOZORDER))

    new(title: string) =
        match (Win32.CreateWindow(title))
        | (hwnd, hinstance) when (hwnd == HWND.NULL) =>
            throw Exception("Failed to create window.")
        | (hwnd, hinstance) =>
            let displayModes = Win32.GetDisplayModes()
            if (displayModes.Length == 0)
                fail("Failed to find appropriate display modes.")
            let displayMode = displayModes[displayModes.Length - 1]
            Win32.WindowLookup[hwnd] <- this
            {
                title = title
                keyEvents = List(128)
                keysDown = HashSet(128)
                mouseInfo = MouseInfo()
                isCursorHidden = false
                hwnd = hwnd
                hinstance = hinstance
                isDisposed = false
                isClosed = true
                currentDisplayMode = displayMode
            }
        | _ =>
            // TODO: Fix language to handle this kind of exhaustiveness
            throw Exception("Failed to create window.")

    Show(): () =
        this.ThrowIfDisposed()
        Win32.ShowWindow(this.hwnd)
        this.isClosed <- false

    Hide(): () =
        this.ThrowIfDisposed()
        Win32.HideWindow(this.hwnd)

    Close(): () =
        this.ThrowIfDisposed()
        Win32.HideWindow(this.hwnd)
        this.isClosed <- true

    Minimize(): () =
        this.ThrowIfDisposed()
        if (!this.isClosed)
            let result = CloseWindow(this.hwnd)     
                
    GetDisplayModes(): DisplayMode[] = Win32.GetDisplayModes()

    CurrentDisplayMode: DisplayMode get() = this.currentDisplayMode

    ChangeDisplayMode(displayMode: DisplayMode): () =
        let displayModes = this.GetDisplayModes()
        let loop(i) =
            if (i == displayModes.Length)
                ()
            else
                let displayMode2 = displayModes[i]
                if (displayMode.Equals(displayMode2))
                    this.currentDisplayMode <- displayMode2
                    this.Size <- Vector2(float32(displayMode.Width), float32(displayMode.Height))
                else
                    loop(i + 1)
        loop(0)

    IsFullscreen: bool
        get() = 
            (GetWindowLong(this.hwnd, GWL.GWL_STYLE) & WS.WS_OVERLAPPEDWINDOW) == 0
        set(value) =
                let dwStyle = GetWindowLong(this.hwnd, GWL.GWL_STYLE)
                if (dwStyle & WS.WS_OVERLAPPEDWINDOW != 0)
                    let size = Vector2(float32(this.currentDisplayMode.Width), float32(this.currentDisplayMode.Height))
                    let _ = SetWindowLong(this.hwnd, GWL.GWL_STYLE, dwStyle & ~WS.WS_OVERLAPPEDWINDOW)
                    let _ =
                        SetWindowPos(this.hwnd, HWND.HWND_TOP,
                            0, 0,
                            int32(size.X), int32(size.Y),
                            uint32(SWP.SWP_NOOWNERZORDER | SWP.SWP_FRAMECHANGED)
                        )
                else
                    let _ = SetWindowLong(this.hwnd, GWL.GWL_STYLE, dwStyle | WS.WS_OVERLAPPEDWINDOW)
                    let _ =
                        SetWindowPos(this.hwnd, HWND.NULL,
                            0, 0,
                            0, 0,
                            uint32(SWP.SWP_NOMOVE | SWP.SWP_NOSIZE | SWP.SWP_NOZORDER | SWP.SWP_NOOWNERZORDER | SWP.SWP_FRAMECHANGED)
                        )

    PumpEvents(): InputSnapshot =
        this.ThrowIfDisposed()

        #[inline]
        let getKeyEvents(): KeyEvent[] =
            let xs = this.keyEvents.ToArray()
            this.keyEvents.Clear()
            Unsafe.AsImmutable(xs)

        if (Evergreen.ImGui.ImGuiContext.InputContext !== unchecked default)
            Evergreen.ImGui.SetCurrentContext(Evergreen.ImGui.ImGuiContext.InputContext)

        let hwnd = this.hwnd
        let mutable msg = default: MSG
        while (PeekMessage(&&msg, hwnd, 0, 0, uint32(PM_REMOVE)) == BOOL.TRUE)
            let result = TranslateMessage(&&msg)
            let result = DispatchMessage(&&msg)

            match (int32(msg.message))
            | WM_INPUT =>
                let rawMouse = Win32.GetRawMouseInput(Unsafe.Cast(msg.lParam))
                let isRelative = Win32.IsMouseRelative(rawMouse)
                if (rawMouse.lLastX != 0 || rawMouse.lLastY != 0)
                    let mutable newMouseInfo = default: MouseInfo
                    newMouseInfo.X <- this.mouseInfo.X + rawMouse.lLastX
                    newMouseInfo.Y <- this.mouseInfo.Y + rawMouse.lLastY
                    newMouseInfo.RelativeX <- rawMouse.lLastX
                    newMouseInfo.RelativeY <- rawMouse.lLastY
                    if (this.isCursorHidden)
                        // center()
                        ()
                    else
                        this.mouseInfo <- newMouseInfo

            | WM_KEYDOWN
            | WM_SYSKEYDOWN =>
                let key = Win32.TranslateKey(char(msg.wParam.Value))
                if (key != Key.Unknown)
                    let flags =
                        if (this.keysDown.Add(key))
                            KeyEventFlags.Down
                        else
                            KeyEventFlags.Repeat
                    let keyEvent = KeyEvent(key, flags)
                    this.keyEvents.Add(keyEvent)

            | WM_KEYUP
            | WM_SYSKEYUP =>
                let key = Win32.TranslateKey(char(msg.wParam.Value))
                if (key != Key.Unknown)
                    let result = this.keysDown.Remove(key)
                    let flags = KeyEventFlags.Up
                    let keyEvent = KeyEvent(key, flags)
                    this.keyEvents.Add(keyEvent)

            | WM_LBUTTONDOWN =>
                () // left mouse button

            | WM_LBUTTONUP =>
                () // left mouse button up

            | WM_RBUTTONDOWN =>
                () // left mouse button

            | WM_RBUTTONUP =>
                () // left mouse button up

            | WM_MBUTTONDOWN =>
                ()

            | WM_MBUTTONUP =>
                ()

            | WM_QUIT =>
                ()

            | _ =>
                ()

        InputSnapshot(getKeyEvents(), this.mouseInfo)

    Dispose(): () =
        this.ThrowIfDisposed()
        let result = DestroyWindow(this.hwnd)
        this.isDisposed <- true
        this.isClosed <- true
        this.keyEvents.Clear()
        this.keysDown.Clear()

    #[DebuggerHidden()]
    private ThrowIfDisposed(): () =
        if (this.isDisposed)
            throw ObjectDisposedException("Win32Window")
