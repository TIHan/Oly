namespace Evergreen.Collections

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

alias TypeId = uint64

interface IComponent =

    static abstract GetTypeId(): TypeId

    static abstract GetSize(): int32

internal alias ArchetypeId = uint64

#[open]
internal module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")

    GetArchetypeId<T0>(): ArchetypeId where T0: IComponent = T0.GetTypeId()

    GetArchetypeId<T0, T1>(): ArchetypeId where T0: IComponent where T1: IComponent = T0.GetTypeId() | T1.GetTypeId()

    GetArchetypeId<T0, T1, T2>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent = T0.GetTypeId() | T1.GetTypeId() | T2.GetTypeId()

    GetArchetypeId<T0, T1, T2, T3>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent where T3: IComponent = T0.GetTypeId() | T1.GetTypeId() | T2.GetTypeId() | T3.GetTypeId()

    GetTypeIds(archetypeId: ArchetypeId): TypeId[] =
        let bitArray = System.Collections.BitArray(BitConverter.GetBytes(archetypeId))
        let tyIds = List<TypeId>()            
        let mutable i = 0
        while (i < bitArray.Count)
            if (bitArray.Get(i))
                tyIds.Add((1: uint64) << i)
            i <- i + 1
        Unsafe.AsImmutable(tyIds.ToArray())

internal class ComponentBuffer =

    public field Buffer: mutable byte[]
    TypeId: TypeId get
    TypeSize: int32 get

    new(buffer: mutable byte[], typeId: TypeId, typeSize: int32) =
        {          
            Buffer = buffer
            TypeId = typeId
            TypeSize = typeSize
        }

    CopyTo(dst: ComponentBuffer, lengthInBytes: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer).Buffer
        Span(this.Buffer, 0, lengthInBytes).CopyTo(Span(dstBuffer, 0, lengthInBytes))

    CopyOneTo(srcIndex: int32, dst: ComponentBuffer, dstIndex: int32): () =
        Span(this.Buffer, srcIndex * this.TypeSize, this.TypeSize).CopyTo(Span(dst.Buffer, dstIndex * this.TypeSize, this.TypeSize))

internal class Archetype =
    
    Id: ArchetypeId get
    DependencyId: ArchetypeId get
    FullId: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: ComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    CopyTo(dst: Archetype): () =
        let count = this.Count
        
        //Span(this.Lookup).CopyTo(Span(dst.Lookup))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))

        // fix-up lookup
        let entIds = dst.EntityIds
        let lookup = dst.Lookup
        let mutable i = 0
        while (i < count)
            lookup[entIds[i].Index] <- i
            i <- i + 1

        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))
        dst.Count <- count

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                buffer.CopyTo(dst.Buffers[dstBufferIndex], count * buffer.TypeSize)
            i <- i + 1 

    CopyOneTo(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                buffer.CopyOneTo(srcIndex, dst.Buffers[dstBufferIndex], dstIndex)
            i <- i + 1 
            
    GetRawComponentBuffer<T>(typedIndex: int32): Span<T> where T: unmanaged =
        MemoryMarshal.Cast<byte, T>(Span(this.Buffers[typedIndex].Buffer))

    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    new(size: int32, buffers: ComponentBuffer[], archetypeId: ArchetypeId, dependencyId: ArchetypeId) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        {
            Id = archetypeId
            DependencyId = dependencyId
            FullId = archetypeId | dependencyId
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

internal interface IArchetypeReference =

    ArchetypedIndex: int32 get
    LastTypedIndex: int32 get

internal class ArchetypeReference1 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex0

    new(archetypedIndex: int32, typedIndex0: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
        }

internal class ArchetypeReference2 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex1

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
        }

internal class ArchetypeReference3 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex2

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
        }

internal class ArchetypeReference4 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    TypedIndex3: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex3

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32, typedIndex3: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
            TypedIndex3 = typedIndex3
        }

internal class EntityQuery<T0> where T0: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1> where T0: unmanaged
                          where T1: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

interface IEntityEvent<T> =

    Add(subscriber: T -> ()): ()

internal class EntityEvent<T> =
    implements IEntityEvent<T>

    field subscribers: List<T -> ()> = List()
    field lockObj: object = System.Object()

    Add(subscriber: T -> ()): () =
        this.subscribers.Add(subscriber)

    Trigger(eventData: T): () =
        let mutable i = 0
        while (i < this.subscribers.Count)
            let subscriber = this.subscribers[i]
            subscriber(eventData)
            i <- i + 1

class EntityDatabase =

    private class ArchetypeIdEqualityComparer =
        implements IEqualityComparer<ArchetypeId>
    
        GetHashCode(x: ArchetypeId): int32 = int32(x)
    
        Equals(x: ArchetypeId, y: ArchetypeId): bool = x == y

    public static field MaxNumberOfEntities: int32 = 65536  

    internal field entityCreated: EntityEvent<EntityId> = EntityEvent()
    EntityCreated: IEntityEvent<EntityId> get() = this.entityCreated

    internal field entityDeleting: EntityEvent<EntityId> = EntityEvent()
    EntityDeleting: IEntityEvent<EntityId> get() = this.entityDeleting

    internal field entityDeleted: EntityEvent<EntityId> = EntityEvent()
    EntityDeleted: IEntityEvent<EntityId> get() = this.entityDeleted

    private Registered: Dictionary<TypeId, int32> get = Dictionary()
    Register<T>(): () where T: unmanaged, IComponent = this.Registered.Add(T.GetTypeId(), T.GetSize())
    GetTypeSize(tyId: TypeId): int32                 = this.Registered[tyId]
    
    internal Archetypes: List<Archetype> get = List()
    internal ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())
    internal DependencyLookup: Dictionary<TypeId, ArchetypeId> get = Dictionary()

    private GetArchetypedIndex<T0>(): int32 where T0: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0>())

    private GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged, IComponent
                                                where T1: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1>())

    private GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged, IComponent
                                                    where T1: unmanaged, IComponent
                                                    where T2: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1, T2>())

    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            archetypedIndex <- this.Archetypes.Count

            let origArchetypeId = archetypeId
            let origTyIds = GetTypeIds(origArchetypeId)

            let mutable dependencyId = 0: ArchetypeId

            let archetypeId =
                let mutable archetypeId = archetypeId
                let mutable i = 0
                while (i < origTyIds.Length)
                    let mutable result = unchecked default
                    if (this.DependencyLookup.TryGetValue(origTyIds[i], &result))
                        archetypeId <- archetypeId | result
                        dependencyId <- dependencyId | result
                    i <- i + 1
                archetypeId

            let tyIds = GetTypeIds(archetypeId)

            let sizes = Array.Map(tyIds, tyId -> this.GetTypeSize(tyId))
            let buffers = Array.MapIndex(tyIds, (i, tyId) -> ComponentBuffer(Array.ZeroCreate<byte>(EntityDatabase.MaxNumberOfEntities * sizes[i]), tyId, sizes[i]))

            let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, buffers, origArchetypeId, dependencyId)

            this.Archetypes.Add(archetype)
            this.ArchetypeLookup[origArchetypeId] <- archetypedIndex
            archetypedIndex

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged, IComponent =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[T.GetTypeId()]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if ((archetype.FullId & archetypeId) == archetypeId)
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    internal RegisterArchetype<T0>(): ArchetypeReference1 where T0: unmanaged, IComponent =
        let archetypedIndex = this.GetArchetypedIndex<T0>()
        ArchetypeReference1(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex))

    private RegisterArchetype<T0, T1>(): ArchetypeReference2 where T0: unmanaged, IComponent 
                                                             where T1: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1>()
        ArchetypeReference2(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex))

    private RegisterArchetype<T0, T1, T2>(): ArchetypeReference3 where T0: unmanaged, IComponent 
                                                                 where T1: unmanaged, IComponent  
                                                                 where T2: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1, T2>()
        ArchetypeReference3(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex), this.GetTypedIndex<T2>(archetypedIndex))
        
    private CreateQuery<T0>(): EntityQuery<T0> where T0: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = EntityQuery<T0>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1>(): EntityQuery<T0, T1> where T0: unmanaged, IComponent  
                                                       where T1: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = EntityQuery<T0, T1>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: unmanaged, IComponent  
                                                               where T1: unmanaged, IComponent 
                                                               where T2: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(): EntityQuery<T0, T1, T2, T3> where T0: unmanaged, IComponent  
                                                                       where T1: unmanaged, IComponent 
                                                                       where T2: unmanaged, IComponent  
                                                                       where T3: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetTypeId()]))

            i <- i + 1

        query

    RegisterDependency<T, TDependency>(): () where T: unmanaged, IComponent
                                             where TDependency: unmanaged, IComponent =
        this.DependencyLookup.Add(T.GetTypeId(), TDependency.GetTypeId())

    ForEachSpan<T0, T1>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                                   where T1: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2, T3>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                               where T1: unmanaged, IComponent 
                                                                                                               where T2: unmanaged, IComponent 
                                                                                                               where T3: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = this.CreateQuery<T0, T1, T2, T3>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup3[i].Buffer)).Slice(0, count)
            )

            i <- i + 1

    ForEach<T0>(f: (EntityId, byref<T0>) -> ()): () where T0: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = this.CreateQuery<T0>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                   where T1: unmanaged, IComponent =
        this.ForEachSpan<T0, T1>(
            (mutable entIds, mutable buffer0, mutable buffer1) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i])
                    i <- i + 1
        )
            
    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                  where T1: unmanaged, IComponent 
                                                                                  where T2: unmanaged, IComponent =
        this.ForEachSpan<T0, T1, T2>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i])
                    i <- i + 1
        )

    ForEach<T0, T1, T2, T3>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent 
                                                                                                 where T3: unmanaged, IComponent =

        this.ForEachSpan<T0, T1, T2, T3>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i])
                    i <- i + 1
        )
            
    Create<T0>(value0: T0): EntityId where T0: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: unmanaged, IComponent
                                                     where T1: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0, T1>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: unmanaged, IComponent
                                                                     where T1: unmanaged, IComponent 
                                                                     where T2: unmanaged, IComponent =                                                                
        let archetypeRef = this.RegisterArchetype<T0, T1, T2>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1
        let typedIndex2 = archetypeRef.TypedIndex2

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    private AddComponentCore(entId: EntityId, typeId: TypeId): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.Archetypes[srcArchetypedIndex]
        let srcArchetypeId = srcArchetype.Id

        if ((srcArchetypeId & typeId) == typeId)
            srcArchetype
        else
            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.Archetypes[dstArchetypedIndex]

            let srcIndex = srcArchetype.Lookup[entId.Index]
            let dstIndex = dstArchetype.Count
            srcArchetype.CopyOneTo(srcIndex, dstArchetype, dstIndex)
            dstArchetype.Lookup[entId.Index] <- dstIndex
            dstArchetype.EntityIds[dstIndex] <- entId
            dstArchetype.Count <- dstIndex + 1

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex

            dstArchetype

    AddComponent<T>(entId: EntityId): byref<T> where T: unmanaged, IComponent =
        let tyId: TypeId = T.GetTypeId()
        let archetype = this.AddComponentCore(entId, tyId)
        let mutable buffer = archetype.GetRawComponentBuffer(archetype.BufferLookup[tyId])
        &buffer[archetype.Lookup[entId.Index]]

    HasComponent<T>(entId: EntityId): bool where T: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId = T.GetTypeId()
        (archetype.FullId & tyId) == tyId

    GetComponent<T>(entId: EntityId): byref<T> where T: unmanaged, IComponent =
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let typedIndex = this.GetTypedIndex<T>(archetypedIndex)
        let archetype = this.Archetypes[archetypedIndex]
        let mutable result = archetype.GetRawComponentBuffer<T>(typedIndex)
        &result[archetype.Lookup[entId.Index]]

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.entityDeleting.Trigger(entId)
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[archetypedIndex]

        // ---
        let index = archetype.Lookup[entId.Index]
        let lastIndex = archetype.Count - 1
        this.Swap(archetype, index, lastIndex)
        archetype.Count <- lastIndex
        // ---

        this.DeleteEntityId(entId)
        this.entityDeleted.Trigger(entId)

    private Swap(archetype: Archetype, index: int32, lastIndex: int32): () =
        let lastEntId = archetype.EntityIds[lastIndex]

        if (lastIndex != index)
            archetype.Lookup[lastEntId.Index] <- index
            archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]

            // TODO: Optimize this.
            let tyIds = GetTypeIds(archetype.FullId)
            let mutable i = 0
            while (i < tyIds.Length)
                let buffer = archetype.Buffers[archetype.BufferLookup[tyIds[i]]]
                buffer.CopyOneTo(lastIndex, buffer, index)
                i <- i + 1

    // ----------------------------------------------

    internal mutable field nextIndex: int32 = 0
    internal mutable field indexQueue: Queue<int32> = Queue()
    internal mutable field entityCount: int32 = 0
    internal field entityArchetypeIndices: mutable int32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> -1)
    internal field entityVersions: mutable uint32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> 0: uint32)

    internal NewEntityId(archetypedIndex: int32): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != EntityDatabase.MaxNumberOfEntities

    EntityCount: int32 get() = this.entityCount

    Replicate(dst: EntityDatabase): () =
        if (this.Archetypes.Count != dst.Archetypes.Count)
            let mutable i = 0
            while (i < this.Archetypes.Count)
                let archetype = this.Archetypes[i]
                let _ = dst.GetArchetypedIndex(archetype.Id)
                i <- i + 1

        let createdEntities = Queue<EntityId>()
        let maxCount = Math.Max(this.EntityCount, dst.EntityCount)

        let mutable i = 0
        while (i < maxCount)
            let version = this.entityVersions[i]
            let archetypedIndex = this.entityArchetypeIndices[i]

            let dstVersion = dst.entityVersions[i]
            let dstArchetypedIndex = dst.entityArchetypeIndices[i]

            if (version != dstVersion)
                if (archetypedIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    createdEntities.Enqueue(entId)

                if (dstVersion != 0 && dstArchetypedIndex != -1)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- dstVersion
                    dst.entityDeleting.Trigger(entId)

                dst.entityArchetypeIndices[i] <- archetypedIndex
                dst.entityVersions[i] <- version

            // This handles when an entity has had components added or removed.
            // This also takes dependencies into account and will move the data to the new archetype.
            else if (archetypedIndex != -1 && dstArchetypedIndex != -1 && archetypedIndex != dstArchetypedIndex)
                dst.entityArchetypeIndices[i] <- archetypedIndex

                let archetype = this.Archetypes[archetypedIndex]
                let depId = archetype.DependencyId

                let dstArchetype = dst.Archetypes[dstArchetypedIndex]
                let dstDepId = dstArchetype.DependencyId
                
                // Do we have any dependencies to copy?
                if ((dstDepId & ~depId) != 0)
                    let archetypeId = this.Archetypes[archetypedIndex].Id
                    let dstNewArchetypedIndex = dst.GetArchetypedIndex(archetypeId)
                    let dstNewArchetype = dst.Archetypes[dstNewArchetypedIndex]

                    dstArchetype.CopyOneTo(dstArchetype.Lookup[i], dstNewArchetype, dstNewArchetype.Count)
                    
            i <- i + 1

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            archetype.CopyTo(dst.Archetypes[i])
            i <- i + 1
            
        let mutable entId = default
        while (createdEntities.TryDequeue(&entId))
            dst.entityCreated.Trigger(entId)