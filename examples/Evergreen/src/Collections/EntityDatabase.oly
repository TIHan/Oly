namespace Evergreen.Collections

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

alias TypeId = uint64

interface IComponent =

    static abstract GetTypeId(): TypeId

    static abstract GetSize(): int32

internal alias ArchetypeId = uint64

#[open]
internal module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")

    GetArchetypeId<T0>(): ArchetypeId where T0: IComponent = T0.GetTypeId()

    GetArchetypeId<T0, T1>(): ArchetypeId where T0: IComponent where T1: IComponent = T0.GetTypeId() | T1.GetTypeId()

    GetArchetypeId<T0, T1, T2>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent = T0.GetTypeId()| T1.GetTypeId() | T2.GetTypeId()

    GetArchetypeId<T0, T1, T2, T3>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent where T3: IComponent = T0.GetTypeId() | T1.GetTypeId() | T2.GetTypeId() | T3.GetTypeId()

    GetTypeIds(archetypeId: ArchetypeId): TypeId[] =
        let bitArray = System.Collections.BitArray(BitConverter.GetBytes(archetypeId))
        let tyIds = List<TypeId>()            
        let mutable i = 0
        while (i < bitArray.Count)
            if (bitArray.Get(i))
                tyIds.Add((1: uint64) << i)
            i <- i + 1
        Unsafe.AsImmutable(tyIds.ToArray())

internal class ComponentBuffer =

    public field Buffer: mutable byte[]
    TypeId: TypeId get
    TypeSize: int32 get

    new(buffer: mutable byte[], typeId: TypeId, typeSize: int32) =
        {          
            Buffer = buffer
            TypeId = typeId
            TypeSize = typeSize
        }

    CopyTo(dst: ComponentBuffer, lengthInBytes: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer).Buffer
        Span(this.Buffer, 0, lengthInBytes).CopyTo(Span(dstBuffer, 0, lengthInBytes))

    CopyOne(size: int32, srcIndex: int32, dst: ComponentBuffer, dstIndex: int32): () =
        Span(this.Buffer, srcIndex * size, size).CopyTo(Span(dst.Buffer, dstIndex * size, size))

internal class Archetype =
    
    Id: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: ComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    IsValid(entId: EntityId): bool =
        if (entId.IsNil) false
        else
            this.Lookup[entId.Index] != -1

    CopyTo(dst: Archetype): () =
        let count = this.Count

        dst.Count <- count
        
       // Span(this.Lookup).CopyTo(Span(dst.Lookup))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))

        // fix-up lookup
        let entIds = dst.EntityIds
        let lookup = dst.Lookup
        let mutable i = 0
        while (i < count)
            lookup[entIds[i].Index] <- i
            i <- i + 1

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                fail("Unable to copy contents.")
            buffer.CopyTo(dst.Buffers[dstBufferIndex], count * buffer.TypeSize)
            i <- i + 1 

    CopyOne(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                fail("Unable to copy contents.")
            buffer.CopyOne(buffer.TypeSize, srcIndex, dst.Buffers[dstBufferIndex], dstIndex)
            i <- i + 1 
            
    GetRawComponentBuffer<T>(typedIndex: int32): Span<T> where T: unmanaged =
        MemoryMarshal.Cast<byte, T>(Span(this.Buffers[typedIndex].Buffer))

    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    new(size: int32, buffers: ComponentBuffer[]) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        let mutable archetypeId = 0: uint64
        let mutable i = 0
        while (i < buffers.Length)
            archetypeId <- archetypeId | buffers[i].TypeId
            i <- i + 1

        {
            Id = archetypeId
            Count = 0
            Capacity = size
            Lookup  = Array.InitializeMutable(size, i -> -1)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

internal interface IArchetypeReference =

    ArchetypedIndex: int32 get
    LastTypedIndex: int32 get

internal class ArchetypeReference<T0> where T0: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex0

    new(archetypedIndex: int32, typedIndex0: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
        }

internal class ArchetypeReference<T0, T1> where T0: unmanaged
                                 where T1: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex1

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
        }

internal class ArchetypeReference<T0, T1, T2> where T0: unmanaged
                                     where T1: unmanaged
                                     where T2: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex2

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
        }

internal class ArchetypeReference<T0, T1, T2, T3> where T0: unmanaged
                                         where T1: unmanaged
                                         where T2: unmanaged 
                                         where T3: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    TypedIndex3: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex3

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32, typedIndex3: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
            TypedIndex3 = typedIndex3
        }

internal class EntityQuery<T0> where T0: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1> where T0: unmanaged
                          where T1: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

interface IEntityEvent<T> =

    Add(subscriber: T -> ()): ()

internal class EntityEvent<T> =
    implements IEntityEvent<T>

    field subscribers: List<T -> ()> = List()
    field lockObj: object = System.Object()

    Add(subscriber: T -> ()): () =
        this.subscribers.Add(subscriber)

    Trigger(eventData: T): () =
        let mutable i = 0
        while (i < this.subscribers.Count)
            let subscriber = this.subscribers[i]
            subscriber(eventData)
            i <- i + 1

class EntityDatabase =

    private class ArchetypeIdEqualityComparer =
        implements IEqualityComparer<ArchetypeId>
    
        GetHashCode(x: ArchetypeId): int32 = int32(x)
    
        Equals(x: ArchetypeId, y: ArchetypeId): bool = x == y

    public static field MaxNumberOfEntities: int32 = 65536

    // class CommandBuffer =
    //     field cmds: List<EntityDatabase -> ()> = List()

    //     Spawn<T0>(value0: T0): () where T0: unmanaged =
    //         let cmd =
    //             (edb: EntityDatabase) ->
    //                 let archetypeRef = edb.RegisterArchetype<T0>()
    //                 let archetypedIndex = archetypeRef.ArchetypedIndex
    //                 let typedIndex0 = archetypeRef.TypedIndex0
            
    //                 let entId = edb.NewEntityId(archetypedIndex)
            
    //                 let archetype = edb.Archetypes[archetypedIndex]
    //                 let index = archetype.Count
    //                 archetype.Lookup[entId.Index] <- index
    //                 archetype.EntityIds[index] <- entId
            
    //                 (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
            
    //                 archetype.Count <- index + 1
    //         this.cmds.Add(cmd)

    //     AddComponent<T>(entId: EntityId): () where T: unmanaged =
    //         let cmd =
    //             (edb: EntityDatabase) ->
    //                 edb.Check(entId)

    //                 let srcArchetypedIndex = edb.entityArchetypeIndices[entId.Index]
    //                 let srcArchetype = edb.Archetypes[srcArchetypedIndex]

    //                 let dstArchetypeId = Array.Add(srcArchetype.Id, typeof<T>)
    //                 let dstArchetypedIndex = edb.GetArchetypedIndex(dstArchetypeId)
    //                 let dstArchetype = edb.Archetypes[dstArchetypedIndex]

    //                 srcArchetype.CopyTo(dstArchetype)

    //                 let remove = edb.ArchetypeRemovers[srcArchetypedIndex]
    //                 remove(srcArchetype.Lookup[entId.Index])

    //                 edb.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex
    //         this.cmds.Add(cmd)       

    internal field entityCreated: EntityEvent<EntityId> = EntityEvent()
    EntityCreated: IEntityEvent<EntityId> get() = this.entityCreated

    internal field entityDeleting: EntityEvent<EntityId> = EntityEvent()
    EntityDeleting: IEntityEvent<EntityId> get() = this.entityDeleting

    internal field entityDeleted: EntityEvent<EntityId> = EntityEvent()
    EntityDeleted: IEntityEvent<EntityId> get() = this.entityDeleted

    private Registered: Dictionary<TypeId, int32> get = Dictionary()
    Register<T>(): () where T: unmanaged, IComponent = this.Registered.Add(T.GetTypeId(), T.GetSize())
    GetTypeSize(tyId: TypeId): int32                 = this.Registered[tyId]
    
    internal Archetypes: List<Archetype> get = List()
    internal ArchetypeRemovers: List<int32 -> ()> get = List()
    internal ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())
    internal DependencyLookup: Dictionary<TypeId, ArchetypeId> get = Dictionary()

    private GetArchetypedIndex<T0>(): int32 where T0: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0>())

    private GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged, IComponent
                                                where T1: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1>())

    private GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged, IComponent
                                                    where T1: unmanaged, IComponent
                                                    where T2: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1, T2>())

    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            archetypedIndex <- this.Archetypes.Count

            let origArchetypeId = archetypeId
            let origTyIds = GetTypeIds(origArchetypeId)

            let archetypeId =
                let mutable archetypeId = archetypeId
                let mutable i = 0
                while (i < origTyIds.Length)
                    let mutable result = unchecked default
                    if (this.DependencyLookup.TryGetValue(origTyIds[i], &result))
                        archetypeId <- archetypeId | result
                    i <- i + 1
                archetypeId

            let tyIds = GetTypeIds(archetypeId)

            let sizes = Array.Map(tyIds, tyId -> this.GetTypeSize(tyId))
            let buffers = Array.MapIndex(tyIds, (i, tyId) -> ComponentBuffer(Array.ZeroCreate<byte>(EntityDatabase.MaxNumberOfEntities * sizes[i]), tyId, sizes[i]))

            let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]

                    let mutable i = 0
                    while (i < tyIds.Length)
                        let buffer = buffers[i]
                        buffer.CopyOne(sizes[i], index, buffer, lastIndex)
                        i <- i + 1

                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[origArchetypeId] <- archetypedIndex
            archetypedIndex

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged, IComponent =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[T.GetTypeId()]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if ((archetype.Id & archetypeId) == archetypeId)
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    internal RegisterArchetype<T0>(): ArchetypeReference<T0> where T0: unmanaged, IComponent =
        let archetypedIndex = this.GetArchetypedIndex<T0>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex))

    private RegisterArchetype<T0, T1>(): ArchetypeReference<T0, T1> where T0: unmanaged, IComponent 
                                                                    where T1: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex))

    private RegisterArchetype<T0, T1, T2>(): ArchetypeReference<T0, T1, T2> where T0: unmanaged, IComponent 
                                                                            where T1: unmanaged, IComponent  
                                                                            where T2: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1, T2>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex), this.GetTypedIndex<T2>(archetypedIndex))
        
    private CreateQuery<T0>(): EntityQuery<T0> where T0: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = EntityQuery<T0>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1>(): EntityQuery<T0, T1> where T0: unmanaged, IComponent  
                                                       where T1: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = EntityQuery<T0, T1>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: unmanaged, IComponent  
                                                               where T1: unmanaged, IComponent 
                                                               where T2: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(): EntityQuery<T0, T1, T2, T3> where T0: unmanaged, IComponent  
                                                                       where T1: unmanaged, IComponent 
                                                                       where T2: unmanaged, IComponent  
                                                                       where T3: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetTypeId()]))

            i <- i + 1

        query

    RegisterDependency<T, TDependency>(): () where T: unmanaged, IComponent
                                             where TDependency: unmanaged, IComponent =
        this.DependencyLookup.Add(T.GetTypeId(), TDependency.GetTypeId())

    ForEach<T0>(f: (EntityId, byref<T0>) -> ()): () where T0: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = this.CreateQuery<T0>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                   where T1: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j])
                j <- j + 1

            i <- i + 1
            
    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                  where T1: unmanaged, IComponent 
                                                                                  where T2: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))
            let mutable buffer2 = MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1, T2, T3>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent 
                                                                                                 where T3: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = this.CreateQuery<T0, T1, T2, T3>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))
            let mutable buffer2 = MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer))
            let mutable buffer3 = MemoryMarshal.Cast(Span(bufferGroup3[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j], &buffer3[j])
                j <- j + 1

            i <- i + 1  
            
    Create<T0>(value0: T0): EntityId where T0: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: unmanaged, IComponent
                                                     where T1: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0, T1>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: unmanaged, IComponent
                                                                     where T1: unmanaged, IComponent 
                                                                     where T2: unmanaged, IComponent =                                                                
        let archetypeRef = this.RegisterArchetype<T0, T1, T2>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1
        let typedIndex2 = archetypeRef.TypedIndex2

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    private AddComponentCore(entId: EntityId, typeId: TypeId): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.Archetypes[srcArchetypedIndex]
        let srcArchetypeId = srcArchetype.Id

        if ((srcArchetypeId & typeId) == typeId)
            srcArchetype
        else
            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.Archetypes[dstArchetypedIndex]

            let srcIndex = srcArchetype.Lookup[entId.Index]
            let dstIndex = dstArchetype.Count
            srcArchetype.CopyOne(srcIndex, dstArchetype, dstIndex)
            dstArchetype.Lookup[entId.Index] <- dstIndex
            dstArchetype.EntityIds[dstIndex] <- entId
            dstArchetype.Count <- dstIndex + 1

            let remove = this.ArchetypeRemovers[srcArchetypedIndex]
            remove(srcArchetype.Lookup[entId.Index])

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex

            dstArchetype

    AddComponent<T>(entId: EntityId): byref<T> where T: unmanaged, IComponent =
        let tyId: TypeId = T.GetTypeId()
        let archetype = this.AddComponentCore(entId, tyId)
        let mutable buffer = archetype.GetRawComponentBuffer(archetype.BufferLookup[tyId])
        &buffer[archetype.Lookup[entId.Index]]

    HasComponent<T>(entId: EntityId): bool where T: unmanaged, IComponent =
        let archetype = this.Archetypes[this.entityArchetypeIndices[entId.Index]]
        let tyId = T.GetTypeId()
        (archetype.Id & tyId) == tyId

    GetComponent<T>(entId: EntityId): byref<T> where T: unmanaged, IComponent =
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let typedIndex = this.GetTypedIndex<T>(archetypedIndex)
        let archetype = this.Archetypes[archetypedIndex]
        let mutable result = archetype.GetRawComponentBuffer<T>(typedIndex)
        &result[archetype.Lookup[entId.Index]]

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.entityDeleting.Trigger(entId)
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[archetypedIndex]
        let remove = this.ArchetypeRemovers[archetypedIndex]
        remove(archetype.Lookup[entId.Index])
        this.DeleteEntityId(entId)
        this.entityDeleted.Trigger(entId)

    // ----------------------------------------------

    internal mutable field nextIndex: int32 = 0
    internal mutable field indexQueue: Queue<int32> = Queue()
    internal mutable field entityCount: int32 = 0
    internal field entityArchetypeIndices: mutable int32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> -1)
    internal field entityVersions: mutable uint32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> 0: uint32)

    internal NewEntityId(archetypedIndex: int32): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != EntityDatabase.MaxNumberOfEntities

    EntityCount: int32 get() = this.entityCount

    Replicate(dst: EntityDatabase): () =
        if (this.Archetypes.Count != dst.Archetypes.Count)
            let mutable i = 0
            while (i < this.Archetypes.Count)
                let archetype = this.Archetypes[i]
                let _ = dst.GetArchetypedIndex(archetype.Id)
                i <- i + 1

        let createdEntities = Queue<EntityId>()
        let maxCount = Math.Max(this.EntityCount, dst.EntityCount)

        let mutable i = 0
        while (i < maxCount)
            let version = this.entityVersions[i]
            let archetypedIndex = this.entityArchetypeIndices[i]

            let dstVersion = dst.entityVersions[i]
            let dstArchetypedIndex = dst.entityArchetypeIndices[i]

            if (version != dstVersion)
                if (version != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    createdEntities.Enqueue(entId)

                if (dstVersion != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- dstVersion
                    dst.entityDeleting.Trigger(entId)
                    
            i <- i + 1

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            archetype.CopyTo(dst.Archetypes[i])
            i <- i + 1
            
        let mutable entId = default
        while (createdEntities.TryDequeue(&entId))
            dst.entityCreated.Trigger(entId)