namespace Evergreen.Collections

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

alias TypeId = uint64

interface IComponent =

    static abstract GetTypeId(): TypeId

    static abstract GetSize(): int32

internal alias ArchetypeId = uint64

#[open]
internal module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")

    GetArchetypeId<T0>(): ArchetypeId where T0: IComponent = T0.GetTypeId()

    GetArchetypeId<T0, T1>(): ArchetypeId where T0: IComponent where T1: IComponent = T0.GetTypeId() | T1.GetTypeId()

    GetArchetypeId<T0, T1, T2>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent = T0.GetTypeId() | T1.GetTypeId() | T2.GetTypeId()

    GetArchetypeId<T0, T1, T2, T3>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent where T3: IComponent = T0.GetTypeId() | T1.GetTypeId() | T2.GetTypeId() | T3.GetTypeId()

    GetTypeIds(archetypeId: ArchetypeId): TypeId[] =
        let bitArray = System.Collections.BitArray(BitConverter.GetBytes(archetypeId))
        let tyIds = List<TypeId>()            
        let mutable i = 0
        while (i < bitArray.Count)
            if (bitArray.Get(i))
                tyIds.Add((1: uint64) << i)
            i <- i + 1
        Unsafe.AsImmutable(tyIds.ToArray())

internal class ComponentBuffer =

    public field RawBuffer: mutable byte[]
    TypeId: TypeId get
    TypeSize: int32 get

    new(rawBuffer: mutable byte[], typeId: TypeId, typeSize: int32) =
        {          
            RawBuffer = rawBuffer
            TypeId = typeId
            TypeSize = typeSize
        }

    CopyTo(dst: ComponentBuffer, lengthInBytes: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer).RawBuffer
        Span(this.RawBuffer, 0, lengthInBytes).CopyTo(Span(dstBuffer, 0, lengthInBytes))

    CopyOneTo(srcIndex: int32, dst: ComponentBuffer, dstIndex: int32): () =
        Span(this.RawBuffer, srcIndex * this.TypeSize, this.TypeSize).CopyTo(Span(dst.RawBuffer, dstIndex * this.TypeSize, this.TypeSize))

internal class Archetype =
    
    Id: ArchetypeId get
    DependencyId: ArchetypeId get
    FullId: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: ComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    CopyTo(dst: Archetype): () =
        let count = this.Count
        
        //Span(this.Lookup).CopyTo(Span(dst.Lookup))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))

        // fix-up lookup
        let entIds = dst.EntityIds
        let lookup = dst.Lookup
        let mutable i = 0
        while (i < count)
            lookup[entIds[i].Index] <- i
            i <- i + 1

        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))
        dst.Count <- count

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                buffer.CopyTo(dst.Buffers[dstBufferIndex], count * buffer.TypeSize)
            i <- i + 1 

    CopyOneTo(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                buffer.CopyOneTo(srcIndex, dst.Buffers[dstBufferIndex], dstIndex)

            i <- i + 1 
            
    GetRawComponentBuffer<T>(typedIndex: int32): Span<T> where T: unmanaged =
        MemoryMarshal.Cast<byte, T>(Span(this.Buffers[typedIndex].RawBuffer))

    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    new(size: int32, buffers: ComponentBuffer[], archetypeId: ArchetypeId, dependencyId: ArchetypeId) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        {
            Id = archetypeId
            DependencyId = dependencyId
            FullId = archetypeId | dependencyId
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

internal interface IArchetypeReference =

    ArchetypedIndex: int32 get
    LastTypedIndex: int32 get

internal class ArchetypeReference1 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex0

    new(archetypedIndex: int32, typedIndex0: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
        }

internal class ArchetypeReference2 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex1

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
        }

internal class ArchetypeReference3 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex2

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
        }

internal class ArchetypeReference4 =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    TypedIndex3: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex3

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32, typedIndex3: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
            TypedIndex3 = typedIndex3
        }

internal class EntityQuery<T0> where T0: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1> where T0: unmanaged
                          where T1: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

interface IEntityEvent<T> =

    Add(subscriber: T -> ()): ()

internal class EntityEvent<T> =
    implements IEntityEvent<T>

    field subscribers: List<T -> ()> = List()
    field lockObj: object = System.Object()

    Add(subscriber: T -> ()): () =
        this.subscribers.Add(subscriber)

    Trigger(eventData: T): () =
        let mutable i = 0
        while (i < this.subscribers.Count)
            let subscriber = this.subscribers[i]
            subscriber(eventData)
            i <- i + 1

class ByteStream =
    mutable field buffer: mutable byte[] = Array.ZeroCreate(65536)
    mutable field position: int32 = 0
    mutable field count: int32 = 0

    Count: int32 get() = this.count
    Position: int32 get() = this.position

    ResetPosition(): () =
        this.position <- 0

    Reset(): () =
        this.ResetPosition()
        this.count <- 0

    private WriteCore<T>(isReading: bool, value: byref<T>): int32 where T: unmanaged =
        let size = sizeof<T>
        if (size >= 65536)
            fail("Value too big.")

        let currentPosition = this.position
        let nextPosition = currentPosition + size

        let mutable buffer = this.buffer

        if (isReading)
            let mutable span = MemoryMarshal.Cast<_, T>(Span(buffer, currentPosition, size))
            let result = span[0]
            value <- result
        else
            ()
            if (nextPosition >= buffer.Length)
                let newBuffer = Array.ZeroCreate<byte>(buffer.Length * 2)
                System.Array.Copy(Unsafe.Cast(buffer), Unsafe.Cast(newBuffer), buffer.Length)
                buffer <- newBuffer
                this.buffer <- buffer

            if (this.count < nextPosition)
                this.count <- nextPosition

            (MemoryMarshal.Cast(Span(buffer, currentPosition, size))[0]) <- value

        this.position <- nextPosition
        size

    Write<T>(mutable value: T): () where T: unmanaged = let _ = this.WriteCore<T>(false, &value)
    Peek<T>(): T where T: unmanaged =
        let oldPosition = this.Position
        let value = this.Read<T>()
        this.position <- oldPosition
        value
    Read<T>(): T where T: unmanaged =
        let mutable value = unchecked default
        let _ = this.WriteCore(true, &value)
        value

    CopyExactTo(bstream: ByteStream): () =
        bstream.position <- this.position
        bstream.count <- this.count

        if (bstream.buffer.Length < this.buffer.Length)
            bstream.buffer <- Array.ZeroCreate(this.buffer.Length)

        Span(this.buffer, 0, this.count).CopyTo(Span(bstream.buffer))

    Write(mutable value: ReadOnlySpan<byte>): () =
        let currentPosition = this.position
        let nextPosition = currentPosition + value.Length

        let buffer = this.buffer

        if (nextPosition >= buffer.Length)
            let newBuffer = Array.ZeroCreate<byte>(buffer.Length * 2)
            System.Array.Copy(Unsafe.Cast(buffer), Unsafe.Cast(newBuffer), buffer.Length)
            this.buffer <- newBuffer
            this.Write(value)
        else
            value.CopyTo(Span(this.buffer, currentPosition, value.Length))

        this.position <- nextPosition

    Write<T>(mutable value: ReadOnlySpan<T>): () where T: unmanaged =
        let size = sizeof<T>
        let totalByteLength = size * value.Length           
        let currentPosition = this.position
        let nextPosition = currentPosition + totalByteLength

        let buffer = this.buffer

        if (nextPosition >= buffer.Length)
            let newBuffer = Array.ZeroCreate<byte>(buffer.Length * 2)
            System.Array.Copy(Unsafe.Cast(buffer), Unsafe.Cast(newBuffer), buffer.Length)
            this.buffer <- newBuffer
            this.Write(value)
        else
            MemoryMarshal.Cast(value).CopyTo(Span(this.buffer, currentPosition, totalByteLength))

        this.position <- nextPosition

    Read(mutable dst: Span<byte>): () =
        let currentPosition = this.position
        let nextPosition = currentPosition + dst.Length

        Span(this.buffer, currentPosition, dst.Length).CopyTo(dst)

        this.position <- nextPosition

    Read<T>(mutable dst: Span<T>): () where T: unmanaged =
        let size = sizeof<T>
        let totalByteLength = size * dst.Length  
        let currentPosition = this.position
        let nextPosition = currentPosition + totalByteLength

        Span(this.buffer, currentPosition, totalByteLength).CopyTo(MemoryMarshal.Cast(dst))

        this.position <- nextPosition

class EntityDatabase =

    private class ArchetypeIdEqualityComparer =
        implements IEqualityComparer<ArchetypeId>
    
        GetHashCode(x: ArchetypeId): int32 = int32(x)
    
        Equals(x: ArchetypeId, y: ArchetypeId): bool = x == y

    public static field MaxNumberOfEntities: int32 = 65536  

    internal field entityCreated: EntityEvent<EntityId> = EntityEvent()
    EntityCreated: IEntityEvent<EntityId> get() = this.entityCreated

    internal field entityDeleting: EntityEvent<EntityId> = EntityEvent()
    EntityDeleting: IEntityEvent<EntityId> get() = this.entityDeleting

    private Registered: Dictionary<TypeId, int32> get = Dictionary()
    Register<T>(): () where T: unmanaged, IComponent = this.Registered.Add(T.GetTypeId(), T.GetSize())
    GetTypeSize(tyId: TypeId): int32                 = this.Registered[tyId]
    
    internal Archetypes: List<Archetype> get = List()
    internal ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())
    internal DependencyLookup: Dictionary<TypeId, ArchetypeId> get = Dictionary()

    private GetArchetypedIndex<T0>(): int32 where T0: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0>())

    private GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged, IComponent
                                                where T1: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1>())

    private GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged, IComponent
                                                    where T1: unmanaged, IComponent
                                                    where T2: unmanaged, IComponent =
        this.GetArchetypedIndex(GetArchetypeId<T0, T1, T2>())

    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            archetypedIndex <- this.Archetypes.Count

            let origArchetypeId = archetypeId
            let origTyIds = GetTypeIds(origArchetypeId)

            let mutable dependencyId = 0: ArchetypeId

            let archetypeId =
                let mutable archetypeId = archetypeId
                let mutable i = 0
                while (i < origTyIds.Length)
                    let mutable result = unchecked default
                    if (this.DependencyLookup.TryGetValue(origTyIds[i], &result))
                        archetypeId <- archetypeId | result
                        dependencyId <- dependencyId | result
                    i <- i + 1
                archetypeId

            let tyIds = GetTypeIds(archetypeId)

            let sizes = Array.Map(tyIds, tyId -> this.GetTypeSize(tyId))
            let buffers = Array.MapIndex(tyIds, (i, tyId) -> ComponentBuffer(Array.ZeroCreate<byte>(EntityDatabase.MaxNumberOfEntities * sizes[i]), tyId, sizes[i]))

            let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, buffers, origArchetypeId, dependencyId)

            this.Archetypes.Add(archetype)
            this.ArchetypeLookup[origArchetypeId] <- archetypedIndex
            archetypedIndex

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged, IComponent =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[T.GetTypeId()]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if ((archetype.FullId & archetypeId) == archetypeId)
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    internal RegisterArchetype<T0>(): ArchetypeReference1 where T0: unmanaged, IComponent =
        let archetypedIndex = this.GetArchetypedIndex<T0>()
        ArchetypeReference1(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex))

    private RegisterArchetype<T0, T1>(): ArchetypeReference2 where T0: unmanaged, IComponent 
                                                             where T1: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1>()
        ArchetypeReference2(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex))

    private RegisterArchetype<T0, T1, T2>(): ArchetypeReference3 where T0: unmanaged, IComponent 
                                                                 where T1: unmanaged, IComponent  
                                                                 where T2: unmanaged, IComponent  =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1, T2>()
        ArchetypeReference3(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex), this.GetTypedIndex<T2>(archetypedIndex))
        
    private CreateQuery<T0>(): EntityQuery<T0> where T0: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = EntityQuery<T0>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1>(): EntityQuery<T0, T1> where T0: unmanaged, IComponent  
                                                       where T1: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = EntityQuery<T0, T1>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: unmanaged, IComponent  
                                                               where T1: unmanaged, IComponent 
                                                               where T2: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(): EntityQuery<T0, T1, T2, T3> where T0: unmanaged, IComponent  
                                                                       where T1: unmanaged, IComponent 
                                                                       where T2: unmanaged, IComponent  
                                                                       where T3: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetTypeId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetTypeId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetTypeId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetTypeId()]))

            i <- i + 1

        query

    RegisterDependency<T, TDependency>(): () where T: unmanaged, IComponent
                                             where TDependency: unmanaged, IComponent =
        this.DependencyLookup.Add(T.GetTypeId(), TDependency.GetTypeId())

    ForEachSpan<T0, T1>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                                   where T1: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2, T3>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                               where T1: unmanaged, IComponent 
                                                                                                               where T2: unmanaged, IComponent 
                                                                                                               where T3: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = this.CreateQuery<T0, T1, T2, T3>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup3[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEach<T0>(f: (EntityId, byref<T0>) -> ()): () where T0: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = this.CreateQuery<T0>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                   where T1: unmanaged, IComponent =
        this.ForEachSpan<T0, T1>(
            (mutable entIds, mutable buffer0, mutable buffer1) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i])
                    i <- i + 1
        )
            
    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                  where T1: unmanaged, IComponent 
                                                                                  where T2: unmanaged, IComponent =
        this.ForEachSpan<T0, T1, T2>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i])
                    i <- i + 1
        )

    ForEach<T0, T1, T2, T3>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent 
                                                                                                 where T3: unmanaged, IComponent =

        this.ForEachSpan<T0, T1, T2, T3>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i])
                    i <- i + 1
        )
            
    Create<T0>(value0: T0): EntityId where T0: unmanaged, IComponent =
        this.Create(&value0)
    Create<T0>(value0: inref<T0>): EntityId where T0: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: unmanaged, IComponent
                                                     where T1: unmanaged, IComponent =
        this.Create(&value0, &value1)
    Create<T0, T1>(value0: inref<T0>, value1: inref<T1>): EntityId where T0: unmanaged, IComponent
                                                                   where T1: unmanaged, IComponent =
        let archetypeRef = this.RegisterArchetype<T0, T1>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: unmanaged, IComponent
                                                                     where T1: unmanaged, IComponent 
                                                                     where T2: unmanaged, IComponent = 
        this.Create(&value0, &value1, &value2)
    Create<T0, T1, T2>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>): EntityId where T0: unmanaged, IComponent
                                                                                          where T1: unmanaged, IComponent 
                                                                                          where T2: unmanaged, IComponent =                                                                
        let archetypeRef = this.RegisterArchetype<T0, T1, T2>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1
        let typedIndex2 = archetypeRef.TypedIndex2

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    private AddCore(entId: EntityId, typeId: TypeId): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.Archetypes[srcArchetypedIndex]
        let srcArchetypeId = srcArchetype.Id

        if ((srcArchetypeId & typeId) == typeId)
            srcArchetype
        else
            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.Archetypes[dstArchetypedIndex]

            let srcIndex = srcArchetype.Lookup[entId.Index]
            let dstIndex = dstArchetype.Count
            srcArchetype.CopyOneTo(srcIndex, dstArchetype, dstIndex)
            dstArchetype.Lookup[entId.Index] <- dstIndex
            dstArchetype.EntityIds[dstIndex] <- entId
            dstArchetype.Count <- dstIndex + 1

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex
            this.entityArchetypeIds[entId.Index] <- dstArchetypeId

            dstArchetype

    AddOrUpdate<T>(entId: EntityId, value: T): () where T: unmanaged, IComponent =
        this.AddOrUpdate(entId, &value)
    AddOrUpdate<T>(entId: EntityId, value: inref<T>): () where T: unmanaged, IComponent =
        let tyId: TypeId = T.GetTypeId()
        let archetype = this.AddCore(entId, tyId)
        (archetype.GetRawComponentBuffer(archetype.BufferLookup[tyId])[archetype.Lookup[entId.Index]]) <- value

    Has<T>(entId: EntityId): bool where T: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId = T.GetTypeId()
        (archetype.FullId & tyId) == tyId

    TryGet<T>(entId: EntityId, callback: byref<T> -> ()): bool where T: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId = T.GetTypeId()
        if ((archetype.FullId & tyId) == tyId)
            let mutable buffer = archetype.GetRawComponentBuffer<T>(archetype.BufferLookup[tyId])
            callback(&buffer[archetype.Lookup[entId.Index]])
            true
        else
            false

    TryGet<T0, T1>(entId: EntityId, callback: (byref<T0>, byref<T1>) -> ()): bool where T0: unmanaged, IComponent where T1: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId0 = T0.GetTypeId()
        let tyId1 = T1.GetTypeId()
        let tyId = tyId0 | tyId1
        if ((archetype.FullId & tyId) == tyId)
            let mutable buffer0 = archetype.GetRawComponentBuffer<T0>(archetype.BufferLookup[tyId0])
            let mutable buffer1 = archetype.GetRawComponentBuffer<T1>(archetype.BufferLookup[tyId1])
            callback(
                &buffer0[archetype.Lookup[entId.Index]],
                &buffer1[archetype.Lookup[entId.Index]]
            )
            true
        else
            false

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.entityDeleting.Trigger(entId)
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[archetypedIndex]

        // ---
        let index = archetype.Lookup[entId.Index]
        let lastIndex = archetype.Count - 1
        this.Swap(archetype, index, lastIndex)
        archetype.Count <- lastIndex
        // ---

        this.entityArchetypeIds[entId.Index] <- 0
        this.DeleteEntityId(entId)

    private Swap(archetype: Archetype, index: int32, lastIndex: int32): () =
        let lastEntId = archetype.EntityIds[lastIndex]

        if (lastIndex != index)
            archetype.Lookup[lastEntId.Index] <- index
            archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]

            // TODO: Optimize this.
            let tyIds = GetTypeIds(archetype.FullId)
            let mutable i = 0
            while (i < tyIds.Length)
                let buffer = archetype.Buffers[archetype.BufferLookup[tyIds[i]]]
                buffer.CopyOneTo(lastIndex, buffer, index)
                i <- i + 1

    // ----------------------------------------------

    internal mutable field nextIndex: int32 = 0
    internal mutable field indexQueue: Queue<int32> = Queue()
    internal mutable field entityCount: int32 = 0
    internal field entityArchetypeIds: mutable ArchetypeId[] = Array.ZeroCreate(EntityDatabase.MaxNumberOfEntities)
    internal field entityArchetypeIndices: mutable int32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> -1)
    internal field entityVersions: mutable uint32[] = Array.ZeroCreate(EntityDatabase.MaxNumberOfEntities)

    internal NewEntityId(archetypedIndex: int32): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != EntityDatabase.MaxNumberOfEntities

    EntityCount: int32 get() = this.entityCount

    CopyTo(dst: EntityDatabase): () =
        if (this.Archetypes.Count != dst.Archetypes.Count)
            let mutable i = 0
            while (i < this.Archetypes.Count)
                let archetype = this.Archetypes[i]
                let _ = dst.GetArchetypedIndex(archetype.Id)
                i <- i + 1

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityArchetypeIds).CopyTo(Span(dst.entityArchetypeIds))

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            archetype.CopyTo(dst.Archetypes[i])
            i <- i + 1

    Serialize(bstream: ByteStream): () =
        let archetypes = this.Archetypes

        bstream.Write(this.Registered.Count)
        ForEach(this.Registered,
            (mutable pair) ->
                bstream.Write(pair.Key)
                bstream.Write(pair.Value)
        )

        bstream.Write(this.entityCount)

        let mutable i = 0
        while (i < archetypes.Count)
            let archetype = archetypes[i]
            let count = archetype.Count
            let buffers = archetype.Buffers

            bstream.Write(archetype.Id)
            bstream.Write(count)
            bstream.Write(buffers.Length)
            bstream.Write(archetype.EntityIds.AsReadOnlySpan(0, count): ReadOnlySpan<EntityId>) // TODO: language bug, we should not need to annotate with 'ReadOnlySpan<EntityId>'.

            let mutable j = 0
            while (j < buffers.Length)
                let buffer = buffers[j]
                let length = buffer.TypeSize * count
                let mutable rawBufferSpan = buffer.RawBuffer.AsReadOnlySpan<byte>(0, length)
                bstream.Write(buffer.TypeId)
                bstream.Write(length)
                bstream.Write(rawBufferSpan) // TODO: language bug, we should be able to use '.AsReadOnlySpan()' without the type argument.
                j <- j + 1

            i <- i + 1

    static DeserializeInto(bstream: ByteStream, db: EntityDatabase): () =
        let registerCount = bstream.Read<int32>()
        let mutable i = 0
        while (i < registerCount)
            let key = bstream.Read<uint64>()
            let value = bstream.Read<int32>()
            db.Registered[key] <- value
            i <- i + 1
        
        db.entityCount <- bstream.Read()

        while (bstream.Position < bstream.Count)
            let archetypeId = bstream.Read<ArchetypeId>()
            let count = bstream.Read<int32>()
            let bufferCount = bstream.Read<int32>()
            
            let archetypedIndex = db.GetArchetypedIndex(archetypeId)
            let archetype = db.Archetypes[archetypedIndex]
            let buffers = archetype.Buffers
            let bufferLookup = archetype.BufferLookup

            let entIds = archetype.EntityIds
            bstream.Read(entIds.AsSpan(0, count): Span<EntityId>) // TODO: language bug, we should not need to annotate with 'Span<EntityId>'.

            let mutable i = 0
            while (i < bufferCount)
                let compId = bstream.Read<uint64>()
                let length = bstream.Read<int32>()

                let mutable bufferIndex = unchecked default
                if (archetype.BufferLookup.TryGetValue(compId, &bufferIndex))
                    let rawBuffer = buffers[bufferIndex].RawBuffer
                    bstream.Read(rawBuffer.AsSpan(0, length): Span<byte>) // TODO: language bug, we should not need to annotate with 'Span<byte>'.
                else
                    fail("Unable to find component buffer. Was the component registered?")
                i <- i + 1

            archetype.Count <- count

            // Fix-ups
            let lookup = archetype.Lookup
            let entVersions = db.entityVersions 
            let entArchetypeIndices = db.entityArchetypeIndices
            let mutable i = 0
            while (i < count)
                let entId = entIds[i]
                let index = entId.Index
                entArchetypeIndices[index] <- archetypedIndex
                entVersions[index] <- entId.Version
                lookup[index] <- i
                i <- i + 1

    Replicate(dst: EntityDatabase, prev: EntityDatabase): () =
        let createdEnts = Queue<(EntityId, ArchetypeId)>()
        // --
        let prevVersions = prev.entityVersions
        let versions = this.entityVersions
        let mutable i = 0
        while (i < EntityDatabase.MaxNumberOfEntities)
            let prevVersion = prevVersions[i]
            let version = versions[i]

            let prevArchetypeId = prev.entityArchetypeIds[i]
            let archetypeId = this.entityArchetypeIds[i]

            if (prevVersion != version)
                if (prevArchetypeId != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- prevVersion
                    dst.entityDeleting.Trigger(entId)

                if (archetypeId != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    createdEnts.Enqueue((entId, archetypeId))

            if (prevArchetypeId != 0 && archetypeId != 0)
                let prevArchetype = prev.Archetypes[prev.entityArchetypeIndices[i]]
                let dstArchetype = dst.Archetypes[dst.entityArchetypeIndices[i]]
                let archetype = this.Archetypes[this.entityArchetypeIndices[i]]

                let prevIndex = prevArchetype.Lookup[i]
                let index = archetype.Lookup[i]
                
                if (prevIndex != index)
                    prevArchetype.CopyOneTo(prevIndex, dstArchetype, index)

            i <- i + 1
        // --

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIds).CopyTo(Span(dst.entityArchetypeIds))

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex

        let mutable i = 0
        while (i < this.Archetypes.Count)     
            let archetype = this.Archetypes[i]
            let mutable dstArchetypedIndex = unchecked default
            if (dst.ArchetypeLookup.TryGetValue(archetype.Id, &dstArchetypedIndex))
                archetype.CopyTo(dst.Archetypes[dstArchetypedIndex])
            i <- i + 1
            
        let mutable result = unchecked default
        while (createdEnts.TryDequeue(&result))
            let (entId, archetypeId) = result
            dst.entityVersions[entId.Index] <- entId.Version
            dst.entityArchetypeIndices[entId.Index] <- dst.GetArchetypedIndex(archetypeId)
            dst.entityCreated.Trigger(entId)