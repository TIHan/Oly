namespace Evergreen.Collections

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

alias ComponentId = BitSet512

interface IComponent =

    static abstract GetName(): string

    static abstract GetId(): ComponentId

    static abstract GetSize(): int32

// TODO: We cannot do this in Oly (yet).
// interface IComponent<N, T> where N: constant int32 where T: unmanaged =
//     inherits IComponent

//     static overrides GetComponentId(): ComponentId = (1: uint64) << N

//     static overrides GetSize(): int32 = sizeof<T>

internal alias ArchetypeId = BitSet512

#[open]
internal module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")

    GetArchetypeId<T0>(): ArchetypeId where T0: IComponent = T0.GetId()

    GetArchetypeId<T0, T1>(): ArchetypeId where T0: IComponent where T1: IComponent = T0.GetId() | T1.GetId()

    GetArchetypeId<T0, T1, T2>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent = T0.GetId() | T1.GetId() | T2.GetId()

    GetArchetypeId<T0, T1, T2, T3>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent where T3: IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId()

    GetArchetypeId<T0, T1, T2, T3, T4>(): ArchetypeId where T0: IComponent where T1: IComponent where T2: IComponent where T3: IComponent where T4: IComponent = T0.GetId() | T1.GetId() | T2.GetId() | T3.GetId() | T4.GetId()

    GetComponentIds(archetypeId: ArchetypeId): ComponentId[] =
        let size = sizeof<ArchetypeId>
        let bytes = Array.ZeroCreate<byte>(size)
        let mutable bytesHandle = GCHandle.Alloc(bytes, GCHandleType.Pinned)
        Marshal.StructureToPtr(archetypeId, bytesHandle.AddrOfPinnedObject(), true)
        bytesHandle.Free()

        // TODO: Do we need to optimize this?
        let bitArray = System.Collections.BitArray(bytes)
        let tyIds = List<ComponentId>()            
        let mutable i = 0
        while (i < bitArray.Count)
            if (bitArray.Get(i))
                tyIds.Add(BitSet512.FromIndex(i))
            i <- i + 1
        Unsafe.AsImmutable(tyIds.ToArray())

internal class ComponentBuffer =

    public field RawBuffer: mutable byte[]
    ComponentId: ComponentId get
    TypeSize: int32 get

    new(rawBuffer: mutable byte[], typeId: ComponentId, typeSize: int32) =
        {          
            RawBuffer = rawBuffer
            ComponentId = typeId
            TypeSize = typeSize
        }

    CopyTo(dst: ComponentBuffer, lengthInBytes: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer).RawBuffer
        Span(this.RawBuffer, 0, lengthInBytes).CopyTo(Span(dstBuffer, 0, lengthInBytes))

    CopyOneTo(srcIndex: int32, dst: ComponentBuffer, dstIndex: int32): () =
        Span(this.RawBuffer, srcIndex * this.TypeSize, this.TypeSize).CopyTo(Span(dst.RawBuffer, dstIndex * this.TypeSize, this.TypeSize))

internal class Archetype =
    
    Id: ArchetypeId get
    DependencyId: ArchetypeId get
    FullId: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: ComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<ComponentId, int32> get

    CopyTo(dst: Archetype): () =
        let count = this.Count
        
        //Span(this.Lookup).CopyTo(Span(dst.Lookup))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))

        // fix-up lookup
        let entIds = dst.EntityIds
        let lookup = dst.Lookup
        let mutable i = 0
        while (i < count)
            lookup[entIds[i].Index] <- i
            i <- i + 1

        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))
        dst.Count <- count

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.ComponentId, &dstBufferIndex))
                buffer.CopyTo(dst.Buffers[dstBufferIndex], count * buffer.TypeSize)
            i <- i + 1 

    CopyOneTo(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (dst.BufferLookup.TryGetValue(buffer.ComponentId, &dstBufferIndex))
                buffer.CopyOneTo(srcIndex, dst.Buffers[dstBufferIndex], dstIndex)

            i <- i + 1 
            
    GetRawComponentBuffer<T>(typedIndex: int32): Span<T> where T: unmanaged =
        MemoryMarshal.Cast<byte, T>(Span(this.Buffers[typedIndex].RawBuffer))

    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    new(size: int32, buffers: ComponentBuffer[], archetypeId: ArchetypeId, dependencyId: ArchetypeId) =
        let bufferLookup = ConcurrentDictionary(BitSet512EqualityComparer())

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.ComponentId] <- i 
            i <- i + 1

        {
            Id = archetypeId
            DependencyId = dependencyId
            FullId = archetypeId | dependencyId
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

internal class EntityQuery<T0> where T0: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1> where T0: unmanaged
                          where T1: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3, T4> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged
                              where T4: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()
    BufferGroup4: List<ComponentBuffer> get       = List()

interface IEntityEvent<T> =

    Add(subscriber: T -> ()): ()

internal class EntityEvent<T> =
    implements IEntityEvent<T>

    field subscribers: List<T -> ()> = List()
    field lockObj: object = System.Object()

    Add(subscriber: T -> ()): () =
        this.subscribers.Add(subscriber)

    Trigger(eventData: T): () =
        let mutable i = 0
        while (i < this.subscribers.Count)
            let subscriber = this.subscribers[i]
            subscriber(eventData)
            i <- i + 1

/// Not concurrency safe.
class EntityDatabase =

    public static field MaxNumberOfEntities: int32 = 65536

    internal field entityCreated: EntityEvent<EntityId> = EntityEvent()
    EntityCreated: IEntityEvent<EntityId> get() = this.entityCreated

    internal field entityDeleting: EntityEvent<EntityId> = EntityEvent()
    EntityDeleting: IEntityEvent<EntityId> get() = this.entityDeleting

    private Registered: Dictionary<ComponentId, int32> get = Dictionary(BitSet512EqualityComparer())
    Register<T>(): () where T: unmanaged, IComponent = this.Registered.Add(T.GetId(), T.GetSize())
    GetTypeSize(tyId: ComponentId): int32                 = this.Registered[tyId]
    
    internal Archetypes: List<Archetype> get = List()
    internal ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(BitSet512EqualityComparer())
    internal AttachmentLookup: Dictionary<ComponentId, ArchetypeId> get = Dictionary(BitSet512EqualityComparer())

    internal GetArchetypedIndex(archetypeId: ArchetypeId): int32 =
        let mutable archetypedIndex = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &archetypedIndex))
            archetypedIndex
        else
            archetypedIndex <- this.Archetypes.Count

            let origArchetypeId = archetypeId
            let origTyIds = GetComponentIds(origArchetypeId)

            let mutable dependencyId = BitSet512(0): ArchetypeId

            let archetypeId =
                let mutable archetypeId = archetypeId
                let mutable i = 0
                while (i < origTyIds.Length)
                    let mutable result = unchecked default
                    if (this.AttachmentLookup.TryGetValue(origTyIds[i], &result))
                        archetypeId <- archetypeId | result
                        dependencyId <- dependencyId | result
                    i <- i + 1
                archetypeId

            let tyIds = GetComponentIds(archetypeId)

            let buffers = List(tyIds.Length)
            let mutable i = 0
            while (i < tyIds.Length)
                let tyId = tyIds[i]
                if (this.Registered.ContainsKey(tyId))
                    let size = this.GetTypeSize(tyId)
                    let buffer = ComponentBuffer(Array.ZeroCreate<byte>(EntityDatabase.MaxNumberOfEntities * size), tyId, size)
                    buffers.Add(buffer)
                i <- i + 1

            let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, Unsafe.AsImmutable(buffers.ToArray()), origArchetypeId, dependencyId)

            this.Archetypes.Add(archetype)
            this.ArchetypeLookup[origArchetypeId] <- archetypedIndex
            archetypedIndex

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged, IComponent =
        let key = T.GetId()
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[key]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if (archetype.FullId.IsSupersetOf(archetypeId))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())
        
    private CreateQuery<T0>(): EntityQuery<T0> where T0: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = EntityQuery<T0>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1>(): EntityQuery<T0, T1> where T0: unmanaged, IComponent  
                                                       where T1: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = EntityQuery<T0, T1>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: unmanaged, IComponent  
                                                               where T1: unmanaged, IComponent 
                                                               where T2: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(): EntityQuery<T0, T1, T2, T3> where T0: unmanaged, IComponent  
                                                                       where T1: unmanaged, IComponent 
                                                                       where T2: unmanaged, IComponent  
                                                                       where T3: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3, T4>(): EntityQuery<T0, T1, T2, T3, T4> where T0: unmanaged, IComponent  
                                                                       where T1: unmanaged, IComponent 
                                                                       where T2: unmanaged, IComponent  
                                                                       where T3: unmanaged, IComponent
                                                                       where T4: unmanaged, IComponent  =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4>())

        let query = EntityQuery<T0, T1, T2, T3, T4>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T0.GetId()]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T1.GetId()]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T2.GetId()]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T3.GetId()]))
            query.BufferGroup4.Add(archetype.GetComponentBuffer(archetype.BufferLookup[T4.GetId()]))

            i <- i + 1

        query

    RegisterAttachment<T, TAttachment>(): () where T: unmanaged, IComponent
                                             where TAttachment: unmanaged, IComponent =
        this.AttachmentLookup.Add(T.GetId(), TAttachment.GetId())

    ForEachSpan<T0, T1>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                                   where T1: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2, T3>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                               where T1: unmanaged, IComponent 
                                                                                                               where T2: unmanaged, IComponent 
                                                                                                               where T3: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3>())

        let query = this.CreateQuery<T0, T1, T2, T3>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup3[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEachSpan<T0, T1, T2, T3, T4>(f: (ReadOnlySpan<EntityId>, Span<T0>, Span<T1>, Span<T2>, Span<T3>, Span<T4>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                                             where T1: unmanaged, IComponent 
                                                                                                                             where T2: unmanaged, IComponent 
                                                                                                                             where T3: unmanaged, IComponent
                                                                                                                             where T4: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2, T3, T4>())

        let query = this.CreateQuery<T0, T1, T2, T3, T4>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3
        let bufferGroup4 = query.BufferGroup4

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count

            f(
                ReadOnlySpan(entIdGroup[i], 0, count),
                MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup1[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup2[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup3[i].RawBuffer)).Slice(0, count),
                MemoryMarshal.Cast(Span(bufferGroup4[i].RawBuffer)).Slice(0, count)
            )

            i <- i + 1

    ForEach<T0>(f: (EntityId, byref<T0>) -> ()): () where T0: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0>())

        let query = this.CreateQuery<T0>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].RawBuffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j])
                j <- j + 1

            i <- i + 1  

    ParallelForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                   where T1: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1>())

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            
            let entIds = entIdGroup[i]
            let mutable buffer0Mem = Memory(bufferGroup0[i].RawBuffer)
            let mutable buffer1Mem = Memory(bufferGroup1[i].RawBuffer)

            ParallelFor(count,
                j ->
                    let mutable buffer0: Span<T0> = MemoryMarshal.Cast(buffer0Mem.Span)
                    let mutable buffer1: Span<T1> = MemoryMarshal.Cast(buffer1Mem.Span)
                    f(entIds[j], &buffer0[j], &buffer1[j])
            )

            i <- i + 1

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged, IComponent 
                                                                   where T1: unmanaged, IComponent =
        this.ForEachSpan<T0, T1>(
            (mutable entIds, mutable buffer0, mutable buffer1) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i])
                    i <- i + 1
        )
            
    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                  where T1: unmanaged, IComponent 
                                                                                  where T2: unmanaged, IComponent =
        this.ForEachSpan<T0, T1, T2>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i])
                    i <- i + 1
        )

    ParallelForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged, IComponent 
                                                                                          where T1: unmanaged, IComponent 
                                                                                          where T2: unmanaged, IComponent =
        let indices = this.GetArchetypedIndices(GetArchetypeId<T0, T1, T2>())

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            
            let entIds = entIdGroup[i]
            let mutable buffer0Mem = Memory(bufferGroup0[i].RawBuffer)
            let mutable buffer1Mem = Memory(bufferGroup1[i].RawBuffer)
            let mutable buffer2Mem = Memory(bufferGroup2[i].RawBuffer)

            ParallelFor(count,
                j ->
                    let mutable buffer0: Span<T0> = MemoryMarshal.Cast(buffer0Mem.Span)
                    let mutable buffer1: Span<T1> = MemoryMarshal.Cast(buffer1Mem.Span)
                    let mutable buffer2: Span<T2> = MemoryMarshal.Cast(buffer2Mem.Span)
                    f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j])
            )

            i <- i + 1

    ForEach<T0, T1, T2, T3>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                 where T1: unmanaged, IComponent 
                                                                                                 where T2: unmanaged, IComponent 
                                                                                                 where T3: unmanaged, IComponent =

        this.ForEachSpan<T0, T1, T2, T3>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i])
                    i <- i + 1
        )

    ForEach<T0, T1, T2, T3, T4>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>, byref<T4>) -> ()): () where T0: unmanaged, IComponent 
                                                                                                                where T1: unmanaged, IComponent 
                                                                                                                where T2: unmanaged, IComponent 
                                                                                                                where T3: unmanaged, IComponent
                                                                                                                where T4: unmanaged, IComponent =

        this.ForEachSpan<T0, T1, T2, T3, T4>(
            (mutable entIds, mutable buffer0, mutable buffer1, mutable buffer2, mutable buffer3, mutable buffer4) ->
                let count = entIds.Length
                let mutable i = 0
                while (i < count)
                    f(entIds[i], &buffer0[i], &buffer1[i], &buffer2[i], &buffer3[i], &buffer4[i])
                    i <- i + 1
        )
            
    Create<T0>(value0: T0): EntityId where T0: unmanaged, IComponent =
        this.Create(&value0)
    Create<T0>(value0: inref<T0>): EntityId where T0: unmanaged, IComponent =
        let archetypeId = GetArchetypeId<T0>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: unmanaged, IComponent
                                                     where T1: unmanaged, IComponent =
        this.Create(&value0, &value1)
    Create<T0, T1>(value0: inref<T0>, value1: inref<T1>): EntityId where T0: unmanaged, IComponent
                                                                   where T1: unmanaged, IComponent =
        let archetypeId = GetArchetypeId<T0, T1>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: unmanaged, IComponent
                                                                     where T1: unmanaged, IComponent 
                                                                     where T2: unmanaged, IComponent = 
        this.Create(&value0, &value1, &value2)
    Create<T0, T1, T2>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>): EntityId where T0: unmanaged, IComponent
                                                                                          where T1: unmanaged, IComponent 
                                                                                          where T2: unmanaged, IComponent =                                                                
        let archetypeId = GetArchetypeId<T0, T1, T2>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2, T3>(value0: T0, value1: T1, value2: T2, value3: T3): EntityId where T0: unmanaged, IComponent
                                                                                     where T1: unmanaged, IComponent 
                                                                                     where T2: unmanaged, IComponent 
                                                                                     where T3: unmanaged, IComponent = 
        this.Create(&value0, &value1, &value2, &value3)
    Create<T0, T1, T2, T3>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>): EntityId where T0: unmanaged, IComponent
                                                                                                                 where T1: unmanaged, IComponent 
                                                                                                                 where T2: unmanaged, IComponent
                                                                                                                 where T3: unmanaged, IComponent =                                                                
        let archetypeId = GetArchetypeId<T0, T1, T2, T3>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2
        (archetype.GetRawComponentBuffer(typedIndex3)[index]) <- value3

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2, T3, T4>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4): EntityId where T0: unmanaged, IComponent
                                                                                                     where T1: unmanaged, IComponent 
                                                                                                     where T2: unmanaged, IComponent 
                                                                                                     where T3: unmanaged, IComponent
                                                                                                     where T4: unmanaged, IComponent = 
        this.Create(&value0, &value1, &value2, &value3, &value4)
    Create<T0, T1, T2, T3, T4>(value0: inref<T0>, value1: inref<T1>, value2: inref<T2>, value3: inref<T3>, value4: inref<T4>): EntityId where T0: unmanaged, IComponent
                                                                                                                                        where T1: unmanaged, IComponent 
                                                                                                                                        where T2: unmanaged, IComponent
                                                                                                                                        where T3: unmanaged, IComponent
                                                                                                                                        where T4: unmanaged, IComponent =                                                                
        let archetypeId = GetArchetypeId<T0, T1, T2, T3, T4>()
        let archetypedIndex = this.GetArchetypedIndex(archetypeId)
        let typedIndex0 = this.GetTypedIndex<T0>(archetypedIndex)
        let typedIndex1 = this.GetTypedIndex<T1>(archetypedIndex)
        let typedIndex2 = this.GetTypedIndex<T2>(archetypedIndex)
        let typedIndex3 = this.GetTypedIndex<T3>(archetypedIndex)
        let typedIndex4 = this.GetTypedIndex<T4>(archetypedIndex)

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2
        (archetype.GetRawComponentBuffer(typedIndex3)[index]) <- value3
        (archetype.GetRawComponentBuffer(typedIndex4)[index]) <- value4

        this.entityArchetypeIds[entId.Index] <- archetype.Id

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    private AddCore(entId: EntityId, typeId: ComponentId): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.Archetypes[srcArchetypedIndex]
        let srcArchetypeId = srcArchetype.Id

        if (srcArchetypeId.IsSupersetOf(typeId))
            srcArchetype
        else
            let dstArchetypeId = srcArchetypeId | typeId
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.Archetypes[dstArchetypedIndex]

            let srcIndex = srcArchetype.Lookup[entId.Index]
            let dstIndex = dstArchetype.Count
            srcArchetype.CopyOneTo(srcIndex, dstArchetype, dstIndex)
            dstArchetype.Lookup[entId.Index] <- dstIndex
            dstArchetype.EntityIds[dstIndex] <- entId
            dstArchetype.Count <- dstIndex + 1

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex
            this.entityArchetypeIds[entId.Index] <- dstArchetypeId

            dstArchetype

    AddOrUpdate<T>(entId: EntityId, value: T): () where T: unmanaged, IComponent =
        this.AddOrUpdate(entId, &value)
    AddOrUpdate<T>(entId: EntityId, value: inref<T>): () where T: unmanaged, IComponent =
        let tyId: ComponentId = T.GetId()
        let archetype = this.AddCore(entId, tyId)
        (archetype.GetRawComponentBuffer(archetype.BufferLookup[tyId])[archetype.Lookup[entId.Index]]) <- value

    Has<T>(entId: EntityId): bool where T: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId = T.GetId()
        archetype.FullId.IsSupersetOf(tyId)

    TryGet<T>(entId: EntityId, callback: byref<T> -> ()): bool where T: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId = T.GetId()
        if (archetype.FullId.IsSupersetOf(tyId))
            let mutable buffer = archetype.GetRawComponentBuffer<T>(archetype.BufferLookup[tyId])
            callback(&buffer[archetype.Lookup[entId.Index]])
            true
        else
            false

    TryGet<T0, T1>(entId: EntityId, callback: (byref<T0>, byref<T1>) -> ()): bool where T0: unmanaged, IComponent where T1: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId0 = T0.GetId()
        let tyId1 = T1.GetId()
        let tyId = tyId0 | tyId1
        if (archetype.FullId.IsSupersetOf(tyId))
            let mutable buffer0 = archetype.GetRawComponentBuffer<T0>(archetype.BufferLookup[tyId0])
            let mutable buffer1 = archetype.GetRawComponentBuffer<T1>(archetype.BufferLookup[tyId1])
            callback(
                &buffer0[archetype.Lookup[entId.Index]],
                &buffer1[archetype.Lookup[entId.Index]]
            )
            true
        else
            false

    TryGet<T0, T1, T2>(entId: EntityId, callback: (byref<T0>, byref<T1>, byref<T2>) -> ()): bool where T0: unmanaged, IComponent where T1: unmanaged, IComponent where T2: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId0 = T0.GetId()
        let tyId1 = T1.GetId()
        let tyId2 = T2.GetId()
        let tyId = tyId0 | tyId1 | tyId2
        if (archetype.FullId.IsSupersetOf(tyId))
            let mutable buffer0 = archetype.GetRawComponentBuffer<T0>(archetype.BufferLookup[tyId0])
            let mutable buffer1 = archetype.GetRawComponentBuffer<T1>(archetype.BufferLookup[tyId1])
            let mutable buffer2 = archetype.GetRawComponentBuffer<T2>(archetype.BufferLookup[tyId2])
            callback(
                &buffer0[archetype.Lookup[entId.Index]],
                &buffer1[archetype.Lookup[entId.Index]],
                &buffer2[archetype.Lookup[entId.Index]]
            )
            true
        else
            false

    TryGet<T0, T1, T2, T3>(entId: EntityId, callback: (byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): bool where T0: unmanaged, IComponent where T1: unmanaged, IComponent where T2: unmanaged, IComponent where T3: unmanaged, IComponent =
        let index = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[index]
        let tyId0 = T0.GetId()
        let tyId1 = T1.GetId()
        let tyId2 = T2.GetId()
        let tyId3 = T3.GetId()
        let tyId = tyId0 | tyId1 | tyId2 | tyId3
        if (archetype.FullId.IsSupersetOf(tyId))
            let mutable buffer0 = archetype.GetRawComponentBuffer<T0>(archetype.BufferLookup[tyId0])
            let mutable buffer1 = archetype.GetRawComponentBuffer<T1>(archetype.BufferLookup[tyId1])
            let mutable buffer2 = archetype.GetRawComponentBuffer<T2>(archetype.BufferLookup[tyId2])
            let mutable buffer3 = archetype.GetRawComponentBuffer<T3>(archetype.BufferLookup[tyId3])
            callback(
                &buffer0[archetype.Lookup[entId.Index]],
                &buffer1[archetype.Lookup[entId.Index]],
                &buffer2[archetype.Lookup[entId.Index]],
                &buffer3[archetype.Lookup[entId.Index]]
            )
            true
        else
            false

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.entityDeleting.Trigger(entId)
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[archetypedIndex]

        // ---
        let index = archetype.Lookup[entId.Index]
        let lastIndex = archetype.Count - 1
        this.Swap(archetype, index, lastIndex)
        archetype.Count <- lastIndex
        // ---

        this.entityArchetypeIds[entId.Index] <- BitSet512(0)
        this.DeleteEntityId(entId)

    private Swap(archetype: Archetype, index: int32, lastIndex: int32): () =
        let lastEntId = archetype.EntityIds[lastIndex]

        if (lastIndex != index)
            archetype.Lookup[lastEntId.Index] <- index
            archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]

            // TODO: Optimize this.
            let tyIds = GetComponentIds(archetype.FullId)
            let mutable i = 0
            while (i < tyIds.Length)
                let buffer = archetype.Buffers[archetype.BufferLookup[tyIds[i]]]
                buffer.CopyOneTo(lastIndex, buffer, index)
                i <- i + 1

    // ----------------------------------------------

    internal mutable field nextIndex: int32 = 0
    internal mutable field indexQueue: Queue<int32> = Queue()
    internal mutable field entityCount: int32 = 0
    internal field entityArchetypeIds: mutable ArchetypeId[] = Array.ZeroCreate(EntityDatabase.MaxNumberOfEntities)
    internal field entityArchetypeIndices: mutable int32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> -1)
    internal field entityVersions: mutable uint32[] = Array.ZeroCreate(EntityDatabase.MaxNumberOfEntities)

    internal NewEntityId(archetypedIndex: int32): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != EntityDatabase.MaxNumberOfEntities

    EntityCount: int32 get() = this.entityCount

    CopyTo(dst: EntityDatabase): () =
        if (this.Archetypes.Count != dst.Archetypes.Count)
            let mutable i = 0
            while (i < this.Archetypes.Count)
                let archetype = this.Archetypes[i]
                let archetypedIndex = dst.GetArchetypedIndex(archetype.Id)
                if (i != archetypedIndex)
                    fail("Invalid archetype to copy.")
                i <- i + 1

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityArchetypeIds).CopyTo(Span(dst.entityArchetypeIds))

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            archetype.CopyTo(dst.Archetypes[i])
            i <- i + 1

    Serialize(bstream: ByteStream): () =
        let archetypes = this.Archetypes

        bstream.Write<int32>(this.Registered.Count)
        ForEach(this.Registered,
            (mutable pair) ->
                bstream.Write<ComponentId>(pair.Key)
                bstream.Write<int32>(pair.Value)
        )

        bstream.Write<int32>(this.entityCount)

        let mutable i = 0
        while (i < archetypes.Count)
            let archetype = archetypes[i]
            let count = archetype.Count
            let buffers = archetype.Buffers

            bstream.Write<ArchetypeId>(archetype.Id)
            bstream.Write<int32>(count)
            bstream.Write<int32>(buffers.Length)
            bstream.Write(archetype.EntityIds.AsReadOnlySpan(0, count): ReadOnlySpan<EntityId>) // TODO: language bug, we should not need to annotate with 'ReadOnlySpan<EntityId>'.

            let mutable j = 0
            while (j < buffers.Length)
                let buffer = buffers[j]
                let length = buffer.TypeSize * count
                let mutable rawBufferSpan = buffer.RawBuffer.AsReadOnlySpan<byte>(0, length)
                bstream.Write<ComponentId>(buffer.ComponentId)
                bstream.Write<int32>(length)
                bstream.Write(rawBufferSpan) // TODO: language bug, we should be able to use '.AsReadOnlySpan()' without the type argument.
                j <- j + 1

            i <- i + 1

    static DeserializeInto(bstream: ByteStream, db: EntityDatabase): () =
        let registerCount = bstream.Read<int32>()
        let mutable i = 0
        while (i < registerCount)
            let key = bstream.Read<ComponentId>()
            let value = bstream.Read<int32>()
            db.Registered[key] <- value
            i <- i + 1
        
        db.entityCount <- bstream.Read()

        while (bstream.Position < bstream.Count)
            let archetypeId = bstream.Read<ArchetypeId>()
            let mutable count = bstream.Read<int32>()
            let bufferCount = bstream.Read<int32>()
            
            let archetypedIndex = db.GetArchetypedIndex(archetypeId)
            let archetype = db.Archetypes[archetypedIndex]
            let buffers = archetype.Buffers
            let bufferLookup = archetype.BufferLookup

            let entIds = archetype.EntityIds
            bstream.Read(entIds.AsSpan(0, count): Span<EntityId>) // TODO: language bug, we should not need to annotate with 'Span<EntityId>'.

            let mutable i = 0
            while (i < bufferCount)
                let compId = bstream.Read<ComponentId>()
                let length = bstream.Read<int32>()

                let mutable bufferIndex = unchecked default
                if (archetype.BufferLookup.TryGetValue(compId, &bufferIndex))
                    let rawBuffer = buffers[bufferIndex].RawBuffer
                    bstream.Read(rawBuffer.AsSpan(0, length): Span<byte>) // TODO: language bug, we should not need to annotate with 'Span<byte>'.
                else
                   // bstream.Seek(bstream.Position + length)
                    fail("Unable to find component buffer. Was the component registered?")
                i <- i + 1

            archetype.Count <- count

            // Fix-ups
            let lookup = archetype.Lookup
            let entVersions = db.entityVersions 
            let entArchetypeIndices = db.entityArchetypeIndices
            let mutable i = 0
            while (i < count)
                let entId = entIds[i]
                let index = entId.Index
                entArchetypeIndices[index] <- archetypedIndex
                entVersions[index] <- entId.Version
                lookup[index] <- i
                i <- i + 1

    internal struct CreatedEntityInfo =
        public mutable field EntityId: EntityId = default
        public mutable field ArchetypeId: ArchetypeId = default

    internal struct DeletingEntityInfo =
        public mutable field EntityId: EntityId = default

    internal struct ArchetypeChangedEntityInfo =
        public mutable field EntityIndex: int32 = default
        public mutable field PreviousIndex: int32 = default
        public mutable field Index: int32 = default

    struct Events =
        internal field CreatedEntities: ConcurrentQueue<CreatedEntityInfo> = ConcurrentQueue()
        internal field DeletingEntities: ConcurrentQueue<DeletingEntityInfo> = ConcurrentQueue()
        internal field ArchetypeChangedEntities: ConcurrentQueue<ArchetypeChangedEntityInfo> = ConcurrentQueue()

    GetReplicatingEvents(prev: EntityDatabase): Events =
        let events = Events()
        // --
        let prevVersions = prev.entityVersions
        let versions = this.entityVersions

        For(EntityDatabase.MaxNumberOfEntities,
            i ->
                let prevVersion = prevVersions[i]
                let version = versions[i]

                let prevArchetypeId = prev.entityArchetypeIds[i]
                let archetypeId = this.entityArchetypeIds[i]

                if (prevVersion != version)
                    if (!prevArchetypeId.IsZero)
                        let mutable entId = EntityId()
                        entId.Index <- i
                        entId.Version <- prevVersion
                        let mutable info = DeletingEntityInfo()
                        info.EntityId <- entId
                        events.DeletingEntities.Enqueue(info)

                    if (!archetypeId.IsZero)
                        let mutable entId = EntityId()
                        entId.Index <- i
                        entId.Version <- version
                        let mutable info = CreatedEntityInfo()
                        info.EntityId <- entId
                        info.ArchetypeId <- archetypeId
                        events.CreatedEntities.Enqueue(info)

                else if (!prevArchetypeId.IsZero && !archetypeId.IsZero)
                    let prevArchetype = prev.Archetypes[prev.entityArchetypeIndices[i]]
                    let archetype = this.Archetypes[this.entityArchetypeIndices[i]]

                    let prevIndex = prevArchetype.Lookup[i]
                    let index = archetype.Lookup[i]
                    
                    if (prevIndex != index)
                        let mutable info = ArchetypeChangedEntityInfo()
                        info.EntityIndex <- i
                        info.PreviousIndex <- prevIndex
                        info.Index <- index
                        events.ArchetypeChangedEntities.Enqueue(info)
        )
        // --
        events

    Replicate(dst: EntityDatabase, prev: EntityDatabase, events: Events): () =
        let mutable result = unchecked default
        while (events.DeletingEntities.TryDequeue(&result))
            dst.entityDeleting.Trigger(result.EntityId)

        let mutable result = unchecked default
        while (events.ArchetypeChangedEntities.TryDequeue(&result))
            let entityIndex = result.EntityIndex
            let prevArchetype = prev.Archetypes[prev.entityArchetypeIndices[entityIndex]]
            let dstArchetype = dst.Archetypes[dst.entityArchetypeIndices[entityIndex]]
            let archetype = this.Archetypes[this.entityArchetypeIndices[entityIndex]]
            
            prevArchetype.CopyOneTo(result.PreviousIndex, dstArchetype, result.Index)

        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))
        Span(this.entityArchetypeIds).CopyTo(Span(dst.entityArchetypeIds))

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex

        let mutable i = 0
        while (i < this.Archetypes.Count)     
            let archetype = this.Archetypes[i]
            let mutable dstArchetypedIndex = unchecked default
            if (dst.ArchetypeLookup.TryGetValue(archetype.Id, &dstArchetypedIndex))
                archetype.CopyTo(dst.Archetypes[dstArchetypedIndex])
            i <- i + 1
            
        let mutable result = unchecked default
        while (events.CreatedEntities.TryDequeue(&result))
            let entId = result.EntityId
            let archetypeId = result.ArchetypeId
            dst.entityVersions[entId.Index] <- entId.Version
            dst.entityArchetypeIndices[entId.Index] <- dst.GetArchetypedIndex(archetypeId)
            dst.entityCreated.Trigger(entId)