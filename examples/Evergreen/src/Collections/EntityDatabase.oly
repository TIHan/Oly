namespace Evergreen.Collections

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

#[open]
private module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")

interface IComponent =

    static abstract GetBitFlag(): uint64

alias TypeId = System.Type
internal alias ArchetypeId = TypeId[]

internal class ComponentBuffer =

    public field Buffer: mutable byte[]
    TypeId: TypeId get
    TypeSize: int32 get

    new(buffer: mutable byte[], typeId: TypeId, typeSize: int32) =
        {          
            Buffer = buffer
            TypeId = typeId
            TypeSize = typeSize
        }

    CopyTo(dst: ComponentBuffer, lengthInBytes: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer).Buffer
        Span(this.Buffer, 0, lengthInBytes).CopyTo(Span(dstBuffer, 0, lengthInBytes))

    CopyOne(size: int32, srcIndex: int32, dst: ComponentBuffer, dstIndex: int32): () =
        Span(this.Buffer, srcIndex * size, size).CopyTo(Span(dst.Buffer, dstIndex * size, size))

internal class Archetype =
    
    Id: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: ComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    IsValid(entId: EntityId): bool =
        if (entId.IsNil) false
        else
            this.Lookup[entId.Index] != -1

    CopyTo(dst: Archetype): () =
        let count = this.Count

        dst.Count <- count
        
       // Span(this.Lookup).CopyTo(Span(dst.Lookup))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds))

        // fix-up lookup
        let entIds = dst.EntityIds
        let lookup = dst.Lookup
        let mutable i = 0
        while (i < count)
            lookup[entIds[i].Index] <- i
            i <- i + 1

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                fail("Unable to copy contents.")
            buffer.CopyTo(dst.Buffers[dstBufferIndex], count * buffer.TypeSize)
            i <- i + 1 

    CopyOne(srcIndex: int32, dst: Archetype, dstIndex: int32): () =
        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                fail("Unable to copy contents.")
            buffer.CopyOne(buffer.TypeSize, srcIndex, dst.Buffers[dstBufferIndex], dstIndex)
            i <- i + 1 
            
    GetRawComponentBuffer<T>(typedIndex: int32): Span<T> where T: unmanaged =
        MemoryMarshal.Cast<byte, T>(Span(this.Buffers[typedIndex].Buffer))

    GetComponentBuffer(typedIndex: int32): ComponentBuffer =
        this.Buffers[typedIndex]

    new(size: int32, buffers: ComponentBuffer[]) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        let archetypeId = Array.Initialize(buffers.Length, i -> buffers[i].TypeId)

        {
            Id = archetypeId
            Count = 0
            Capacity = size
            Lookup  = Array.InitializeMutable(size, i -> -1)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

internal interface IArchetypeReference =

    ArchetypedIndex: int32 get
    LastTypedIndex: int32 get

internal class ArchetypeReference<T0> where T0: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex0

    new(archetypedIndex: int32, typedIndex0: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
        }

internal class ArchetypeReference<T0, T1> where T0: unmanaged
                                 where T1: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex1

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
        }

internal class ArchetypeReference<T0, T1, T2> where T0: unmanaged
                                     where T1: unmanaged
                                     where T2: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex2

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
        }

internal class ArchetypeReference<T0, T1, T2, T3> where T0: unmanaged
                                         where T1: unmanaged
                                         where T2: unmanaged 
                                         where T3: unmanaged =
    implements IArchetypeReference

    ArchetypedIndex: int32 get
    TypedIndex0: int32 get
    TypedIndex1: int32 get
    TypedIndex2: int32 get
    TypedIndex3: int32 get
    LastTypedIndex: int32 get() = this.TypedIndex3

    new(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, typedIndex2: int32, typedIndex3: int32) =
        {
            ArchetypedIndex = archetypedIndex
            TypedIndex0 = typedIndex0
            TypedIndex1 = typedIndex1
            TypedIndex2 = typedIndex2
            TypedIndex3 = typedIndex3
        }

internal class EntityQuery<T0> where T0: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1> where T0: unmanaged
                          where T1: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()

internal class EntityQuery<T0, T1, T2, T3> where T0: unmanaged
                              where T1: unmanaged
                              where T2: unmanaged 
                              where T3: unmanaged =
    
    internal CountGroup  : List<Archetype> get = List()
    EntIdGroup  : List<mutable EntityId[]> get = List()
    BufferGroup0: List<ComponentBuffer> get       = List()
    BufferGroup1: List<ComponentBuffer> get       = List()
    BufferGroup2: List<ComponentBuffer> get       = List()
    BufferGroup3: List<ComponentBuffer> get       = List()

interface IEntityEvent<T> =

    Add(subscriber: T -> ()): ()

internal class EntityEvent<T> =
    implements IEntityEvent<T>

    field subscribers: List<T -> ()> = List()
    field lockObj: object = System.Object()

    Add(subscriber: T -> ()): () =
        this.subscribers.Add(subscriber)

    Trigger(eventData: T): () =
        let mutable i = 0
        while (i < this.subscribers.Count)
            let subscriber = this.subscribers[i]
            subscriber(eventData)
            i <- i + 1

class EntityDatabase =

    private class ArchetypeIdEqualityComparer =
        implements System.Collections.Generic.IEqualityComparer<ArchetypeId>
    
        GetHashCode(x: TypeId[]): int32 = x.Length
    
        Equals(x: TypeId[], y: TypeId[]): bool =
            let mutable isEqual = true
    
            let mutable i = 0
            while (i < x.Length && isEqual)
                let xx = x[i]
    
                let mutable isEqual2 = false
                let mutable j = 0
                while (j < y.Length && !isEqual2)
                    let yy = y[i]
                    isEqual2 <- xx.Equals(yy)
                    j <- j + 1
    
                isEqual <- isEqual2
    
                i <- i + 1
    
            isEqual

    public static field MaxNumberOfEntities: int32 = 65536

    class CommandBuffer =
        field cmds: List<EntityDatabase -> ()> = List()

        Spawn<T0>(value0: T0): () where T0: unmanaged =
            let cmd =
                (edb: EntityDatabase) ->
                    let archetypeRef = edb.RegisterArchetype<T0>()
                    let archetypedIndex = archetypeRef.ArchetypedIndex
                    let typedIndex0 = archetypeRef.TypedIndex0
            
                    let entId = edb.NewEntityId(archetypedIndex)
            
                    let archetype = edb.Archetypes[archetypedIndex]
                    let index = archetype.Count
                    archetype.Lookup[entId.Index] <- index
                    archetype.EntityIds[index] <- entId
            
                    (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
            
                    archetype.Count <- index + 1
            this.cmds.Add(cmd)

        AddComponent<T>(entId: EntityId): () where T: unmanaged =
            let cmd =
                (edb: EntityDatabase) ->
                    edb.Check(entId)

                    let srcArchetypedIndex = edb.entityArchetypeIndices[entId.Index]
                    let srcArchetype = edb.Archetypes[srcArchetypedIndex]

                    let dstArchetypeId = Array.Add(srcArchetype.Id, typeof<T>)
                    let dstArchetypedIndex = edb.GetArchetypedIndex(dstArchetypeId)
                    let dstArchetype = edb.Archetypes[dstArchetypedIndex]

                    srcArchetype.CopyTo(dstArchetype)

                    let remove = edb.ArchetypeRemovers[srcArchetypedIndex]
                    remove(srcArchetype.Lookup[entId.Index])

                    edb.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex
            this.cmds.Add(cmd)       

    internal field entityCreated: EntityEvent<EntityId> = EntityEvent()
    EntityCreated: IEntityEvent<EntityId> get() = this.entityCreated

    internal field entityDeleting: EntityEvent<EntityId> = EntityEvent()
    EntityDeleting: IEntityEvent<EntityId> get() = this.entityDeleting

    internal field entityDeleted: EntityEvent<EntityId> = EntityEvent()
    EntityDeleted: IEntityEvent<EntityId> get() = this.entityDeleted

    internal Archetypes: List<Archetype> get = List()
    internal ArchetypeRemovers: List<int32 -> ()> get = List()
    internal ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())
    internal DependencyLookup: Dictionary<TypeId, TypeId[]> get = Dictionary()

    private GetArchetypedIndex<T0>(): int32 where T0: unmanaged =
        let archetypeId = [typeof<T0>]
        this.GetArchetypedIndex(archetypeId)

    private GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged
                                                where T1: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>]
        this.GetArchetypedIndex(archetypeId)

    private GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged
                                                    where T1: unmanaged
                                                    where T2: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>;typeof<T2>]
        this.GetArchetypedIndex(archetypeId)

    internal GetArchetypedIndex(archetypeId: TypeId[]): int32 =
        let mutable result = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &result))
            result
        else
            let origArchetypeId = Array.DistinctBy(archetypeId, typeId -> typeId)

            let archetypeId =
                let deps = List<Type>()
                let mutable i = 0
                while (i < archetypeId.Length)
                    let mutable result = unchecked default
                    if (this.DependencyLookup.TryGetValue(archetypeId[i], &result))
                        deps.AddRange(Cast(result))
                    i <- i + 1
                Array.DistinctBy(Array.Add(archetypeId, Unsafe.AsImmutable(deps.ToArray())), typeId -> typeId)
                
            result <- this.Archetypes.Count

            let sizes =
                Array.Map(archetypeId, ty -> Marshal.SizeOf(ty))

            let buffers =
                Array.Map(archetypeId, ty -> ComponentBuffer(Array.ZeroCreate<byte>(EntityDatabase.MaxNumberOfEntities * Marshal.SizeOf(ty)), ty, Marshal.SizeOf(ty)))

            let archetype = Archetype(EntityDatabase.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]

                    let mutable i = 0
                    while (i < archetypeId.Length)
                        let buffer = buffers[i]
                        buffer.CopyOne(sizes[i], index, buffer, lastIndex)
                        i <- i + 1

                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[origArchetypeId] <- result
            result

    private GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[typeof<T>]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let archetypeId = Array.DistinctBy(archetypeId, ty -> ty)
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if (Array.ForAll(archetypeId, ty -> Array.Exists(archetype.Id, ty2 -> ty == ty2)))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    internal RegisterArchetype<T0>(): ArchetypeReference<T0> where T0: unmanaged =
        let archetypedIndex = this.GetArchetypedIndex<T0>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex))

    private RegisterArchetype<T0, T1>(): ArchetypeReference<T0, T1> where T0: unmanaged
                                                                    where T1: unmanaged =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex))

    private RegisterArchetype<T0, T1, T2>(): ArchetypeReference<T0, T1, T2> where T0: unmanaged
                                                                            where T1: unmanaged 
                                                                            where T2: unmanaged =
        let archetypedIndex = this.GetArchetypedIndex<T0, T1, T2>()
        ArchetypeReference(archetypedIndex, this.GetTypedIndex<T0>(archetypedIndex), this.GetTypedIndex<T1>(archetypedIndex), this.GetTypedIndex<T2>(archetypedIndex))
        
    private CreateQuery<T0>(): EntityQuery<T0> where T0: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>])

        let query = EntityQuery<T0>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T0>]))

            i <- i + 1

        query

    private CreateQuery<T0, T1>(): EntityQuery<T0, T1> where T0: unmanaged 
                                                       where T1: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>])

        let query = EntityQuery<T0, T1>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T0>]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T1>]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2>(): EntityQuery<T0, T1, T2> where T0: unmanaged 
                                                               where T1: unmanaged
                                                               where T2: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>])

        let query = EntityQuery<T0, T1, T2>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T0>]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T1>]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T2>]))

            i <- i + 1

        query

    private CreateQuery<T0, T1, T2, T3>(): EntityQuery<T0, T1, T2, T3> where T0: unmanaged 
                                                                       where T1: unmanaged
                                                                       where T2: unmanaged 
                                                                       where T3: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>;typeof<T3>])

        let query = EntityQuery<T0, T1, T2, T3>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            query.CountGroup.Add(archetype)
            query.EntIdGroup.Add(archetype.EntityIds)
            query.BufferGroup0.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T0>]))
            query.BufferGroup1.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T1>]))
            query.BufferGroup2.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T2>]))
            query.BufferGroup3.Add(archetype.GetComponentBuffer(archetype.BufferLookup[typeof<T3>]))

            i <- i + 1

        query

    RegisterDependency<T, TDependency>(): () where T: unmanaged
                                             where TDependency: unmanaged =
        this.DependencyLookup.Add(typeof<T>, [typeof<TDependency>])

    ForEach<T0>(f: (EntityId, byref<T0>) -> ()): () where T0: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>])

        let query = this.CreateQuery<T0>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged 
                                                                   where T1: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>])

        let query = this.CreateQuery<T0, T1>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j])
                j <- j + 1

            i <- i + 1
            
    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged 
                                                                                  where T1: unmanaged 
                                                                                  where T2: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>])

        let query = this.CreateQuery<T0, T1, T2>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))
            let mutable buffer2 = MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j])
                j <- j + 1

            i <- i + 1  

    ForEach<T0, T1, T2, T3>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>, byref<T3>) -> ()): () where T0: unmanaged 
                                                                                                 where T1: unmanaged 
                                                                                                 where T2: unmanaged 
                                                                                                 where T3: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>;typeof<T3>])

        let query = this.CreateQuery<T0, T1, T2, T3>()
        let countGroup   = query.CountGroup
        let entIdGroup   = query.EntIdGroup
        let bufferGroup0 = query.BufferGroup0
        let bufferGroup1 = query.BufferGroup1
        let bufferGroup2 = query.BufferGroup2
        let bufferGroup3 = query.BufferGroup3

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i].Count
            let entIds = entIdGroup[i]
            let mutable buffer0 = MemoryMarshal.Cast(Span(bufferGroup0[i].Buffer))
            let mutable buffer1 = MemoryMarshal.Cast(Span(bufferGroup1[i].Buffer))
            let mutable buffer2 = MemoryMarshal.Cast(Span(bufferGroup2[i].Buffer))
            let mutable buffer3 = MemoryMarshal.Cast(Span(bufferGroup3[i].Buffer))

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j], &buffer3[j])
                j <- j + 1

            i <- i + 1  
            
    Create<T0>(value0: T0): EntityId where T0: unmanaged =
        let archetypeRef = this.RegisterArchetype<T0>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1>(value0: T0, value1: T1): EntityId where T0: unmanaged
                                                     where T1: unmanaged =
        let archetypeRef = this.RegisterArchetype<T0, T1>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    Create<T0, T1, T2>(value0: T0, value1: T1, value2: T2): EntityId where T0: unmanaged
                                                                     where T1: unmanaged 
                                                                     where T2: unmanaged =                                                                
        let archetypeRef = this.RegisterArchetype<T0, T1, T2>()
        let archetypedIndex = archetypeRef.ArchetypedIndex
        let typedIndex0 = archetypeRef.TypedIndex0
        let typedIndex1 = archetypeRef.TypedIndex1
        let typedIndex2 = archetypeRef.TypedIndex2

        let entId = this.NewEntityId(archetypedIndex)

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        (archetype.GetRawComponentBuffer(typedIndex0)[index]) <- value0
        (archetype.GetRawComponentBuffer(typedIndex1)[index]) <- value1
        (archetype.GetRawComponentBuffer(typedIndex2)[index]) <- value2

        archetype.Count <- index + 1
        this.entityCreated.Trigger(entId)
        entId

    private AddComponentCore(entId: EntityId, typeId: TypeId): Archetype =
        this.Check(entId)

        let srcArchetypedIndex = this.entityArchetypeIndices[entId.Index]
        let srcArchetype = this.Archetypes[srcArchetypedIndex]
        let srcArchetypeId = srcArchetype.Id

        if (Array.Exists(srcArchetypeId, ty -> ty == typeId))
            srcArchetype
        else
            let dstArchetypeId = Array.Add(srcArchetypeId, typeId)
            let dstArchetypedIndex = this.GetArchetypedIndex(dstArchetypeId)
            let dstArchetype = this.Archetypes[dstArchetypedIndex]

            let srcIndex = srcArchetype.Lookup[entId.Index]
            let dstIndex = dstArchetype.Count
            srcArchetype.CopyOne(srcIndex, dstArchetype, dstIndex)
            dstArchetype.Lookup[entId.Index] <- dstIndex
            dstArchetype.EntityIds[dstIndex] <- entId
            dstArchetype.Count <- dstIndex + 1

            let remove = this.ArchetypeRemovers[srcArchetypedIndex]
            remove(srcArchetype.Lookup[entId.Index])

            this.entityArchetypeIndices[entId.Index] <- dstArchetypedIndex

            dstArchetype

    AddComponent<T>(entId: EntityId): byref<T> where T: unmanaged =
        let tyId: TypeId = typeof<T>
        let archetype = this.AddComponentCore(entId, tyId)
        let mutable buffer = archetype.GetRawComponentBuffer(archetype.BufferLookup[tyId])
        &buffer[archetype.Lookup[entId.Index]]

    HasComponent<T>(entId: EntityId): bool where T: unmanaged =
        let targetTy = typeof<T>
        let archetype = this.Archetypes[this.entityArchetypeIndices[entId.Index]]
        Array.Exists(archetype.Id, ty -> ty == targetTy)

    GetComponent<T>(entId: EntityId): byref<T> where T: unmanaged =
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let typedIndex = this.GetTypedIndex<T>(archetypedIndex)
        let archetype = this.Archetypes[archetypedIndex]
        let mutable result = archetype.GetRawComponentBuffer<T>(typedIndex)
        &result[archetype.Lookup[entId.Index]]

    Delete(entId: EntityId): () =
        this.Check(entId)
        this.entityDeleting.Trigger(entId)
        let archetypedIndex = this.entityArchetypeIndices[entId.Index]
        let archetype = this.Archetypes[archetypedIndex]
        let remove = this.ArchetypeRemovers[archetypedIndex]
        remove(archetype.Lookup[entId.Index])
        this.DeleteEntityId(entId)
        this.entityDeleted.Trigger(entId)

    // ----------------------------------------------

    internal mutable field nextIndex: int32 = 0
    internal mutable field indexQueue: Queue<int32> = Queue()
    internal mutable field entityCount: int32 = 0
    internal field entityArchetypeIndices: mutable int32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> -1)
    internal field entityVersions: mutable uint32[] = Array.InitializeMutable(EntityDatabase.MaxNumberOfEntities, i -> 0: uint32)

    internal NewEntityId(archetypedIndex: int32): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityArchetypeIndices[index] <- archetypedIndex
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    internal Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.entityArchetypeIndices[entId.Index] <- -1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != EntityDatabase.MaxNumberOfEntities

    EntityCount: int32 get() = this.entityCount

    Replicate(dst: EntityDatabase): () =
        if (this.Archetypes.Count != dst.Archetypes.Count)
            let mutable i = 0
            while (i < this.Archetypes.Count)
                let archetype = this.Archetypes[i]
                let _ = dst.GetArchetypedIndex(archetype.Id)
                i <- i + 1

        let createdEntities = Queue<EntityId>()
        let maxCount = Math.Max(this.EntityCount, dst.EntityCount)

        let mutable i = 0
        while (i < maxCount)
            let version = this.entityVersions[i]
            let archetypedIndex = this.entityArchetypeIndices[i]

            let dstVersion = dst.entityVersions[i]
            let dstArchetypedIndex = dst.entityArchetypeIndices[i]

            if (version != dstVersion)
                if (version != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- version
                    createdEntities.Enqueue(entId)

                if (dstVersion != 0)
                    let mutable entId = EntityId()
                    entId.Index <- i
                    entId.Version <- dstVersion
                    dst.entityDeleting.Trigger(entId)
                    
            i <- i + 1

        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex
        Span(this.entityArchetypeIndices).CopyTo(Span(dst.entityArchetypeIndices))
        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            archetype.CopyTo(dst.Archetypes[i])
            i <- i + 1
            
        let mutable entId = default
        while (createdEntities.TryDequeue(&entId))
            dst.entityCreated.Trigger(entId)