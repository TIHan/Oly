module Game.Core

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Collections
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct PointLight =
    public mutable field Position: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct DirectionalLight =
    public mutable field Direction: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct Camera =
    public mutable field Transform: Transform
    public mutable field Projection: mat4

    mutable field yaw: float32
    mutable field pitch: float32

    private static DefaultRotation: quat get = quat.CreateFromAxisAngle(vec3.UnitX, radians(0))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(mat4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = mat4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * quat.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, vec3.One)

struct Transform =
    public mutable field Matrix: mat4

    new(matrix: mat4) = { Matrix = matrix }

    Position: vec3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: quat
        get() = quat.CreateFromRotationMatrix(this.Matrix)

    Scale: vec3
        get() = 
            let mutable scale = vec3.Zero
            let mutable rotation = quat.Identity
            let mutable position = vec3.Zero
            if (mat4.Decompose(this.Matrix, &scale, &rotation, &position))
                scale
            else
                vec3.Zero

    Forward: vec3
        get() = vec3.Transform(vec3.Forward, this.Rotation)

    Back: vec3
        get() = vec3.Transform(vec3.Back, this.Rotation)

    Left: vec3
        get() = vec3.Transform(vec3.Left, this.Rotation)

    Right: vec3
        get() = vec3.Transform(vec3.Right, this.Rotation)

    WorldToLocalMatrix: mat4
        get() =
            let mutable inverted = mat4.Identity
            let didSucceed = mat4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: vec3, rotation: quat, scale: vec3): Transform =
        let rotationMatrix = mat4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = mat4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

alias Color = vec4

struct Material =
    Id: int32 get

    new(id: int32) =
        {
            Id = id
        }

newtype Box =
    internal field Value: EntityId

newtype Player =
    internal field Value: EntityId

enum PlayerActions =
    | Forward   = 0b0001
    | Backward  = 0b0010
    | Left      = 0b0100
    | Right     = 0b1000

struct PlayerActionSnapshot =

    public mutable field Actions: PlayerActions = default
    public mutable field Rotation: quat         = quat.Identity


// Tags

struct BoxTag
struct PlayerTag

// Component for regsitration

#[open]
extension CameraComponent =
    inherits Camera
    implements IComponent

    static overrides GetTypeId(): TypeId = 1
    static overrides GetSize(): int32 = sizeof<Camera>

#[open]
extension TransformComponent =
    inherits Transform
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 1
    static overrides GetSize(): int32 = sizeof<Transform>

#[open]
extension MaterialComponent =
    inherits Material
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 2
    static overrides GetSize(): int32 = sizeof<Material>

#[open]
extension PlayerActionSnapshotComponent =
    inherits PlayerActionSnapshot
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 3
    static overrides GetSize(): int32 = sizeof<PlayerActionSnapshot>

#[open]
extension PlayerTagComponent =
    inherits PlayerTag
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 4
    static overrides GetSize(): int32 = sizeof<PlayerTag>

#[open]
extension BoxTagComponent =
    inherits BoxTag
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 5
    static overrides GetSize(): int32 = sizeof<BoxTag>

#[open]
extension DynamicObjectIdComponent =
    inherits DynamicObjectId
    implements IComponent

    static overrides GetTypeId(): TypeId = 1 << 6
    static overrides GetSize(): int32 = sizeof<DynamicObjectId>
    
// ----------------------------------------------------------------------

abstract class World =

    new() =
        let db = EntityDatabase()

        db.EntityCreated.Add(
            entId -> this.OnEntitySpawned(entId)
        )

        db.EntityDeleting.Add(
            entId -> this.OnEntityDestroying(entId)
        )

        let stagingDb = EntityDatabase()

        {
            Database = db
            StagingDatabase = stagingDb
        }

    protected Database: EntityDatabase get
    protected StagingDatabase: EntityDatabase get

    IsValid(entId: EntityId): bool =
        this.Database.IsValid(entId)

    CanSpawnEntity: bool get() = this.Database.CanSpawnEntity

    Replicate(world: World): () =
        world.Database.CopyTo(world.StagingDatabase)
        this.Database.Replicate(world.Database, world.StagingDatabase)

    CopyTo(world: World): () =
        this.Database.CopyTo(world.Database)

    protected abstract default OnEntitySpawned(entId: EntityId): () = ()

    protected abstract default OnEntityDestroying(entId: EntityId): () = ()

abstract default class SharedWorld =
    inherits World

    protected field Physics: Physics = Physics.Init()

    abstract default Initialize(): () =
        let init(db: EntityDatabase): () =
            db.Register<Camera>()
            db.Register<Transform>()
            db.Register<Material>()
            db.Register<PlayerActionSnapshot>()
            db.Register<PlayerTag>()
            db.Register<BoxTag>()
        init(this.Database)
        init(this.StagingDatabase)

class ServerWorld =
    inherits SharedWorld

    field DestroyEntityQueue: ConcurrentQueue<EntityId>

    new() =
        {
            DestroyEntityQueue = ConcurrentQueue()
        }

    overrides Initialize(): () =
        base.Initialize()

        this.Database.Register<DynamicObjectId>()
        this.Database.RegisterDependency<BoxTag, DynamicObjectId>()

    private Flush(): () =
        let mutable entId = default
        while (this.DestroyEntityQueue.TryDequeue(&entId))
            this.Database.Delete(entId)

    Update(Δ: float32): () =
        this.Flush()

        this.Physics.Update(Δ)

        this.Database.ParallelForEach<Transform, DynamicObjectId>(
            (entId, transform, physObjId) ->
                let mutable position = vec3.Zero
                let mutable orientation = quat.Identity
                this.Physics.GetPositionAndOrientation(physObjId, &position, &orientation)
                transform <- Transform.Create(position, orientation, transform.Scale)
        )

    SpawnPlayer(position: vec3): () =
      //  let character = this.Physics.AddCharacter(position, quat.Identity, 0.5, 1, 1)
        let transform = Transform.Create(position, quat.Identity, vec3.One)
        let mutable camera = Camera(70, 1280, 720, 0.1, 1000000)
        camera.Transform.Position <- position

        let entId = this.Database.Create(PlayerTag(), transform, camera)
        
    DestroyPlayer(player: Player): () =
        this.DestroyEntityQueue.Enqueue(player.Value)

    ForEachPlayer(f: (Player, transform: byref<Transform>, camera: byref<Camera>) -> ()): () =
        this.Flush()

        this.Database.ForEach<PlayerTag, Transform, Camera>(
            (entId, tag, transform, camera) -> 
                f(Player(entId), &transform, &camera)
        )

        this.Flush()

    AddPlayerActionSnapshot(player: Player, actionSnapshot: PlayerActionSnapshot): () =
        this.Database.AddOrUpdate<PlayerActionSnapshot>(player.Value, actionSnapshot)

    SpawnBox(position: vec3, rotation: quat, scale: vec3): () =
        if (this.CanSpawnEntity)
            let transform = Transform.Create(position, rotation, scale)
            let material = Material(0)

            let entId = this.Database.Create(BoxTag(), transform, material)

    DestroyBox(box: Box): () =
        this.DestroyEntityQueue.Enqueue(box.Value)

    ForEachBox(f: (Box, transform: Transform, material: Material) -> ()): () =
        this.Flush()

        this.Database.ForEach<BoxTag, Transform, Material>(
            (entId, tag, transform, material) -> 
                f(Box(entId), transform, material)
        )

        this.Flush()

    protected overrides OnEntitySpawned(entId: EntityId): () =
        let _ =
            this.Database.TryGet<Transform, DynamicObjectId>(entId,
                (transform, physObjId) ->
                    physObjId <- this.Physics.AddBox(transform.Position, transform.Rotation, transform.Scale)
            )

    protected overrides OnEntityDestroying(entId: EntityId): () =
        let _ =
            this.Database.TryGet<DynamicObjectId>(entId,
                physObjId ->
                    this.Physics.RemoveBox(physObjId)
            )
