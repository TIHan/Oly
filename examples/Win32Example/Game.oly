module Game.Core

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct PointLight =
    public mutable field Position: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct DirectionalLight =
    public mutable field Direction: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct Camera =
    public mutable field Transform: Transform
    public mutable field Projection: mat4

    mutable field yaw: float32
    mutable field pitch: float32

    private static DefaultRotation: quat get = quat.CreateFromAxisAngle(vec3.UnitX, radians(0))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(mat4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = mat4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * quat.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, vec3.One)

struct Transform =
    public mutable field Matrix: mat4

    new(matrix: mat4) = { Matrix = matrix }

    Position: vec3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: quat
        get() = quat.CreateFromRotationMatrix(this.Matrix)

    Scale: vec3
        get() = 
            let mutable scale = vec3.Zero
            let mutable rotation = quat.Identity
            let mutable position = vec3.Zero
            if (mat4.Decompose(this.Matrix, &scale, &rotation, &position))
                scale
            else
                vec3.Zero

    Forward: vec3
        get() = vec3.Transform(vec3.Forward, this.Rotation)

    Back: vec3
        get() = vec3.Transform(vec3.Back, this.Rotation)

    Left: vec3
        get() = vec3.Transform(vec3.Left, this.Rotation)

    Right: vec3
        get() = vec3.Transform(vec3.Right, this.Rotation)

    WorldToLocalMatrix: mat4
        get() =
            let mutable inverted = mat4.Identity
            let didSucceed = mat4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: vec3, rotation: quat, scale: vec3): Transform =
        let rotationMatrix = mat4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = mat4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

interface IArchetype =

    Count: int32 get
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get

private GetArrayElementType(o: System.Object): System.Type =
    let ty = o.GetType()
    if (ty.IsArray)
        ty.GetElementType()
    else
        fail("Expected array.")


alias TypeId = System.Type

interface IComponentBuffer =

    TypeId: TypeId get
    CopyTo(dst: IComponentBuffer, length: int32): ()
    CopyOne(srcIndex: int32, dst: IComponentBuffer, dstIndex: int32): ()

class ComponentBuffer<T> where T: unmanaged =
    implements IComponentBuffer

    public field Buffer: mutable T[]
    TypeId: TypeId get

    new(buffer: mutable T[]) =
        {          
            Buffer = buffer
            TypeId = GetArrayElementType(buffer)
        }

    CopyTo(dst: IComponentBuffer, length: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer<T>).Buffer
        Span(this.Buffer, 0, length).CopyTo(Span(dstBuffer, 0, length))

    CopyOne(srcIndex: int32, dst: IComponentBuffer, dstIndex: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer<T>).Buffer
        dstBuffer[dstIndex] <- this.Buffer[srcIndex]

private class Archetype =
    implements IArchetype

    Id: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: IComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    CopyTo(dst: Archetype): () =
        dst.Count <- this.Count
        Span(this.Lookup, 0, this.Count).CopyTo(Span(dst.Lookup, 0, this.Count))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(dst.EntityIds, 0, this.Count))

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBuffer = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBuffer))
                fail("Unable to copy contents of '" + buffer.TypeId.Name.ToString() + "'.")
            i <- i + 1      

    new(size: int32, buffers: IComponentBuffer[]) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        let archetypeId = Array.Initialize(buffers.Length, i -> buffers[i].TypeId)

        {
            Id = archetypeId
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

private alias ArchetypeId = System.Type[]


private class ArchetypeIdEqualityComparer =
    implements System.Collections.Generic.IEqualityComparer<ArchetypeId>

    GetHashCode(x: System.Type[]): int32 = x.Length

    Equals(x: System.Type[], y: System.Type[]): bool =
        let mutable isEqual = true

        let mutable i = 0
        while (i < x.Length && isEqual)
            let xx = x[i]

            let mutable isEqual2 = false
            let mutable j = 0
            while (j < y.Length && !isEqual2)
                let yy = y[i]
                isEqual2 <- xx == yy
                j <- j + 1

            isEqual <- isEqual2

            i <- i + 1

        isEqual

class EntityDatabase =

    private Archetypes: List<Archetype> get = List()
    private ArchetypeRemovers: List<int32 -> ()> get = List()
    private ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())

    GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged
                                        where T1: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>]
        let mutable result = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &result))
            result
        else
            result <- this.Archetypes.Count

            let buffer0 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T0[]
            let buffer1 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T1[]
            let buffers =
                [
                    ComponentBuffer(buffer0): IComponentBuffer
                    ComponentBuffer(buffer1)
                ]
            let archetype = Archetype(World.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]
                    buffer0[index] <- buffer0[lastIndex]
                    buffer1[index] <- buffer1[lastIndex]
                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[archetypeId] <- result
            result

    GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged
                                            where T1: unmanaged
                                            where T2: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>;typeof<T2>]
        let mutable result = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &result))
            result
        else
            result <- this.Archetypes.Count

            let buffer0 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T0[]
            let buffer1 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T1[]
            let buffer2 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T2[]
            let buffers =
                [
                    ComponentBuffer(buffer0): IComponentBuffer
                    ComponentBuffer(buffer1)
                    ComponentBuffer(buffer2)
                ]
            let archetype = Archetype(World.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]
                    buffer0[index] <- buffer0[lastIndex]
                    buffer1[index] <- buffer1[lastIndex]
                    buffer2[index] <- buffer2[lastIndex]
                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[archetypeId] <- result
            result

    GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[typeof<T>]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if (Array.ForAll(archetypeId, ty -> Array.Exists(archetype.Id, ty2 -> ty == ty2)))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged where T1: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>])

        let countGroup   = List<int32>()
        let entIdGroup   = List<mutable EntityId[]>()
        let bufferGroup0 = List<ComponentBuffer<T0>>()
        let bufferGroup1 = List<ComponentBuffer<T1>>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            countGroup.Add(archetype.Count)
            entIdGroup.Add(archetype.EntityIds)
            bufferGroup0.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T0>]]))
            bufferGroup1.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T1>]]))

            i <- i + 1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Buffer
            let buffer1 = bufferGroup1[i].Buffer

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j])
                j <- j + 1

            i <- i + 1   

    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged where T1: unmanaged where T2: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>])

        let countGroup   = List<int32>()
        let entIdGroup   = List<mutable EntityId[]>()
        let bufferGroup0 = List<ComponentBuffer<T0>>()
        let bufferGroup1 = List<ComponentBuffer<T1>>()
        let bufferGroup2 = List<ComponentBuffer<T2>>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            countGroup.Add(archetype.Count)
            entIdGroup.Add(archetype.EntityIds)
            bufferGroup0.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T0>]]))
            bufferGroup1.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T1>]]))
            bufferGroup2.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T2>]]))

            i <- i + 1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Buffer
            let buffer1 = bufferGroup1[i].Buffer
            let buffer2 = bufferGroup2[i].Buffer

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j])
                j <- j + 1

            i <- i + 1   
        

    Spawn<T0, T1>(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, value0: T0, value1: T1): EntityId where T0: unmanaged
                                                                                                                    where T1: unmanaged =
        let entId = this.NewEntityId()

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        let buffer0 = (Unsafe.Cast(archetype.Buffers[typedIndex0]): ComponentBuffer<T0>).Buffer
        let buffer1 = (Unsafe.Cast(archetype.Buffers[typedIndex1]): ComponentBuffer<T1>).Buffer
        buffer0[index] <- value0
        buffer1[index] <- value1

        archetype.Count <- index + 1
        entId

    Add<T>(archedtypedIndex: int32, archedtypedTransferIndex: int32, typedTransferIndex: int32, entId: EntityId, value: T): () where T: unmanaged =
        let archetype = this.Archetypes[archedtypedIndex]
        let archetypeTransfer = this.Archetypes[archedtypedTransferIndex]

        archetype.CopyTo(archetypeTransfer)

        let index = archetypeTransfer.Count
        let buffer = (Unsafe.Cast(archetypeTransfer.Buffers[typedTransferIndex]): ComponentBuffer<T>).Buffer
        buffer[index] <- value
        archetypeTransfer.Count <- index + 1

        let remove = this.ArchetypeRemovers[archedtypedIndex]
        remove(archetype.Lookup[entId.Index])

    Destroy(archedtypedIndex: int32, entId: EntityId): () =
        let archetype = this.Archetypes[archedtypedIndex]
        let remove = this.ArchetypeRemovers[archedtypedIndex]
        remove(archetype.Lookup[entId.Index])
        this.DeleteEntityId(entId)

    // ----------------------------------------------

    mutable field nextIndex: int32 = 0
    mutable field indexQueue: Queue<int32> = Queue()
    mutable field entityCount: int32 = 0
    field entityVersions: mutable uint32[] = Array.InitializeMutable(World.MaxNumberOfEntities, i -> 0: uint32)

    private NewEntityId(): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    private Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.Check(entId)

        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != World.MaxNumberOfEntities

    private CopyTo(edb: EntityDatabase): () =
        edb.indexQueue.Clear()
        edb.entityCount <- this.entityCount
        edb.nextIndex <- this.nextIndex
        Span(this.entityVersions).CopyTo(Span(edb.entityVersions))

class Archetype<T0> where T0: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.Set(index, entId, item0)

    Set(index: int32, entId: EntityId, item0: T0): () =
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0

    Remove(index: int32): () =
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index

        this.Set(index, lastEntId, this.Buffer0[lastIndex])
        this.Count <- this.Count - 1
        if (this.Count < 0)
            fail("'Count' is less than zero.")

    Remove(entId: EntityId): () =
        this.Remove(this.Lookup[entId.Index])
    
    Get0(index: int32): T0 =
        this.Buffer0[index]

    Get0(entId: EntityId): T0 =
        this.Get0(this.Lookup[entId.Index])

    CopyTo(archetype: Archetype<T0>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))

class Archetype<T0, T1> where T0: unmanaged 
                        where T1: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
        }

    private Set(index: int32, entId: EntityId, item0: T0, item1: T1): () =
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1

    private SwapClear(index: int32): () =
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index

        this.Set(index, lastEntId, this.Buffer0[lastIndex], this.Buffer1[lastIndex])
    
    NextIndex(): int32 =
        this.Count

    Add(entId: EntityId, item0: T0, item1: T1): () =
        let index = this.NextIndex()

        this.Count <- this.Count + 1
        this.Lookup[entId.Index] <- index
        this.Set(index, entId, item0, item1)

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        this.SwapClear(index)
        this.Count <- this.Count - 1
        if (this.Count < 0)
            fail("'Count' is less than zero.")

    CopyTo(archetype: Archetype<T0, T1>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))


class Archetype<T0, T1, T2> where T0: unmanaged 
                            where T1: unmanaged 
                            where T2: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get
    Buffer2: mutable T2[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
            Buffer2 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0, item1: T1, item2: T2): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1
        this.Buffer2[index] <- item2

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index
        this.EntityIds[index] <- lastEntId
        this.Buffer0[index] <- this.Buffer0[lastIndex]
        this.Buffer1[index] <- this.Buffer1[lastIndex]
        this.Buffer2[index] <- this.Buffer2[lastIndex]

        this.Count <- this.Count - 1
        if (this.Count < 0)
            fail("'Count' is less than zero.")

    NextIndex(): int32 =
        this.Count

    Get0(entId: EntityId): T0 =
        this.Buffer0[this.Lookup[entId.Index]]

    Get1(entId: EntityId): T1 =
        this.Buffer1[this.Lookup[entId.Index]]

    Get2(entId: EntityId): T2 =
        this.Buffer2[this.Lookup[entId.Index]]

    CopyTo(archetype: Archetype<T0, T1, T2>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))
        Span(this.Buffer2, 0, this.Count).CopyTo(Span(archetype.Buffer2))

class Archetype<T0, T1, T2, T3> where T0: unmanaged 
                                where T1: unmanaged 
                                where T2: unmanaged 
                                where T3: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get
    Buffer2: mutable T2[] get
    Buffer3: mutable T3[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
            Buffer2 = Array.ZeroCreate(size)
            Buffer3 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0, item1: T1, item2: T2, item3: T3): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1
        this.Buffer2[index] <- item2
        this.Buffer3[index] <- item3

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.Lookup[lastEntId.Index] <- index
        this.EntityIds[index] <- lastEntId
        this.Buffer0[index] <- this.Buffer0[lastIndex]
        this.Buffer1[index] <- this.Buffer1[lastIndex]
        this.Buffer2[index] <- this.Buffer2[lastIndex]
        this.Buffer3[index] <- this.Buffer3[lastIndex]

        this.Count <- this.Count - 1
        if (this.Count < 0)
            fail("'Count' is less than zero.")

    CopyTo(archetype: Archetype<T0, T1, T2, T3>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))
        Span(this.Buffer2, 0, this.Count).CopyTo(Span(archetype.Buffer2))
        Span(this.Buffer3, 0, this.Count).CopyTo(Span(archetype.Buffer3))

alias Color = vec4

struct Material =
    Id: int32 get

    new(id: int32) =
        {
            Id = id
        }

newtype Box =
    internal field Value: EntityId

newtype Player =
    internal field Value: EntityId

enum PlayerActions =
    | Forward   = 0b0001
    | Backward  = 0b0010
    | Left      = 0b0100
    | Right     = 0b1000

struct PlayerActionSnapshot =

    public mutable field Actions: PlayerActions = default
    public mutable field Rotation: quat         = quat.Identity
    
// ----------------------------------------------------------------------

abstract class World =

    public static field MaxNumberOfEntities: int32 = 65536

    mutable field nextIndex: int32 = 0
    mutable field indexQueue: Queue<int32> = Queue()
    mutable field entityCount: int32 = 0
    field entityVersions: mutable uint32[] = Array.InitializeMutable(MaxNumberOfEntities, i -> 0: uint32)

    protected NewEntityId(): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    protected Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    protected DeleteEntityId(entId: EntityId): () =
        this.Check(entId)

        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != MaxNumberOfEntities

    protected CopyTo(world: World): () =
        world.indexQueue.Clear()
        world.entityCount <- this.entityCount
        world.nextIndex <- this.nextIndex
        Span(this.entityVersions).CopyTo(Span(world.entityVersions))

    

abstract default class SharedWorld =
    inherits World

    field Physics: Physics = Physics.Init()
    
    protected Shared_Player:    Archetype<Transform, Camera, PlayerActionSnapshot> get = Archetype(World.MaxNumberOfEntities)
    protected Shared_Box:       Archetype<Transform, Material> get = Archetype(World.MaxNumberOfEntities)
    protected Shared_StaticBox: Archetype<Transform, Material> get = Archetype(World.MaxNumberOfEntities)

    CopyTo(world: SharedWorld): () =
        let maxCount = Math.Max(this.Shared_Box.Count, world.Shared_Box.Count)

        // Shared_Player -------------------------------------------------------------------------
        let lookup = world.Shared_Box.Lookup
        let entIds = world.Shared_Player.EntityIds
        let buffer0 = world.Shared_Player.Buffer0
        let buffer1 = world.Shared_Player.Buffer1

        let entIdsToCopy = this.Shared_Player.EntityIds
        let buffer0ToCopy = this.Shared_Player.Buffer0
        let buffer1ToCopy = this.Shared_Player.Buffer1

        let mutable i = 0
        while (i < maxCount)
            let entId = entIds[i]
            let entIdToCopy = entIdsToCopy[i]

            if (entId.Index != entIdToCopy.Index || entId.Version != entIdToCopy.Version)
                if (!entId.IsNil && !this.IsValid(entId))
                    if (world.IsValid(entIdToCopy))
                        world.OnPlayerRemoving(i, lookup[entIdToCopy.Index])
                    else
                        world.OnPlayerRemoving(i, i)

                if (!entIdToCopy.IsNil && !world.IsValid(entIdToCopy))
                    world.OnPlayerAdding(i, entIdToCopy, buffer0ToCopy[i], buffer1ToCopy[i])
                
            i <- i + 1
        // ------------------------------------------------------------------------------------------

        // Shared_Box -------------------------------------------------------------------------
        let lookup = world.Shared_Box.Lookup
        let entIds = world.Shared_Box.EntityIds
        let buffer0 = world.Shared_Box.Buffer0
        let buffer1 = world.Shared_Box.Buffer1

        let entIdsToCopy = this.Shared_Box.EntityIds
        let buffer0ToCopy = this.Shared_Box.Buffer0
        let buffer1ToCopy = this.Shared_Box.Buffer1

        let mutable i = 0
        while (i < maxCount)
            let entId = entIds[i]
            let entIdToCopy = entIdsToCopy[i]

            if (entId.Index != entIdToCopy.Index || entId.Version != entIdToCopy.Version)
                if (!entId.IsNil && !this.IsValid(entId))
                    if (world.IsValid(entIdToCopy))
                        world.OnBoxRemoving(i, lookup[entIdToCopy.Index])
                    else
                        world.OnBoxRemoving(i, i)

                if (!entIdToCopy.IsNil && !world.IsValid(entIdToCopy))
                    world.OnBoxAdding(i, entIdToCopy, buffer0ToCopy[i], buffer1ToCopy[i])
                
            i <- i + 1
        // ------------------------------------------------------------------------------------------

        this.Shared_Player.CopyTo(world.Shared_Player)
        this.Shared_Box.CopyTo(world.Shared_Box)
        this.Shared_StaticBox.CopyTo(world.Shared_StaticBox)
        this.CopyTo(world: World)

    protected abstract default OnBoxAdding(index: int32, entId: EntityId, transform: Transform, material: Material): () = ()

    protected abstract default OnBoxRemoving(index: int32, swapIndex: int32): () = ()

    protected abstract default OnPlayerAdding(index: int32, entId: EntityId, transform: Transform, camera: Camera): () = ()

    protected abstract default OnPlayerRemoving(index: int32, swapIndex: int32): () = ()

class ServerWorld =
    inherits SharedWorld

    field Physics: Physics
    field DestroyPlayerQueue: ConcurrentQueue<Player>
    field DestroyBoxQueue: ConcurrentQueue<Box>

    private Server_Box: mutable DynamicObjectId[] get
    private Server_PlayerActionSnapshot: mutable PlayerActionSnapshot[] get

    new() =
        {
            Physics = Physics.Init()
            DestroyBoxQueue = ConcurrentQueue()
            DestroyPlayerQueue = ConcurrentQueue()
            Server_Box = Array.ZeroCreate(this.Shared_Box.Capacity)
            Server_PlayerActionSnapshot = Array.ZeroCreate(this.Shared_Player.Capacity)
        }

    private Flush(): () =
        let mutable box = default
        while (this.DestroyBoxQueue.TryDequeue(&box))
            let entId = box.Value
            this.Check(entId)

            let index = this.Shared_Box.Lookup[entId.Index]
            let lastIndex = this.Shared_Box.Count - 1
            this.OnBoxRemoving(index, lastIndex)
            this.Shared_Box.Remove(entId)
            this.DeleteEntityId(entId)

        let mutable player = default
        while (this.DestroyPlayerQueue.TryDequeue(&player))
            let entId = player.Value
            this.Check(entId)

            let index = this.Shared_Player.Lookup[entId.Index]
            let lastIndex = this.Shared_Player.Count - 1
            this.OnPlayerRemoving(index, lastIndex)
            this.Shared_Player.Remove(entId)
            this.DeleteEntityId(entId)

    Update(Δ: float32): () =
        this.Flush()

        this.Physics.Update(Δ)

        static let updatePhysicsBoxes(physics: Physics, physicsBoxCount: int32, physicsBoxTransforms: mutable Transform[], physicsBoxDynamicObjectIds: mutable DynamicObjectId[]) =
            let _ = 
                System.Threading.Tasks.Parallel.For(0, physicsBoxCount,
                    (i, x) ->
                        let mutable m = physicsBoxTransforms[i]
                        let mutable position = vec3.Zero
                        let mutable orientation = quat.Identity
                        physics.GetPositionAndOrientation(physicsBoxDynamicObjectIds[i], &position, &orientation)
                        let mutable scale = mat4.CreateScale(m.Scale)
                        let mutable m = mat4.CreateFromQuaternion(orientation)
                        scale.Translation <- position
                        physicsBoxTransforms[i] <- Transform(m * scale)
                )

        updatePhysicsBoxes(this.Physics, this.Shared_Box.Count, this.Shared_Box.Buffer0, this.Server_Box)

    SpawnPlayer(position: vec3): () =
        let transform = Transform.Create(position, quat.Identity, vec3.One)
        let camera = Camera(70, 1280, 720, 0.1, 1000000)

        let entId = this.NewEntityId()
        this.OnPlayerAdding(this.Shared_Player.NextIndex(), entId, transform, camera)
        this.Shared_Player.Add(entId, transform, camera, default)
        
    DestroyPlayer(player: Player): () =
        this.DestroyPlayerQueue.Enqueue(player)

    ForEachPlayer(f: (Player, transform: byref<Transform>, camera: byref<Camera>) -> ()): () =
        this.Flush()

        let count = this.Shared_Player.Count
        let entIds = this.Shared_Player.EntityIds

        let transforms = this.Shared_Player.Buffer0
        let cameras = this.Shared_Player.Buffer1

        let mutable i = 0
        while (i < count)
            f(Player(entIds[i]), &transforms[i], &cameras[i])
            i <- i + 1

        this.Flush()

    SpawnBox(position: vec3, rotation: quat, scale: vec3): () =
        if (this.CanSpawnEntity)
            let transform = Transform.Create(position, rotation, scale)
            let material = Material(0)

            let entId = this.NewEntityId()
            this.OnBoxAdding(this.Shared_Box.NextIndex(), entId, transform, material)
            this.Shared_Box.Add(entId, transform, material)

    DestroyBox(box: Box): () =
        this.DestroyBoxQueue.Enqueue(box)

    ForEachBox(f: (Box, transform: Transform, material: Material, DynamicObjectId) -> ()): () =
        this.Flush()

        let count = this.Shared_Box.Count
        let entIds = this.Shared_Box.EntityIds

        let transforms = this.Shared_Box.Buffer0
        let materials = this.Shared_Box.Buffer1
        let physIds = this.Server_Box

        let mutable i = 0
        while (i < count)
            f(Box(entIds[i]), transforms[i], materials[i], physIds[i])
            i <- i + 1

        this.Flush()

    protected overrides OnBoxAdding(index: int32, entId: EntityId, transform: Transform, material: Material): () =
        let objId = this.Physics.AddBox(transform.Position, transform.Rotation, transform.Scale)
        this.Server_Box[index] <- objId

    protected overrides OnBoxRemoving(index: int32, swapIndex: int32): () =
        this.Physics.RemoveBox(this.Server_Box[index])
        this.Server_Box[index] <- this.Server_Box[swapIndex]
