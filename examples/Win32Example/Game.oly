module Game.Core

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct PointLight =
    public mutable field Position: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct DirectionalLight =
    public mutable field Direction: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct Camera =
    public mutable field Transform: Transform
    public mutable field Projection: mat4

    mutable field yaw: float32
    mutable field pitch: float32

    private static DefaultRotation: quat get = quat.CreateFromAxisAngle(vec3.UnitX, radians(90))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(mat4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = mat4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * quat.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, vec3.One)

struct Transform =
    public mutable field Matrix: mat4

    new(matrix: mat4) = { Matrix = matrix }

    Position: vec3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: quat
        get() = quat.CreateFromRotationMatrix(this.Matrix)

    Scale: vec3
        get() = 
            let mutable scale = vec3.Zero
            let mutable rotation = quat.Identity
            let mutable position = vec3.Zero
            if (mat4.Decompose(this.Matrix, &scale, &rotation, &position))
                scale
            else
                vec3.Zero

    Forward: vec3
        get() = vec3.Transform(vec3.Forward, this.Rotation)

    Back: vec3
        get() = vec3.Transform(vec3.Back, this.Rotation)

    Left: vec3
        get() = vec3.Transform(vec3.Left, this.Rotation)

    Right: vec3
        get() = vec3.Transform(vec3.Right, this.Rotation)

    WorldToLocalMatrix: mat4
        get() =
            let mutable inverted = mat4.Identity
            let didSucceed = mat4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: vec3, rotation: quat, scale: vec3): Transform =
        let rotationMatrix = mat4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = mat4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

interface IArchetype =

    Count: int32 get
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get

class Archetype<T0> where T0: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.Set(index, entId, item0)

    Set(index: int32, entId: EntityId, item0: T0): () =
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0

    Remove(index: int32): () =
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index

        this.Set(index, lastEntId, this.Buffer0[lastIndex])
        this.Count <- this.Count - 1

    Remove(entId: EntityId): () =
        this.Remove(this.Lookup[entId.Index])
    
    Get0(index: int32): T0 =
        this.Buffer0[index]

    Get0(entId: EntityId): T0 =
        this.Get0(this.Lookup[entId.Index])

    CopyTo(archetype: Archetype<T0>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))

class Archetype<T0, T1> where T0: unmanaged 
                        where T1: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
        }

    private Set(index: int32, entId: EntityId, item0: T0, item1: T1): () =
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1

    private SwapClear(index: int32): () =
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index

        this.Set(index, lastEntId, this.Buffer0[lastIndex], this.Buffer1[lastIndex])
    
    NextIndex(): int32 =
        this.Count

    Add(entId: EntityId, item0: T0, item1: T1): () =
        let index = this.NextIndex()

        this.Count <- this.Count + 1
        this.Lookup[entId.Index] <- index
        this.Set(index, entId, item0, item1)

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        this.SwapClear(index)
        this.Count <- this.Count - 1

    CopyTo(archetype: Archetype<T0, T1>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))


class Archetype<T0, T1, T2> where T0: unmanaged 
                            where T1: unmanaged 
                            where T2: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get
    Buffer2: mutable T2[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
            Buffer2 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0, item1: T1, item2: T2): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1
        this.Buffer2[index] <- item2

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.EntityIds[lastIndex] <- EntityId()
        this.Lookup[lastEntId.Index] <- index
        this.EntityIds[index] <- lastEntId
        this.Buffer0[index] <- this.Buffer0[lastIndex]
        this.Buffer1[index] <- this.Buffer1[lastIndex]
        this.Buffer2[index] <- this.Buffer2[lastIndex]

        this.Count <- this.Count - 1

    Get0(entId: EntityId): T0 =
        this.Buffer0[this.Lookup[entId.Index]]

    Get1(entId: EntityId): T1 =
        this.Buffer1[this.Lookup[entId.Index]]

    Get2(entId: EntityId): T2 =
        this.Buffer2[this.Lookup[entId.Index]]

    CopyTo(archetype: Archetype<T0, T1, T2>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))
        Span(this.Buffer2, 0, this.Count).CopyTo(Span(archetype.Buffer2))

class Archetype<T0, T1, T2, T3> where T0: unmanaged 
                                where T1: unmanaged 
                                where T2: unmanaged 
                                where T3: unmanaged =
    implements IArchetype

    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffer0: mutable T0[] get
    Buffer1: mutable T1[] get
    Buffer2: mutable T2[] get
    Buffer3: mutable T3[] get

    new(size: int32) =
        {
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffer0 = Array.ZeroCreate(size)
            Buffer1 = Array.ZeroCreate(size)
            Buffer2 = Array.ZeroCreate(size)
            Buffer3 = Array.ZeroCreate(size)
        }

    Add(entId: EntityId, item0: T0, item1: T1, item2: T2, item3: T3): () =
        let index = this.Count
        this.Count <- this.Count + 1

        this.Lookup[entId.Index] <- index
        this.EntityIds[index] <- entId
        this.Buffer0[index] <- item0
        this.Buffer1[index] <- item1
        this.Buffer2[index] <- item2
        this.Buffer3[index] <- item3

    Remove(entId: EntityId): () =
        let index = this.Lookup[entId.Index]
        let lastIndex = this.Count - 1
        let lastEntId = this.EntityIds[lastIndex]
        
        this.Lookup[lastEntId.Index] <- index
        this.EntityIds[index] <- lastEntId
        this.Buffer0[index] <- this.Buffer0[lastIndex]
        this.Buffer1[index] <- this.Buffer1[lastIndex]
        this.Buffer2[index] <- this.Buffer2[lastIndex]
        this.Buffer3[index] <- this.Buffer3[lastIndex]

        this.Count <- this.Count - 1

    CopyTo(archetype: Archetype<T0, T1, T2, T3>): () =
        archetype.Count <- this.Count
        Span(this.Lookup).CopyTo(Span(archetype.Lookup))
        Span(this.EntityIds, 0, this.Count).CopyTo(Span(archetype.EntityIds))
        Span(this.Buffer0, 0, this.Count).CopyTo(Span(archetype.Buffer0))
        Span(this.Buffer1, 0, this.Count).CopyTo(Span(archetype.Buffer1))
        Span(this.Buffer2, 0, this.Count).CopyTo(Span(archetype.Buffer2))
        Span(this.Buffer3, 0, this.Count).CopyTo(Span(archetype.Buffer3))

alias Color = vec4

struct Material =
    Id: int32 get

    new(id: int32) =
        {
            Id = id
        }

newtype Box =
    internal field Value: EntityId

abstract class World =

    public static field MaxNumberOfEntities: int32 = 65536

    mutable field nextIndex: int32 = 0
    mutable field indexQueue: Queue<int32> = Queue()
    mutable field entityCount: int32 = 0
    field entityVersions: mutable uint32[] = Array.ZeroCreate<uint32>(MaxNumberOfEntities)

    protected NewEntityId(): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    protected Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    protected DeleteEntityId(entId: EntityId): () =
        this.Check(entId)

        this.entityVersions[entId.Index] <- 0
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    protected CopyTo(world: World): () =
        world.indexQueue.Clear()
        world.entityCount <- this.entityCount
        world.nextIndex <- this.nextIndex
        Span(this.entityVersions).CopyTo(Span(world.entityVersions))

abstract default class SharedWorld =
    inherits World

    field Physics: Physics = Physics.Init()
    
    protected Shared_Box:       Archetype<Transform, Material> get = Archetype(World.MaxNumberOfEntities)
    protected Shared_StaticBox: Archetype<Transform, Material> get = Archetype(World.MaxNumberOfEntities)

    CopyTo(world: SharedWorld): () =
        let maxCount = Math.Max(this.Shared_Box.Count, world.Shared_Box.Count)

        let entIds = world.Shared_Box.EntityIds
        let buffer0 = world.Shared_Box.Buffer0
        let buffer1 = world.Shared_Box.Buffer1

        let entIdsToCopy = this.Shared_Box.EntityIds
        let buffer0ToCopy = this.Shared_Box.Buffer0
        let buffer1ToCopy = this.Shared_Box.Buffer1

        let mutable i = 0
        while (i < maxCount)
            let entId = entIds[i]
            let entIdToCopy = entIds[i]

            if (entId.IsNil)
                world.OnBoxAdding(i, entIdToCopy, buffer0ToCopy[i], buffer1ToCopy[i])
            else if (entIdToCopy.IsNil)
                world.OnBoxRemoving(i)
            else if (entId.Index == entIdToCopy.Index && entId.Version != entIdToCopy.Version)
                world.OnBoxRemoving(i)
                world.OnBoxAdding(i, entIdToCopy, buffer0ToCopy[i], buffer1ToCopy[i])    
                
            i <- i + 1

        this.Shared_Box.CopyTo(world.Shared_Box)
        this.Shared_StaticBox.CopyTo(world.Shared_StaticBox)
        this.CopyTo(world: World)

    protected abstract default OnBoxAdding(index: int32, entId: EntityId, transform: Transform, material: Material): () = ()

    protected abstract default OnBoxRemoving(index: int32): () = ()

class ServerWorld =
    inherits SharedWorld

    field Physics: Physics
    field DestroyBoxStagingQueue: ConcurrentQueue<Box>
    field DestroyBoxQueue: Queue<Box>

    private Server_Box: mutable DynamicObjectId[] get

    new() =
        {
            Physics = Physics.Init()
            DestroyBoxStagingQueue = ConcurrentQueue()
            DestroyBoxQueue = Queue()
            Server_Box = Array.ZeroCreate(this.Shared_Box.Capacity)
        }

    private ProcessDestroyBoxQueue(): () =
        let mutable box = default
        while (this.DestroyBoxStagingQueue.TryDequeue(&box))
            let entId = box.Value
            this.Check(entId)

            let index = this.Shared_Box.Lookup[entId.Index]
            let lastIndex = this.Shared_Box.Count - 1
            this.OnBoxRemoving(index)
            this.OnBoxAdding(lastIndex, this.Shared_Box.EntityIds[lastIndex], this.Shared_Box.Buffer0[lastIndex], this.Shared_Box.Buffer1[lastIndex])
            this.Shared_Box.Remove(entId)
            this.DeleteEntityId(entId)

    Update(Δ: float32): () =
        this.ProcessDestroyBoxQueue()

        this.Physics.Update(Δ)

        static let updatePhysicsBoxes(physics: Physics, physicsBoxCount: int32, physicsBoxTransforms: mutable Transform[], physicsBoxDynamicObjectIds: mutable DynamicObjectId[]) =
            let mutable i = 0
            while (i < physicsBoxCount)
                let mutable m = physicsBoxTransforms[i]
                let mutable position = vec3.Zero
                let mutable orientation = quat.Identity
                physics.GetPositionAndOrientation(physicsBoxDynamicObjectIds[i], &position, &orientation)
                let mutable scale = mat4.CreateScale(m.Scale)
                let mutable m = mat4.CreateFromQuaternion(orientation)
                scale.Translation <- position
                physicsBoxTransforms[i] <- Transform(m * scale)
                i <- i + 1

        updatePhysicsBoxes(this.Physics, this.Shared_Box.Count, this.Shared_Box.Buffer0, this.Server_Box)

    CreateBox(position: vec3, rotation: quat, scale: vec3): Box =
        let transform = Transform.Create(position, rotation, scale)
        let material = Material(0)

        let entId = this.NewEntityId()
        this.OnBoxAdding(this.Shared_Box.NextIndex(), entId, transform, material)
        this.Shared_Box.Add(entId, transform, material)
        Box(entId)

    DestroyBox(box: Box): () =
        this.DestroyBoxStagingQueue.Enqueue(box)

    ForEachBox(f: (Box, transform: Transform, material: Material, DynamicObjectId) -> ()): () =
        this.ProcessDestroyBoxQueue()

        let count = this.Shared_Box.Count
        let entIds = this.Shared_Box.EntityIds

        let transforms = this.Shared_Box.Buffer0
        let materials = this.Shared_Box.Buffer1
        let physIds = this.Server_Box

        let mutable i = 0
        while (i < count)
            f(Box(entIds[i]), transforms[i], materials[i], physIds[i])
            i <- i + 1

        this.ProcessDestroyBoxQueue()

    protected overrides OnBoxAdding(index: int32, entId: EntityId, transform: Transform, material: Material): () =
        let objId = this.Physics.AddBox(transform.Position, transform.Rotation, transform.Scale)
        this.Server_Box[index] <- objId

    protected overrides OnBoxRemoving(index: int32): () =
        this.Physics.RemoveBox(this.Server_Box[index])
        this.Server_Box[index] <- unchecked default
