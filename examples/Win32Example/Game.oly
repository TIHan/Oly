module Game.Core

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Collections
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices

private alias Array = OlyPrelude.Array

struct PointLight =
    public mutable field Position: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct DirectionalLight =
    public mutable field Direction: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct Camera =
    public mutable field Transform: Transform
    public mutable field Projection: mat4

    mutable field yaw: float32
    mutable field pitch: float32

    private static DefaultRotation: quat get = quat.CreateFromAxisAngle(vec3.UnitX, radians(0))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(mat4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = mat4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * quat.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, vec3.One)

struct Transform =
    public mutable field Matrix: mat4

    new(matrix: mat4) = { Matrix = matrix }

    Position: vec3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: quat
        get() = quat.CreateFromRotationMatrix(this.Matrix)

    Scale: vec3
        get() = 
            let mutable scale = vec3.Zero
            let mutable rotation = quat.Identity
            let mutable position = vec3.Zero
            if (mat4.Decompose(this.Matrix, &scale, &rotation, &position))
                scale
            else
                vec3.Zero

    Forward: vec3
        get() = vec3.Transform(vec3.Forward, this.Rotation)

    Back: vec3
        get() = vec3.Transform(vec3.Back, this.Rotation)

    Left: vec3
        get() = vec3.Transform(vec3.Left, this.Rotation)

    Right: vec3
        get() = vec3.Transform(vec3.Right, this.Rotation)

    WorldToLocalMatrix: mat4
        get() =
            let mutable inverted = mat4.Identity
            let didSucceed = mat4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: vec3, rotation: quat, scale: vec3): Transform =
        let rotationMatrix = mat4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = mat4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

alias Color = vec4

struct Material =
    Id: int32 get

    new(id: int32) =
        {
            Id = id
        }

newtype Box =
    internal field Value: EntityId

newtype Player =
    internal field Value: EntityId

enum PlayerActions =
    | Forward   = 0b0001
    | Backward  = 0b0010
    | Left      = 0b0100
    | Right     = 0b1000

struct PlayerInput =

    public mutable field Actions: PlayerActions = default
    public mutable field Yaw: float32 = 0
    public mutable field Pitch: float32 = 0

struct Collidable

struct Velocity =
    public mutable field Linear: vec3 = vec3.Zero
    public mutable field Angular: vec3 = vec3.Zero

enum MeshKind =
    | Custom
    | Cube

struct Mesh =
    public mutable field Kind: MeshKind = MeshKind.Custom
    public mutable field Index: int32 = 0

struct PhysicsDynamic
struct PhysicsStatic

// Component for regsitration

#[open]
extension CameraComponent =
    inherits Camera
    implements IComponent

    static overrides GetName(): string = "camera"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(0)
    static overrides GetSize(): int32 = sizeof<Camera>

#[open]
extension TransformComponent =
    inherits Transform
    implements IComponent

    static overrides GetName(): string = "transform"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(1)
    static overrides GetSize(): int32 = sizeof<Transform>

#[open]
extension MaterialComponent =
    inherits Material
    implements IComponent

    static overrides GetName(): string = "material"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(2)
    static overrides GetSize(): int32 = sizeof<Material>

#[open]
extension PlayerInputComponent =
    inherits PlayerInput
    implements IComponent

    static overrides GetName(): string = "player-input"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(3)
    static overrides GetSize(): int32 = sizeof<PlayerInput>

#[open]
extension PhysicsDynamicComponent =
    inherits PhysicsDynamic
    implements IComponent

    static overrides GetName(): string = "physics-dynamic"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(4)
    static overrides GetSize(): int32 = sizeof<PhysicsDynamic>

#[open]
extension PhysicsStaticComponent =
    inherits PhysicsStatic
    implements IComponent

    static overrides GetName(): string = "physics-static"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(5)
    static overrides GetSize(): int32 = sizeof<PhysicsStatic>

#[open]
extension PhysicsDynamicIdComponent =
    inherits DynamicObjectId
    implements IComponent

    static overrides GetName(): string = "internal-physics-dynamic-id"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(511)
    static overrides GetSize(): int32 = sizeof<DynamicObjectId>

#[open]
extension PhysicsStaticIdComponent =
    inherits StaticObjectId
    implements IComponent

    static overrides GetName(): string = "internal-physics-static-id"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(510)
    static overrides GetSize(): int32 = sizeof<DynamicObjectId>

#[open]
extension CollidableComponent =
    inherits Collidable
    implements IComponent

    static overrides GetName(): string = "collidable"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(7)
    static overrides GetSize(): int32 = sizeof<Collidable>

#[open]
extension VelocityComponent =
    inherits Velocity
    implements IComponent

    static overrides GetName(): string = "velocity"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(8)
    static overrides GetSize(): int32 = sizeof<Velocity>

#[open]
extension MeshComponent =
    inherits Mesh
    implements IComponent

    static overrides GetName(): string = "mesh"
    static overrides GetId(): ComponentId = BitSet512.FromIndex(9)
    static overrides GetSize(): int32 = sizeof<Mesh>
    
// ----------------------------------------------------------------------

abstract default class World =

    new() =
        let db = EntityDatabase()

        db.EntityCreated.Add(
            entId -> this.OnEntitySpawned(entId)
        )

        db.EntityDeleting.Add(
            entId -> this.OnEntityDestroying(entId)
        )

        {
            Database = db
        }

    protected Database: EntityDatabase get

    IsValid(entId: EntityId): bool =
        this.Database.IsValid(entId)

    CanSpawnEntity: bool get() = this.Database.CanSpawnEntity

    Replicate(dstWorld: World, prevWorld: World, events: EntityDatabase.Events): () =
        this.Database.Replicate(dstWorld.Database, prevWorld.Database, events)

    CopyTo(dstWorld: World): () =
        this.Database.CopyTo(dstWorld.Database)

    protected abstract default OnEntitySpawned(entId: EntityId): () = ()

    protected abstract default OnEntityDestroying(entId: EntityId): () = ()

abstract default class SharedWorld =
    inherits World

    static SetupComponents(world: World): () =
        let db = world.Database

        db.Register<Camera>()
        db.Register<Transform>()
        db.Register<Material>()
        db.Register<PlayerInput>()
        db.Register<Mesh>()
        db.Register<PhysicsStatic>()

    protected field Physics: Physics = Physics.Init()

module WorldEvent =

    PlayerInputUpdated(entId: EntityId, playerInput: PlayerInput, bstream: ByteStream): () =
        bstream.Write<byte>(1)
        bstream.Write<EntityId>(entId)
        bstream.Write<PlayerInput>(playerInput)

    pattern PlayerInputUpdated(bstream: ByteStream): (entId: EntityId, playerInput: PlayerInput) when (bstream.Peek<byte>() == 1) =>
        bstream.Seek(bstream.Position + 1)
        (bstream.Read(), bstream.Read())

class ServerWorld =
    inherits SharedWorld

    static SetupComponents(world: World): () =
        SharedWorld.SetupComponents(world)

        let db = world.Database

        db.Register<PhysicsDynamic>()
        db.Register<StaticObjectId>()
        db.Register<DynamicObjectId>()
        db.Register<Velocity>()
        db.Register<Collidable>()

        db.RegisterAttachment<PhysicsDynamic, DynamicObjectId>()
        db.RegisterAttachment<PhysicsStatic, StaticObjectId>()

    field DestroyEntityQueue: ConcurrentQueue<EntityId>
    field EventStream: ByteStream

    new() =
        {
            DestroyEntityQueue = ConcurrentQueue()
            EventStream = ByteStream()
        }

    private Flush(): () =
        let mutable entId = default
        while (this.DestroyEntityQueue.TryDequeue(&entId))
            this.Database.Delete(entId)

    GetReplicatingEvents(prevWorld: World): EntityDatabase.Events =
        this.Database.GetReplicatingEvents(prevWorld.Database)

    Update(Δ: float32): () =
        this.Flush()

        let physics = this.Physics

        physics.Update(Δ)

        this.Database.ParallelForEach<Transform, Velocity, DynamicObjectId>(
            (entId, transform, velocity, physObjId) ->
                let mutable position = vec3.Zero
                let mutable orientation = quat.Identity
                physics.GetPositionAndOrientationAndVelocity(physObjId, &position, &orientation, &velocity.Linear, &velocity.Angular)
                transform <- Transform.Create(position, orientation, transform.Scale)
        )

    SpawnPlayer(position: vec3): () =
      //  let character = this.Physics.AddCharacter(position, quat.Identity, 0.5, 1, 1)
        let transform = Transform.Create(position, quat.Identity, vec3.One)
        let mutable camera = Camera(70, 1280, 720, 0.1, 1000000)
        camera.Transform.Position <- position

        let entId = this.Database.Create(PlayerInput(), transform, camera)
        
    DestroyPlayer(player: Player): () =
        this.DestroyEntityQueue.Enqueue(player.Value)

    ForEachPlayer(f: (Player, transform: byref<Transform>, camera: byref<Camera>) -> ()): () =
        this.Flush()

        this.Database.ForEach<PlayerInput, Transform, Camera>(
            (entId, playerInput, transform, camera) -> 
                f(Player(entId), &transform, &camera)
        )

        this.Flush()

    AddPlayerInput(player: Player, playerInput: PlayerInput): () =
        this.Database.AddOrUpdate<PlayerInput>(player.Value, playerInput)

    SpawnBox(position: vec3, rotation: quat, scale: vec3): () =
        if (this.CanSpawnEntity)
            let mutable mesh = Mesh()
            mesh.Kind <- MeshKind.Cube

            let transform = Transform.Create(position, rotation, scale)
            let material = Material(0)
            let physObjId = this.Physics.AddBox(transform.Position, transform.Rotation, transform.Scale)

            let entId = this.Database.Create(mesh, transform, material, physObjId, Velocity())

    DestroyBox(box: Box): () =
        this.DestroyEntityQueue.Enqueue(box.Value)

    ForEachBox(f: (Box, transform: Transform, material: Material) -> ()): () =
        this.Flush()

        this.Database.ForEach<Mesh, Transform, Material>(
            (entId, mesh, transform, material) -> 
                if (mesh.Kind == MeshKind.Cube)
                    f(Box(entId), transform, material)
        )

        this.Flush()

    protected overrides OnEntitySpawned(entId: EntityId): () =
        let _ =
            this.Database.TryGet<PhysicsDynamic, DynamicObjectId>(entId,
                (phys, physObjId) ->
                    ()
            )

    protected overrides OnEntityDestroying(entId: EntityId): () =
        let _ =
            this.Database.TryGet<DynamicObjectId>(entId,
                physObjId ->
                    this.Physics.RemoveBox(physObjId)
            )
