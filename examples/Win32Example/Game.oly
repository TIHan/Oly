module Game.Core

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices
open static Game.Database

private alias Array = OlyPrelude.Array

struct PointLight =
    public mutable field Position: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct DirectionalLight =
    public mutable field Direction: vec3 = vec3.Zero
    public field Padding: float32 = 0
    public mutable field Color: vec4 = vec4.Zero

struct Camera =
    public mutable field Transform: Transform
    public mutable field Projection: mat4

    mutable field yaw: float32
    mutable field pitch: float32

    private static DefaultRotation: quat get = quat.CreateFromAxisAngle(vec3.UnitX, radians(0))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(mat4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = mat4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * quat.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, vec3.One)

struct Transform =
    public mutable field Matrix: mat4

    new(matrix: mat4) = { Matrix = matrix }

    Position: vec3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: quat
        get() = quat.CreateFromRotationMatrix(this.Matrix)

    Scale: vec3
        get() = 
            let mutable scale = vec3.Zero
            let mutable rotation = quat.Identity
            let mutable position = vec3.Zero
            if (mat4.Decompose(this.Matrix, &scale, &rotation, &position))
                scale
            else
                vec3.Zero

    Forward: vec3
        get() = vec3.Transform(vec3.Forward, this.Rotation)

    Back: vec3
        get() = vec3.Transform(vec3.Back, this.Rotation)

    Left: vec3
        get() = vec3.Transform(vec3.Left, this.Rotation)

    Right: vec3
        get() = vec3.Transform(vec3.Right, this.Rotation)

    WorldToLocalMatrix: mat4
        get() =
            let mutable inverted = mat4.Identity
            let didSucceed = mat4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: vec3, rotation: quat, scale: vec3): Transform =
        let rotationMatrix = mat4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = mat4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

struct EntityId =
    public mutable field Index: int32 = 0
    public mutable field Version: uint32 = 0

    IsNil: bool get() = this.Version == 0

alias Color = vec4

struct Material =
    Id: int32 get

    new(id: int32) =
        {
            Id = id
        }

newtype Box =
    internal field Value: EntityId

newtype Player =
    internal field Value: EntityId

enum PlayerActions =
    | Forward   = 0b0001
    | Backward  = 0b0010
    | Left      = 0b0100
    | Right     = 0b1000

struct PlayerActionSnapshot =

    public mutable field Actions: PlayerActions = default
    public mutable field Rotation: quat         = quat.Identity


// Tags

struct BoxTag
struct PlayerTag
    
// ----------------------------------------------------------------------

abstract class World =

    new() =
        let db = EntityDatabase()

        db.EntityCreated.Add(
            entId -> this.OnEntitySpawned(entId)
        )

        db.EntityDeleting.Add(
            entId -> this.OnEntityDestroying(entId)
        )

        {
            Database = db
        }

    protected Database: EntityDatabase get

    IsValid(entId: EntityId): bool =
        this.Database.IsValid(entId)

    CanSpawnEntity: bool get() = this.Database.CanSpawnEntity

    CopyTo(world: World): () =
        this.Database.Replicate(world.Database) 

    protected abstract default OnEntitySpawned(entId: EntityId): () = ()

    protected abstract default OnEntityDestroying(entId: EntityId): () = ()

abstract default class SharedWorld =
    inherits World

    protected field Physics: Physics = Physics.Init()


class ServerWorld =
    inherits SharedWorld

    field DestroyEntityQueue: ConcurrentQueue<EntityId>

    private Server_Box: mutable DynamicObjectId[] get

    new() =
        let boxes = Array.ZeroCreate(EntityDatabase.MaxNumberOfEntities)

        {
            DestroyEntityQueue = ConcurrentQueue()
            Server_Box = boxes
        }

    private Flush(): () =
        let mutable entId = default
        while (this.DestroyEntityQueue.TryDequeue(&entId))
            this.Database.Delete(entId)

    Update(Δ: float32): () =
        this.Flush()

        this.Physics.Update(Δ)

        this.Database.ForEach<BoxTag, Transform>(
            (entId, tag, transform) ->
                let physObjId = this.Server_Box[entId.Index]
                let mutable position = vec3.Zero
                let mutable orientation = quat.Identity
                this.Physics.GetPositionAndOrientation(physObjId, &position, &orientation)
                let mutable scale = mat4.CreateScale(transform.Scale)
                let mutable m = mat4.CreateFromQuaternion(orientation)
                scale.Translation <- position
                transform <- Transform(m * scale)
        )

    SpawnPlayer(position: vec3): () =
      //  let character = this.Physics.AddCharacter(position, quat.Identity, 0.5, 1, 1)
        let transform = Transform.Create(position, quat.Identity, vec3.One)
        let mutable camera = Camera(70, 1280, 720, 0.1, 1000000)
        camera.Transform.Position <- position

        let entId = this.Database.Create(PlayerTag(), transform, camera)
        
    DestroyPlayer(player: Player): () =
        this.DestroyEntityQueue.Enqueue(player.Value)

    ForEachPlayer(f: (Player, transform: byref<Transform>, camera: byref<Camera>) -> ()): () =
        this.Flush()

        this.Database.ForEach<PlayerTag, Transform, Camera>(
            (entId, tag, transform, camera) -> 
                f(Player(entId), &transform, &camera)
        )

        this.Flush()

    SpawnBox(position: vec3, rotation: quat, scale: vec3): () =
        if (this.CanSpawnEntity)
            let transform = Transform.Create(position, rotation, scale)
            let material = Material(0)

            let entId = this.Database.Create(BoxTag(), transform, material)

    DestroyBox(box: Box): () =
        this.DestroyEntityQueue.Enqueue(box.Value)

    ForEachBox(f: (Box, transform: Transform, material: Material, DynamicObjectId) -> ()): () =
        this.Flush()

        this.Database.ForEach<BoxTag, Transform, Material>(
            (entId, tag, transform, material) -> 
                let physObjId = this.Server_Box[entId.Index]
                f(Box(entId), transform, material, physObjId)
        )

        this.Flush()

    protected overrides OnEntitySpawned(entId: EntityId): () =
        if (this.Database.HasComponent<BoxTag>(entId))
            let transform = this.Database.GetComponent<Transform>(entId)
            let objId = this.Physics.AddBox(transform.Position, transform.Rotation, transform.Scale)
            this.Server_Box[entId.Index] <- objId

    protected overrides OnEntityDestroying(entId: EntityId): () =
        if (this.Database.HasComponent<BoxTag>(entId))
            this.Physics.RemoveBox(this.Server_Box[entId.Index])
            this.Server_Box[entId.Index] <- default
