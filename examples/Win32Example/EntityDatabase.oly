module Game.Database

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open static Game.Core

private alias Array = OlyPrelude.Array

#[open]
module Helpers =

    GetArrayElementType(o: System.Object): System.Type =
        let ty = o.GetType()
        if (ty.IsArray)
            ty.GetElementType()
        else
            fail("Expected array.")


alias TypeId = System.Type

interface IComponentBuffer =

    TypeId: TypeId get
    CopyTo(dst: IComponentBuffer, length: int32): ()
    CopyOne(srcIndex: int32, dst: IComponentBuffer, dstIndex: int32): ()

class ComponentBuffer<T> where T: unmanaged =
    implements IComponentBuffer

    public field Buffer: mutable T[]
    TypeId: TypeId get

    new(buffer: mutable T[]) =
        {          
            Buffer = buffer
            TypeId = GetArrayElementType(buffer)
        }

    CopyTo(dst: IComponentBuffer, length: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer<T>).Buffer
        Span(this.Buffer, 0, length).CopyTo(Span(dstBuffer, 0, length))

    CopyOne(srcIndex: int32, dst: IComponentBuffer, dstIndex: int32): () =
        let dstBuffer = (Unsafe.Cast(dst): ComponentBuffer<T>).Buffer
        dstBuffer[dstIndex] <- this.Buffer[srcIndex]

private class Archetype =
    
    Id: ArchetypeId get
    Count: int32 get, set
    Capacity: int32 get
    Lookup: mutable int32[] get
    EntityIds: mutable EntityId[] get
    Buffers: IComponentBuffer[] get
    BufferLookup: ConcurrentDictionary<TypeId, int32> get

    CopyTo(dst: Archetype): () =
        let count = this.Count

        dst.Count <- count
        Span(this.Lookup, 0, count).CopyTo(Span(dst.Lookup, 0, count))
        Span(this.EntityIds, 0, count).CopyTo(Span(dst.EntityIds, 0, count))

        let mutable i = 0
        while (i < this.Buffers.Length)
            let buffer = this.Buffers[i]
            let mutable dstBufferIndex = unchecked default
            if (!dst.BufferLookup.TryGetValue(buffer.TypeId, &dstBufferIndex))
                fail("Unable to copy contents of '" + buffer.TypeId.Name.ToString() + "'.")
            buffer.CopyTo(dst.Buffers[dstBufferIndex], count)
            i <- i + 1      

    new(size: int32, buffers: IComponentBuffer[]) =
        let bufferLookup = ConcurrentDictionary()

        let mutable i = 0
        while (i < buffers.Length)
            let buffer = buffers[i]
            bufferLookup[buffer.TypeId] <- i 
            i <- i + 1

        let archetypeId = Array.Initialize(buffers.Length, i -> buffers[i].TypeId)

        {
            Id = archetypeId
            Count = 0
            Capacity = size
            Lookup  = Array.ZeroCreate(size)
            EntityIds = Array.ZeroCreate(size)
            Buffers = buffers
            BufferLookup = bufferLookup
        }

private alias ArchetypeId = System.Type[]

private class ArchetypeIdEqualityComparer =
    implements System.Collections.Generic.IEqualityComparer<ArchetypeId>

    GetHashCode(x: System.Type[]): int32 = x.Length

    Equals(x: System.Type[], y: System.Type[]): bool =
        let mutable isEqual = true

        let mutable i = 0
        while (i < x.Length && isEqual)
            let xx = x[i]

            let mutable isEqual2 = false
            let mutable j = 0
            while (j < y.Length && !isEqual2)
                let yy = y[i]
                isEqual2 <- xx == yy
                j <- j + 1

            isEqual <- isEqual2

            i <- i + 1

        isEqual

class EntityDatabase =

    private Archetypes: List<Archetype> get = List()
    private ArchetypeRemovers: List<int32 -> ()> get = List()
    private ArchetypeLookup: ConcurrentDictionary<ArchetypeId, int32> get = ConcurrentDictionary(ArchetypeIdEqualityComparer())

    GetArchetypedIndex<T0, T1>(): int32 where T0: unmanaged
                                        where T1: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>]
        let mutable result = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &result))
            result
        else
            result <- this.Archetypes.Count

            let buffer0 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T0[]
            let buffer1 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T1[]
            let buffers =
                [
                    ComponentBuffer(buffer0): IComponentBuffer
                    ComponentBuffer(buffer1)
                ]
            let archetype = Archetype(World.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]
                    buffer0[index] <- buffer0[lastIndex]
                    buffer1[index] <- buffer1[lastIndex]
                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[archetypeId] <- result
            result

    GetArchetypedIndex<T0, T1, T2>(): int32 where T0: unmanaged
                                            where T1: unmanaged
                                            where T2: unmanaged =
        let archetypeId = [typeof<T0>;typeof<T1>;typeof<T2>]
        let mutable result = default
        if (this.ArchetypeLookup.TryGetValue(archetypeId, &result))
            result
        else
            result <- this.Archetypes.Count

            let buffer0 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T0[]
            let buffer1 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T1[]
            let buffer2 = Array.ZeroCreate(World.MaxNumberOfEntities): mutable T2[]
            let buffers =
                [
                    ComponentBuffer(buffer0): IComponentBuffer
                    ComponentBuffer(buffer1)
                    ComponentBuffer(buffer2)
                ]
            let archetype = Archetype(World.MaxNumberOfEntities, buffers)

            this.Archetypes.Add(archetype)
            this.ArchetypeRemovers.Add(
                index ->
                    let lastIndex = archetype.Count - 1
                    let lastEntId = archetype.EntityIds[lastIndex]

                    archetype.Lookup[lastEntId.Index] <- index
                    archetype.EntityIds[index] <- archetype.EntityIds[lastIndex]
                    buffer0[index] <- buffer0[lastIndex]
                    buffer1[index] <- buffer1[lastIndex]
                    buffer2[index] <- buffer2[lastIndex]
                    archetype.Count <- lastIndex
            )

            this.ArchetypeLookup[archetypeId] <- result
            result

    GetTypedIndex<T>(archetypedIndex: int32): int32 where T: unmanaged =
        let archetype = this.Archetypes[archetypedIndex]
        archetype.BufferLookup[typeof<T>]

    private GetArchetypedIndices(archetypeId: ArchetypeId): int32[] =
        let indices = List<int32>()
        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]

            if (Array.ForAll(archetypeId, ty -> Array.Exists(archetype.Id, ty2 -> ty == ty2)))
                indices.Add(i)
            
            i <- i + 1

        Unsafe.AsImmutable(indices.ToArray())

    ForEach<T0, T1>(f: (EntityId, byref<T0>, byref<T1>) -> ()): () where T0: unmanaged 
                                                                   where T1: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>])

        let countGroup   = List<int32>()
        let entIdGroup   = List<mutable EntityId[]>()
        let bufferGroup0 = List<ComponentBuffer<T0>>()
        let bufferGroup1 = List<ComponentBuffer<T1>>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            countGroup.Add(archetype.Count)
            entIdGroup.Add(archetype.EntityIds)
            bufferGroup0.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T0>]]))
            bufferGroup1.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T1>]]))

            i <- i + 1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Buffer
            let buffer1 = bufferGroup1[i].Buffer

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j])
                j <- j + 1

            i <- i + 1   

    ForEach<T0, T1, T2>(f: (EntityId, byref<T0>, byref<T1>, byref<T2>) -> ()): () where T0: unmanaged 
                                                                                  where T1: unmanaged 
                                                                                  where T2: unmanaged =
        let indices = this.GetArchetypedIndices([typeof<T0>;typeof<T1>;typeof<T2>])

        let countGroup   = List<int32>()
        let entIdGroup   = List<mutable EntityId[]>()
        let bufferGroup0 = List<ComponentBuffer<T0>>()
        let bufferGroup1 = List<ComponentBuffer<T1>>()
        let bufferGroup2 = List<ComponentBuffer<T2>>()

        let mutable i = 0
        while (i < indices.Length)
            let index = indices[i]
            let archetype = this.Archetypes[index]
            
            countGroup.Add(archetype.Count)
            entIdGroup.Add(archetype.EntityIds)
            bufferGroup0.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T0>]]))
            bufferGroup1.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T1>]]))
            bufferGroup2.Add(Unsafe.Cast(archetype.Buffers[archetype.BufferLookup[typeof<T2>]]))

            i <- i + 1

        let mutable i = 0
        while (i < indices.Length)
            let count = countGroup[i]
            let entIds = entIdGroup[i]
            let buffer0 = bufferGroup0[i].Buffer
            let buffer1 = bufferGroup1[i].Buffer
            let buffer2 = bufferGroup2[i].Buffer

            let mutable j = 0
            while (j < count)
                f(entIds[j], &buffer0[j], &buffer1[j], &buffer2[j])
                j <- j + 1

            i <- i + 1   
        

    Spawn<T0, T1>(archetypedIndex: int32, typedIndex0: int32, typedIndex1: int32, value0: T0, value1: T1): EntityId where T0: unmanaged
                                                                                                                    where T1: unmanaged =
        let entId = this.NewEntityId()

        let archetype = this.Archetypes[archetypedIndex]
        let index = archetype.Count
        archetype.Lookup[entId.Index] <- index
        archetype.EntityIds[index] <- entId

        let buffer0 = (Unsafe.Cast(archetype.Buffers[typedIndex0]): ComponentBuffer<T0>).Buffer
        let buffer1 = (Unsafe.Cast(archetype.Buffers[typedIndex1]): ComponentBuffer<T1>).Buffer
        buffer0[index] <- value0
        buffer1[index] <- value1

        archetype.Count <- index + 1
        entId

    Add<T>(archedtypedIndex: int32, archedtypedTransferIndex: int32, typedTransferIndex: int32, entId: EntityId, value: T): () where T: unmanaged =
        let archetype = this.Archetypes[archedtypedIndex]
        let archetypeTransfer = this.Archetypes[archedtypedTransferIndex]

        archetype.CopyTo(archetypeTransfer)

        let index = archetypeTransfer.Count
        let buffer = (Unsafe.Cast(archetypeTransfer.Buffers[typedTransferIndex]): ComponentBuffer<T>).Buffer
        buffer[index] <- value
        archetypeTransfer.Count <- index + 1

        let remove = this.ArchetypeRemovers[archedtypedIndex]
        remove(archetype.Lookup[entId.Index])

    Destroy(archedtypedIndex: int32, entId: EntityId): () =
        let archetype = this.Archetypes[archedtypedIndex]
        let remove = this.ArchetypeRemovers[archedtypedIndex]
        remove(archetype.Lookup[entId.Index])
        this.DeleteEntityId(entId)

    // ----------------------------------------------

    mutable field nextIndex: int32 = 0
    mutable field indexQueue: Queue<int32> = Queue()
    mutable field entityCount: int32 = 0
    field entityVersions: mutable uint32[] = Array.InitializeMutable(World.MaxNumberOfEntities, i -> 0: uint32)

    private NewEntityId(): EntityId =
        let index =
            if (this.indexQueue.Count == 0)
                let index = this.nextIndex
                this.nextIndex <- this.nextIndex + 1
                index
            else
                this.indexQueue.Dequeue()

        let version = this.entityVersions[index] + 1
        this.entityVersions[index] <- version
        this.entityCount <- this.entityCount + 1

        let mutable entId = EntityId()
        entId.Index <- index
        entId.Version <- version
        entId

    private Check(entId: EntityId): () =
        if (!this.IsValid(entId))
            fail("Invalid entity.")

    private DeleteEntityId(entId: EntityId): () =
        this.Check(entId)

        this.entityVersions[entId.Index] <- this.entityVersions[entId.Index] + 1
        this.indexQueue.Enqueue(entId.Index)
        this.entityCount <- this.entityCount - 1

    IsValid(entId: EntityId): bool =
        let version = this.entityVersions[entId.Index]
        version != 0 && version == entId.Version

    CanSpawnEntity: bool get() = this.entityCount != World.MaxNumberOfEntities

    Replicate(dst: EntityDatabase): () =
        dst.indexQueue.Clear()
        dst.entityCount <- this.entityCount
        dst.nextIndex <- this.nextIndex
        Span(this.entityVersions).CopyTo(Span(dst.entityVersions))

        let mutable i = 0
        while (i < this.Archetypes.Count)
            let archetype = this.Archetypes[i]
            let mutable dstArchetypeIndex = -1
            if (!dst.ArchetypeLookup.TryGetValue(archetype.Id, &dstArchetypeIndex))
                fail("Unable to copy contents.")
            archetype.CopyTo(dst.Archetypes[dstArchetypeIndex])
            i <- i + 1      