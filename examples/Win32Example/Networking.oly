namespace Evergreen.Networking

open System

open LiteNetLib
open LiteNetLib.Layers
open LiteNetLib.Utils

internal class OnConnectionRequestDelegate =
    field f: ConnectionRequest -> ()
    new(f: ConnectionRequest -> ()) =
        {
            f = f
        }

    Invoke(request: ConnectionRequest): () =
        this.f(request)

internal class PeerConnectedDelegate =
    field f: NetPeer -> ()
    new(f: NetPeer -> ()) =
        {
            f = f
        }

    Invoke(peer: NetPeer): () =
        this.f(peer)

// module Helpers =

//     class Delegate<TArg0, TReturn> =
//         field f: TArg0 -> TReturn
//         new(f: TArg0 -> TReturn) = { f = f }

//         Invoke(arg0: TArg0): TReturn =
//             this.f(arg0)

//     CreateDelegate<T, TArg0, TReturn>(f: TArg0 -> TReturn): T where T: { new(object, nint); Invoke(TArg0): TReturn } =
//         let del = Delegate(f)
//         let result: T = Unsafe.Cast(T(del, nint(&&del.Invoke)))
//         result

// class Delegate<TArg0, TReturn> =
//     field f: TArg0 -> TReturn
//     new(f: TArg0 -> TReturn) = { f = f }

//     Invoke(arg0: TArg0): TReturn =
//         this.f(arg0)

// internal module Helpers =

//     CreateDelegate<T, TArg0, TReturn>(f: (object, nint) -> T): T where T: { Invoke(TArg0): TReturn } =
//         let x= 
        
internal class OnNetworkReceiveDelegate =
    field f: (NetPeer, NetPacketReader, channel: byte, DeliveryMethod) -> ()
    new(f: (NetPeer, NetPacketReader, channel: byte, DeliveryMethod) -> ()) =
        {
            f = f
        }

    Invoke(peer: NetPeer, packet: NetPacketReader, channel: byte, deliveryMethod: DeliveryMethod): () =
        this.f(peer, packet, channel, deliveryMethod)


newtype NetworkPeer =
    field value: NetPeer

class NetworkServer =

    field listener: EventBasedNetListener
    field server: NetManager

    private new(listener: EventBasedNetListener, server: NetManager) =
        {
            listener = listener
            server = server
        }

    static Create(): NetworkServer =
        let listener = EventBasedNetListener()
        let server = NetManager(listener, null)
        NetworkServer(listener, server)

    Start(mutable port: int32, connectionKey: string, onClientDataReceived: (NetworkPeer, ByteStream, channel: byte) -> ()): () =
        if (!this.server.Start(port))
            fail("Unable to start server at port: " + port.ToString())

        let onConnectionRequest = 
            OnConnectionRequestDelegate(
                (request: ConnectionRequest) ->
                    if (this.server.ConnectedPeersCount < 8)
                        let peer = request.AcceptIfKey(connectionKey)
                    else
                        request.Reject()
                        printLine(request.RemoteEndPoint.ToString() + " rejected")
            )
        let onConnectionRequest = EventBasedNetListener.OnConnectionRequest(onConnectionRequest, nint(&&onConnectionRequest.Invoke))
        this.listener.add_ConnectionRequestEvent(onConnectionRequest)

        let peerConnectedEvent =
            PeerConnectedDelegate(
                peer ->
                    printLine(peer.EndPoint.ToString() + " " + peer.ConnectionState.ToString())
            )
        let peerConnectedEvent = EventBasedNetListener.OnPeerConnected(peerConnectedEvent, nint(&&peerConnectedEvent.Invoke))
        this.listener.add_PeerConnectedEvent(peerConnectedEvent)

        let onNetworkReceive =
            OnNetworkReceiveDelegate(
                (peer, reader, channel, deliveryMethod) ->
                    let bstream = ByteStream(reader.RawData, reader.UserDataOffset, reader.RawDataSize)
                    onClientDataReceived(NetworkPeer(peer), bstream, channel)
                    reader.Recycle()
            )
        let onNetworkReceive = EventBasedNetListener.OnNetworkReceive(onNetworkReceive, nint(&&onNetworkReceive.Invoke))
        this.listener.add_NetworkReceiveEvent(onNetworkReceive)

    Send(buffer: mutable byte[], offset: int32, length: int32): () =
        this.server.SendToAll(buffer, offset, length, DeliveryMethod.ReliableOrdered)

    PollEvents(): () =
        this.server.PollEvents()

    Stop(): () =
        this.server.Stop()

class NetworkClient =

    field listener: EventBasedNetListener
    field client: NetManager

    mutable field currentConnection: NetPeer

    private new(listener: EventBasedNetListener, client: NetManager) =
        {
            listener = listener
            client = client
            currentConnection = null
        }

    static Create(): NetworkClient =
        let listener = EventBasedNetListener()
        let client = NetManager(listener, null)
        NetworkClient(listener, client)

    Start(onServerDataReceived: (ByteStream, channel: byte) -> ()): () =
        if (!this.client.Start())
            fail("Unable to start client.")

        let onNetworkReceive =
            OnNetworkReceiveDelegate(
                (peer, reader, channel, deliveryMethod) ->
                    let bstream = ByteStream(reader.RawData, reader.UserDataOffset, reader.RawDataSize)
                    onServerDataReceived(bstream, channel)
                    reader.Recycle()
            )
        let onNetworkReceive = EventBasedNetListener.OnNetworkReceive(onNetworkReceive, nint(&&onNetworkReceive.Invoke))
        this.listener.add_NetworkReceiveEvent(onNetworkReceive)

    Connect(ipOrHostName: string, port: int32, connectionKey: string): () =
        this.currentConnection <- this.client.Connect(ipOrHostName, port, connectionKey)

    PollEvents(): () =
        this.client.PollEvents()

    Disconnect(): () =
        this.client.DisconnectAll()

    Stop(): () =
        this.client.Stop()
        
        

    // EventBasedNetListener listener = new EventBasedNetListener();
    //     NetManager client = new NetManager(listener);
    //     client.Start();
    //     client.Connect("localhost" /* host ip or name */, 9050 /* port */, "SomeConnectionKey" /* text key or NetDataWriter */);
    //     listener.NetworkReceiveEvent += (fromPeer, dataReader, deliveryMethod, channel) =>
    //     {
    //         Console.WriteLine("We got: {0}", dataReader.GetString(100 /* max length of string */));
    //         dataReader.Recycle();
    //     };
        
    //     while (!Console.KeyAvailable)
    //     {
    //         client.PollEvents();
    //         Thread.Sleep(15);
    //     }
        
    //     client.Stop();

// EventBasedNetListener listener = new EventBasedNetListener();
//     NetManager server = new NetManager(listener);
//     server.Start(9050 /* port */);
    
//     listener.ConnectionRequestEvent += request =>
//     {
//         if(server.ConnectedPeersCount < 10 /* max connections */)
//             request.AcceptIfKey("SomeConnectionKey");
//         else
//             request.Reject();
//     };
    
//     listener.PeerConnectedEvent += peer =>
//     {
//         Console.WriteLine("We got connection: {0}", peer.EndPoint); // Show peer ip
//         NetDataWriter writer = new NetDataWriter();                 // Create writer class
//         writer.Put("Hello client!");                                // Put some string
//         peer.Send(writer, DeliveryMethod.ReliableOrdered);             // Send with reliability
//     };
    
//     while (!Console.KeyAvailable)
//     {
//         server.PollEvents();
//         Thread.Sleep(15);
//     }
//     server.Stop();