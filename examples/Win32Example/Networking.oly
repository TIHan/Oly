namespace Evergreen.Networking

open System
open System.IO
open System.Net
open System.Net.Sockets
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices

internal enum PacketKind =
    | Invalid

    | ConnectionRequested
    | ConnectionAcknowledged
    | ConnectionAccepted

    | Unreliable
    | UnreliableSequenced
    | Reliable
    | ReliableSequenced
    | ReliableOrdered

internal struct ConnectionPacketHeader =
    public mutable field Kind: PacketKind = PacketKind.Invalid
    
internal struct PacketHeader =
    public mutable field Kind: PacketKind = PacketKind.Invalid
    public mutable field SequenceId: uint32 = 0
    public mutable field FragmentIndex: int32 = 0
    public mutable field FragmentCount: int32 = 0
    public mutable field TotalDataSize: int32 = 0

internal class PacketManager =
    field maxDataSizeBeforeFragmentation: int32 = 1024
    field maxDataSizeBeforeFragmentationWithHeader: int32 = 1024 + sizeof<PacketHeader>
    
    mutable field nextSequenceId: uint32 = 1

    CreatePackets(packetKind: PacketKind, mutable largeData: ReadOnlyMemory<byte>): (mutable byte[])[] =
        let sequenceId = this.nextSequenceId
        this.nextSequenceId <- (this.nextSequenceId + 1) % uint32.MaxValue

        let largeDataLength = largeData.Length
        if (largeDataLength > this.maxDataSizeBeforeFragmentation)
            let chunkCount = (largeDataLength / this.maxDataSizeBeforeFragmentation) + 1
            OlyPrelude.Array.Initialize(chunkCount,
                i ->
                    let bytes = OlyPrelude.Array.ZeroCreate(this.maxDataSizeBeforeFragmentationWithHeader)
                    let headerSpan = Span(bytes).Slice(0, sizeof<PacketHeader>)
                    let dataSpan = Span(bytes).Slice(sizeof<PacketHeader>)

                    let mutable header = PacketHeader()
                    header.Kind <- packetKind
                    header.SequenceId <- sequenceId
                    header.FragmentIndex <- i
                    header.FragmentCount <- chunkCount
                    header.TotalDataSize <- largeDataLength

                    (MemoryMarshal.Cast(headerSpan)[0]) <- header

                    let mutable largeData = largeData.Span
                    if (i == (chunkCount - 1))
                        largeData.Slice(i * this.maxDataSizeBeforeFragmentation, largeData.Length - (i * this.maxDataSizeBeforeFragmentation)).CopyTo(dataSpan)
                    else
                        largeData.Slice(i * this.maxDataSizeBeforeFragmentation, this.maxDataSizeBeforeFragmentation).CopyTo(dataSpan)
                    bytes
            )
        else
            let bytes = OlyPrelude.Array.ZeroCreate(this.maxDataSizeBeforeFragmentationWithHeader)
            let headerSpan = Span(bytes).Slice(0, sizeof<PacketHeader>)
            let dataSpan = Span(bytes).Slice(sizeof<PacketHeader>)

            let mutable header = PacketHeader()
            header.Kind <- packetKind
            header.SequenceId <- sequenceId
            header.FragmentIndex <- 0
            header.FragmentCount <- 1
            header.TotalDataSize <- largeDataLength

            (MemoryMarshal.Cast(headerSpan)[0]) <- header

            let mutable largeData = largeData.Span
            largeData.CopyTo(dataSpan)

            [bytes]

internal class Defragmenter =
    field lookup: Dictionary<uint32, (HashSet<int32>, mutable byte[])> = Dictionary()
    HandlePacket(mutable packet: ReadOnlySpan<byte>, callback: (ByteStream, channel: byte) -> ()): () =
        let headerSpan = packet.Slice(0, sizeof<PacketHeader>)
        let mutable dataSpan = packet.Slice(sizeof<PacketHeader>)

        let mutable headerSpan: ReadOnlySpan<PacketHeader> = MemoryMarshal.Cast<_, PacketHeader>(headerSpan)
        let header = headerSpan[0]

        if (header.FragmentIndex < 0 || header.FragmentCount <= 0)
            ()
        else if (header.FragmentCount == 1)
            let callbackData = OlyPrelude.Array.ZeroCreate(dataSpan.Length)
            dataSpan.CopyTo(Span(callbackData))
            callback(ByteStream(callbackData, 0, header.TotalDataSize), 0)
        else    
            let mutable result = unchecked default
            if (!this.lookup.TryGetValue(header.SequenceId, &result))
                let reassembledData = OlyPrelude.Array.ZeroCreate<byte>(header.TotalDataSize)
                result <- (HashSet(), reassembledData)
                this.lookup[header.SequenceId] <- result

            let (hashSet, reassembledData) = result
            if (hashSet.Add(header.FragmentIndex))
                let mutable reassembledDataSpan = Span(reassembledData)
                let lastIndex = header.TotalDataSize / 1024
                if (header.FragmentIndex == lastIndex)
                    let position = lastIndex * 1024
                    let remaining = header.TotalDataSize - position
                    let mutable dst = reassembledDataSpan.Slice(position)
                    dataSpan.Slice(0, dst.Length).CopyTo(dst)
                else
                    dataSpan.CopyTo(reassembledDataSpan.Slice(header.FragmentIndex * 1024))

            if (hashSet.Count == header.FragmentCount)
                callback(ByteStream(reassembledData, 0, header.TotalDataSize), 0)
                let _ = this.lookup.Remove(header.SequenceId)
            else if (hashSet.Count > header.FragmentCount)
                let _ = this.lookup.Remove(header.SequenceId)
            
            
            // TODO
        

class NetworkServer =

    field receiveBuffer: mutable byte[]
    field socket: Socket
    field connections: ConcurrentDictionary<EndPoint, (float32, PacketManager)>
    mutable field onClientMessageReceived: (EndPoint, ByteStream, channel: byte) -> ()
    mutable field connectionKey: string 
    mutable field port: int32

    private new(socket: Socket) = 
        { 
            socket = socket
            connections = ConcurrentDictionary()
            receiveBuffer = GC.AllocateArray<byte>(51_200_000, true)
            onClientMessageReceived = (endPoint, bstream, channel) -> ()
            connectionKey = ""
            port = 0
        }

    static Create(): NetworkServer =
        let socket = Socket(SocketType.Dgram, ProtocolType.Udp)
        socket.Blocking <- false
        NetworkServer(socket)

    Start(mutable port: int32, connectionKey: string, onClientMessageReceived: (EndPoint, ByteStream, channel: byte) -> ()): () =
        let endPoint = IPEndPoint(IPAddress.Parse("127.0.0.1"), port)
        this.socket.Bind(endPoint)
        this.onClientMessageReceived <- onClientMessageReceived
        this.connectionKey <- connectionKey
        this.port <- port

    Send(buffer: mutable byte[], offset: int32, length: int32): () =
        printLine(length)
        ForEach(this.connections,
            (mutable pair) ->
                let (time, packetManager) = pair.Value
                if (time >= 0)
                    let endPoint = pair.Key
                    let packets = packetManager.CreatePackets(PacketKind.UnreliableSequenced, ReadOnlyMemory(buffer, offset, length))
                    let mutable i = 0
                    while (i < packets.Length)
                        let packet = packets[i]
                        let _ = this.socket.SendTo(ReadOnlySpan(packet, 0, packet.Length), SocketFlags.None, endPoint)
                        i <- i + 1
        )
        
    PollEvents(): () =
        while (this.socket.Available > 0)
            let mutable endPoint = IPEndPoint(IPAddress.Any, this.port): EndPoint
            let packetLength = this.socket.ReceiveFrom(this.receiveBuffer, 0, 1024, SocketFlags.None, &endPoint)
            
            let mutable heartbeat = unchecked default
            if (this.connections.TryGetValue(endPoint, &heartbeat))
                let (time, packetManager) = heartbeat
                if (time >= 0)
                    () // client message
                else
                    let msg = System.Text.Encoding.Default.GetString(this.receiveBuffer, 0, packetLength)
                    if (msg == "ACK")
                        this.connections[endPoint] <- ((0: float32), PacketManager())
                        printLine("connection accepted")
                        let bytes = System.Text.Encoding.Default.GetBytes("SUCCESS")
                        let _ = this.socket.SendTo(bytes, 0, bytes.Length, SocketFlags.None, endPoint)
                    else if (msg != this.connectionKey)
                        let _ = this.connections.TryRemove(endPoint, &heartbeat)
                        printLine("connection refused")
            else
                printLine("connection requested")
                let connectionKey = System.Text.Encoding.Default.GetString(this.receiveBuffer, 0, packetLength)
                if (connectionKey == this.connectionKey)
                    this.connections[endPoint] <- ((-1: float32), unchecked default)
                    let bytes = System.Text.Encoding.Default.GetBytes(this.connectionKey)
                    let _ = this.socket.SendTo(bytes, 0, bytes.Length, SocketFlags.None, endPoint)
                else
                    printLine("connection refused")
                
    Flush(): () = ()
        

class NetworkClient =

    field receiveBuffer: mutable byte[]
    field socket: Socket
    field defrag: Defragmenter
    mutable field onServerMessageReceived: (ByteStream, channel: byte) -> ()
    mutable field connectionKey: string 
    mutable field port: int32
    mutable field isConnected: bool

    private new(socket: Socket) = 
        { 
            socket = socket
            defrag = Defragmenter()
            receiveBuffer = GC.AllocateArray<byte>(51_200_000, true)
            onServerMessageReceived = (bstream, channel) -> ()
            connectionKey = ""
            port = 0
            isConnected = false
        }

    static Create(): NetworkClient =
        let socket = Socket(SocketType.Dgram, ProtocolType.Udp)
        socket.Blocking <- false
        socket.ReceiveBufferSize <- Int32.MaxValue
        NetworkClient(socket)

    private SendString(str: string): () =
        let endPoint = IPEndPoint(IPAddress.Parse("127.0.0.1"), this.port)
        let bytes = System.Text.Encoding.Default.GetBytes(str)
        let _ = this.socket.SendTo(bytes, 0, bytes.Length, SocketFlags.None, endPoint)

    Start(onServerMessageReceived: (ByteStream, channel: byte) -> ()): () =
        this.onServerMessageReceived <- onServerMessageReceived

    Connect(ipOrHostName: string, port: int32, connectionKey: string): () =
        let ipOrHostName =
            if (ipOrHostName == "localhost")
                "127.0.0.1"
            else
                ipOrHostName
        let endPoint = IPEndPoint(IPAddress.Parse(ipOrHostName), port)
        this.connectionKey <- connectionKey
        this.port <- port

        this.SendString(connectionKey)

    PollEvents(): () =
        while (this.socket.Available > 0)
            let mutable endPoint = IPEndPoint(IPAddress.Any, this.port): EndPoint
            let packetLength = this.socket.ReceiveFrom(this.receiveBuffer, 0, 1024 + sizeof<PacketHeader>, SocketFlags.None, &endPoint)
            
            if (this.isConnected)
                this.defrag.HandlePacket(ReadOnlySpan(this.receiveBuffer, 0, packetLength), this.onServerMessageReceived)
            else
                let connectionKey = System.Text.Encoding.Default.GetString(this.receiveBuffer, 0, packetLength)
                if (connectionKey == this.connectionKey)
                    this.SendString("ACK")
                else if (connectionKey == "SUCCESS")
                    printLine("connected to server")
                    this.isConnected <- true
    
    Flush(): () =
        ()

    Disconnect(): () =
        ()

    Stop(): () =
        ()
    
