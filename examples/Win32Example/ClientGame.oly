module ClientGame

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Collections
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices
open Evergreen.Graphics.Rendering
open static Game.Core

private alias Array = OlyPrelude.Array

newtype CameraLerp =
    public field Value: Camera

newtype TransformLerp =
    public field Value: Transform

// Components

#[open]
extension CameraLerpComponent =
    inherits CameraLerp
    implements IComponent

    static overrides GetName(): string = "camera-lerp"

    static overrides GetId(): ComponentId = BitSet512.FromIndex(47)

    static overrides GetSize(): int32 =
        sizeof<CameraLerp>

#[open]
extension TransformLerpComponent =
    inherits TransformLerp
    implements IComponent

    static overrides GetName(): string = "transform-lerp"

    static overrides GetId(): ComponentId = BitSet512.FromIndex(48)

    static overrides GetSize(): int32 = sizeof<TransformLerp>

class ClientWorld =
    inherits SharedWorld
    
    Render_Box: GpuMutableArray<mat4> get

    new(renderBox: GpuMutableArray<mat4>) =
        {
            Render_Box = renderBox
        }

    static SetupComponents(world: World): () =
        SharedWorld.SetupComponents(world)

        let db = world.Database

        db.Register<PlayerInput>()

        db.Register<CameraLerp>()
        db.RegisterAttachment<Camera, CameraLerp>()

        db.Register<TransformLerp>()
        db.RegisterAttachment<Transform, TransformLerp>()

    FixedUpdate(deltaTime: float32): () =
        this.Database.ForEach<TransformLerp, Transform>(
            (entId, transformLerp, transform) ->
                transformLerp <- TransformLerp(transform)
        )

        this.Database.ForEach<CameraLerp, Camera>(
            (entId, cameraLerp, camera) ->
                cameraLerp <- CameraLerp(camera)
        )

    LateFixedUpdate(deltaTime: float32): () =
        ()

    Update(deltaTime: float32): () =
        ()
    
    LateUpdate(deltaTime: float32, alpha: float32): () =
        let mutable boxRenders = this.Render_Box.AsMemory()
        let mutable boxCount = 0

        this.Database.ForEachSpan<Game.Core.Mesh, TransformLerp, Transform>(
            (mutable entIds, mutable meshes, mutable transformLerps, mutable transforms) ->
                let length = entIds.Length
                let mutable boxRenders = boxRenders.Span
                let mutable i = 0
                while (i < length)
                    let mesh = meshes[i]
                    if (mesh.Kind == MeshKind.Cube)
                        (boxRenders[boxCount + i]) <- mat4.Lerp(transformLerps[i].Value.Matrix, transforms[i].Matrix, alpha)
                    i <- i + 1
                boxCount <- boxCount + length
        )

        this.Render_Box.SyncOffset <- 0
        this.Render_Box.SyncLength <- boxCount

    ForEachPlayer(f: (Player, playerInput: byref<PlayerInput>, transformLerp: byref<Transform>, transform: byref<Transform>, cameraLerp: byref<Camera>, camera: byref<Camera>) -> ()): () =
        this.Database.ForEach<PlayerInput, TransformLerp, Transform, CameraLerp, Camera>(
            (entId, playerInput, transformLerp, transform, cameraLerp, camera) ->
                f(Player(entId), &playerInput, &Unsafe.AsByRef(&transformLerp), &transform, &Unsafe.AsByRef(&cameraLerp), &camera)
        )

    protected overrides OnEntitySpawned(mutable entId: EntityId): () =
        let _ =
            this.Database.TryGet<Transform, TransformLerp>(entId,
                (transform, transformLerp) ->
                    transformLerp <- TransformLerp(transform)
            )

        let _ =
            this.Database.TryGet<Camera, CameraLerp>(entId,
                (camera, cameraLerp) ->
                    cameraLerp <- CameraLerp(camera)
            )

    protected overrides OnEntityDestroying(entId: EntityId): () =
        ()
