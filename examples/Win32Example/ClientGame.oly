module ClientGame

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen.Collections
open Evergreen.Graphics
open Evergreen.Physics
open System.Runtime.InteropServices
open Evergreen.Graphics.Rendering
open static Game.Core

private alias Array = OlyPrelude.Array

newtype CameraLerp =
    public field Value: Camera
   // new(camera: Camera) = { Value = camera }

newtype TransformLerp =
    public field Value: Transform
  //  new(transform: Transform) = { Value = transform }

// Components

#[open]
extension CameraLerpComponent =
    inherits CameraLerp
    implements IComponent

    static overrides GetId(): ComponentId = BitSet512.FromIndex(47)

    static overrides GetSize(): int32 = sizeof<CameraLerp>

#[open]
extension TransformLerpComponent =
    inherits TransformLerp
    implements IComponent

    static overrides GetId(): ComponentId = BitSet512.FromIndex(48)

    static overrides GetSize(): int32 = sizeof<TransformLerp>

class ClientWorld =
    inherits SharedWorld
    
    Render_Box: GpuMutableArray<mat4> get

    new(renderBox: GpuMutableArray<mat4>) =
        {
            Render_Box = renderBox
        }

    static SetupComponents(world: World): () =
        SharedWorld.SetupComponents(world)

        let db = world.Database

        db.Register<CameraLerp>()
        db.RegisterDependency<Camera, CameraLerp>()

        db.Register<TransformLerp>()
        db.RegisterDependency<Transform, TransformLerp>()

    FixedUpdate(deltaTime: float32): () =
        this.Database.ForEach<TransformLerp, Transform>(
            (entId, transformLerp, transform) ->
                transformLerp <- TransformLerp(transform)
        )

        this.Database.ForEach<CameraLerp, Camera>(
            (entId, cameraLerp, camera) ->
                cameraLerp <- CameraLerp(camera)
        )

    LateFixedUpdate(deltaTime: float32): () =
        ()
    
    Update(alpha: float32): () =
        let mutable boxRenders = this.Render_Box.AsMemory()
        let mutable boxCount = 0

        this.Database.ForEachSpan<BoxTag, TransformLerp, Transform>(
            (mutable entIds, tags, mutable transformLerps, mutable transforms) ->
                let length = entIds.Length
                let mutable boxRenders = boxRenders.Span
                let mutable i = 0
                while (i < length)
                    (boxRenders[boxCount + i]) <- mat4.Lerp(transformLerps[i].Value.Matrix, transforms[i].Matrix, alpha)
                    i <- i + 1
                boxCount <- boxCount + length
        )

        this.Render_Box.SyncOffset <- 0
        this.Render_Box.SyncLength <- boxCount

    ForEachPlayer(f: (Player, transform: inref<Transform>, cameraLerp: byref<Camera>, camera: byref<Camera>) -> ()): () =
        this.Database.ForEach<PlayerTag, Transform, CameraLerp, Camera>(
            (entId, tag, transform, cameraLerp, camera) ->
                f(Player(entId), &transform, &Unsafe.AsByRef(&cameraLerp), &camera)
        )

    protected overrides OnEntitySpawned(mutable entId: EntityId): () =
        let _ =
            this.Database.TryGet<Transform, TransformLerp>(entId,
                (transform, transformLerp) ->
                    transformLerp <- TransformLerp(transform)
            )

        let _ =
            this.Database.TryGet<Camera, CameraLerp>(entId,
                (camera, cameraLerp) ->
                    cameraLerp <- CameraLerp(camera)
            )

    protected overrides OnEntityDestroying(entId: EntityId): () =
        ()
