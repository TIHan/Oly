#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.Graphics.Rendering
open Evergreen.Graphics.Rendering.UI

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias Array = OlyPrelude.Array

class ExternalProcess =
    implements IDisposable

    field p: Process

    new(filePath: string, args: string) =
        ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            field f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, nint(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, nint(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception("Failed process")

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

struct Vertex =
    public field Position: Vector3
    public field TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    public mutable field Model: Matrix4x4 = Matrix4x4.Identity
    public mutable field View: Matrix4x4 = Matrix4x4.Identity
    public mutable field Projection: Matrix4x4 = Matrix4x4.Identity

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

compileShaderByFile(path: string): ReadOnlyMemory<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlyMemory(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createImageByFile(path: string): GpuImage =
    let image = Image.Load<Rgba32>(File.ReadAllBytes(path))

    let mutable imageSpan = default
    if (!image.TryGetSinglePixelSpan(&imageSpan))
        fail("Invalid image.")

    let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
    let mutable bytesSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
    let mutable bytes = Array.ZeroCreate<byte>(bytesSpan.Length)
    bytesSpan.CopyTo(Span(bytes))
    image.Dispose()

    GpuImage(image.Width, image.Height, ReadOnlyMemory(bytes))

createUI(deviceName: string): WindowView =
    let window = WindowView()
    window.Title <- "Window"

    window.Children.Add(
        let view = LabelView()
        view.Label <- "Device"
        view.Text <- deviceName
        view
    )

    let image = ImageView()
    window.Children.Add(
        let view = image
        view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf068.png")
        view.Size <- Vector2(64, 64)
        view
    )

    let textInput = TextInputView()
    textInput.Label <- "Oly Input Text"
    textInput.OnTextChanged <- () -> printLine(textInput.Text)
    window.Children.Add(textInput)

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Toggle Input Text"
        view.OnClicked <- () -> textInput.IsEnabled <- !textInput.IsEnabled
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Add Image"
        view.OnClicked <- 
            () ->
                image.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf066.png")
                window.Children.Add(
                    let view = ImageView()
                    view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf067.png")
                    view.Size <- Vector2(64, 64)
                    view
                )
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Move"
        view.IsChecked <- window.CanMove
        view.OnChecked <- (x: bool) -> window.CanMove <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Resize"
        view.IsChecked <- window.CanResize
        view.OnChecked <- (x: bool) -> window.CanResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Auto-Resize"
        view.IsChecked <- window.CanAutoResize
        view.OnChecked <- (x: bool) -> window.CanAutoResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = ComboBoxView()
        view.Label <- "Combo Box"
        view.Items <- mutable ["Item1";"Item2";"Item3"]
        view.OnSelectedItemIndexChanged <- (x: int32, y: int32) -> ()
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Close Window"
        view.OnClicked <- () -> window.IsOpen <- false
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Close Window"
        view.OnClicked <- () -> window.IsOpen <- false
        view
    )

    window

main(): () =
    let options = RenderingOptions()
    let r = Rendering.Create(options)

    let image = createImageByFile("GameExample/Textures/flats/aqf068.png")
    r.Gpu.Sync(image)

    let uiNode = createUI(r.Gpu.DeviceName)
    let uiNode2 = createUI(r.Gpu.DeviceName)

    let globals =
        GpuMutableArray.Initialize(GpuArrayKind.Global, GpuMemoryKind.Shared, 1,
            i ->
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
        )

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices = 
        GpuMutableArray.Initialize(GpuArrayKind.Vertex, GpuMemoryKind.Local, quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )

    let indices =
        GpuMutableArray.Initialize(GpuArrayKind.Index, GpuMemoryKind.Local, quad.Indices.Length,
            i -> quad.Indices[i]
        )

    let gpuProgramUI = GpuProgramUI()
    r.Gpu.Sync(gpuProgramUI)

    let frame = GpuFrame()

    let gpuProgramUI2 = GpuProgramUI(frame)
    r.Gpu.Sync(gpuProgramUI2)

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuInputKind.Array, GpuStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuInputKind.ImageOrFrame, GpuStageFlags.Fragment)
    gpuProgram.SetVertexInput<Vertex>()
    gpuProgram.VertexCode <- vertexShaderByteCode
    gpuProgram.FragmentCode <- fragmentShaderByteCode

    let gpuProgramReference = GpuProgramReference(gpuProgram)
    gpuProgramReference.AddGlobalInput(globals)
    gpuProgramReference.AddGlobalInput(frame)
    let gpuProgramInstance1 = GpuProgramInstance(gpuProgramReference)

    let gpuProgramReference2 = GpuProgramReference(gpuProgram)
    gpuProgramReference2.AddGlobalInput(globals)
    gpuProgramReference2.AddGlobalInput(image)
    let gpuProgramInstance2 = GpuProgramInstance(gpuProgramReference2, frame)

    let gpuCommands =
        Array.Initialize(1000,
            i -> GpuCommand.DrawIndexed(gpuProgramInstance1, vertices, indices, quad.Indices.Length)
        )

    let gpuCommands = 
        Array.Add(
            [
                GpuCommand.NewFrame(frame)
                GpuCommand.DrawIndexed(gpuProgramInstance2, vertices, indices, quad.Indices.Length)
                GpuCommand.DrawUI(gpuProgramUI2, Unsafe.Cast([uiNode2]))
                GpuCommand.EndFrame()
            ],
            gpuCommands
        )
        
        
    let gpuCommands = Array.Add(gpuCommands, GpuCommand.DrawUI(gpuProgramUI, Unsafe.Cast([uiNode])))

    let mutable pos = Vector3(2, 2, 2)

    r.Window.Show()
    while (!r.Window.IsClosed)
        let inputSnapshot = r.Window.PumpEvents()

        // TODO

        let size = r.Window.Size
        if (!r.Window.IsClosed && !r.Window.IsHidden && size.X != 0 && size.Y != 0)
            let mutable result = globals.AsSpan()
            let mutable x = &result[0]
           // pos <- Vector3(2, 2, pos.Z + 0.01)

            x.View <- Matrix4x4.CreateLookAt(pos, Vector3(0, 0, 0), Vector3(0, 0, 1))
            gpuProgram.FragmentCode <- fragmentShaderByteCode
            r.Gpu.Execute(gpuCommands)

    r.Dispose()
