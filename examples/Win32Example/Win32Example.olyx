#target "dotnet: net7"

#load "*.oly"

#reference "../core/core.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"
#reference "../Evergreen/src/Physics/Evergreen.Physics.olyx"
#reference "../Evergreen/src/Collections/Evergreen.Collections.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Collections.Generic
open System.Runtime.InteropServices
open System.Threading.Tasks

open Evergreen
open Evergreen.Window
open Evergreen.Collections
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.Graphics.Rendering
open Evergreen.Graphics.Rendering.UI

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

open static Game.Core
open static ClientGame

private alias Array = OlyPrelude.Array

class ExternalProcess =
    implements IDisposable

    field p: Process

    new(filePath: string, args: string) =
        ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            field f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, nint(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, nint(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception(output)

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

struct Vertex =
    public field Position: Vector3
    public field TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    public mutable field Model: Matrix4x4 = Matrix4x4.Identity
    public mutable field View: Matrix4x4 = Matrix4x4.Identity
    public mutable field Projection: Matrix4x4 = Matrix4x4.Identity

compileShaderByFile(path: string): ReadOnlyMemory<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlyMemory(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createImageByFile(path: string): GpuImage =
    let image = Image.Load<Rgba32>(File.ReadAllBytes(path))

    let mutable imageSpan = default
    if (!image.TryGetSinglePixelSpan(&imageSpan))
        fail("Invalid image.")

    let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
    let mutable bytesSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
    let mutable bytes = Array.ZeroCreate<byte>(bytesSpan.Length)
    bytesSpan.CopyTo(Span(bytes))
    image.Dispose()

    GpuImage(image.Width, image.Height, ReadOnlyMemory(bytes))

createUI(deviceName: string, r: Rendering, frameTimesVM: FrameTimesViewModel): WindowView =
    let window = WindowView()
    window.Title <- "Window"

    window.Children.Add(
        let view = LabelView()
        view.Label <- "Device"
        view.Text <- deviceName
        view
    )

    let image = ImageView()
    window.Children.Add(
        let view = image
        view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf068.png")
        view.Size <- Vector2(64, 64)
        view
    )

    let textInput = TextInputView()
    textInput.Label <- "Oly Input Text"
    textInput.OnTextChanged <- (x: string, y: string) -> printLine(textInput.Text)
    window.Children.Add(textInput)

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Toggle Input Text"
        view.OnClicked <- () -> textInput.IsEnabled <- !textInput.IsEnabled
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Add Image"
        view.OnClicked <- 
            () ->
                image.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf066.png")
                window.Children.Add(
                    let view = ImageView()
                    view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf067.png")
                    view.Size <- Vector2(64, 64)
                    view
                )
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Move"
        view.IsChecked <- window.CanMove
        view.OnChecked <- (x: bool) -> window.CanMove <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Resize"
        view.IsChecked <- window.CanResize
        view.OnChecked <- (x: bool) -> window.CanResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Auto-Resize"
        view.IsChecked <- window.CanAutoResize
        view.OnChecked <- (x: bool) -> window.CanAutoResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Multi Threading Enabled"
        view.IsChecked <- frameTimesVM.MultiThreadingEnabled.Value
        view.OnChecked <- (x: bool) -> frameTimesVM.MultiThreadingEnabled.Value <- x
        view
    )

    window.Children.Add(
        let displayModes = r.Window.GetDisplayModes()
        let view = ComboBoxView()
        view.Label <- "Combo Box"
        view.Items <- Array.MapAsMutable(displayModes, x -> x.Width.ToString() + " x " + x.Height.ToString() + " | " + x.RefreshRate.ToString() + "hz")
        view.SelectedItemIndex <- Array.FindIndex(displayModes, (i, x) -> x.Equals(r.Window.CurrentDisplayMode))
        view.OnSelectedItemIndexChanged <- 
            (x: int32, y: int32) ->
                r.Window.ChangeDisplayMode(displayModes[y])
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Fullscreen"
        view.IsChecked <- r.Window.IsFullscreen
        view.OnChecked <- (x: bool) -> r.Window.IsFullscreen <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Close Window"
        view.OnClicked <- () -> window.IsOpen <- false
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Force GC"
        view.OnClicked <- () -> DotNet.GCCollect()
        view
    )

    window.Children.Add(
        let view = LinePlotView()
        view.Label <- "Frame Times"
        view.Values <- frameTimesVM.Values
        view.ScaleMax <- 33
        view.ScaleMin <- 0
        let _ = frameTimesVM.Offset.Subscribe(x -> view.Offset <- x)
      //  view.ScaleMax <- 20
        view.Size <- Vector2(0, 100)
        view
    )

    window.Children.Add(
        let view = LabelView()
        view.Label <- "Fixed Update Time"
        let _ = frameTimesVM.FixedUpdateTime.Subscribe((mutable x) -> view.Text <- x.ToString())
        view
    )

    window

class Subscription<T> =
    implements IDisposable

    private Unsubscribe: () -> () get

    new(unsubscribe: () -> ()) =
        {
            Unsubscribe = unsubscribe
        }

    Dispose(): () = this.Unsubscribe()

class Observable<T> =

    field subscribers: System.Collections.Concurrent.ConcurrentDictionary<T -> (), ()>
    mutable field value: T

    Subscribe(callback: T -> ()): Subscription<T> =
        let _ = this.subscribers[callback] <- ()
        Subscription(
            () -> 
                let mutable value = unchecked default
                let _ = this.subscribers.TryRemove(callback, &value)
        )

    Value: T
        get() = this.value
        set(value) =
            this.value <- value
            ForEach(this.subscribers, pair -> pair.Key(value))

    new(value: T) = { value = value; subscribers = System.Collections.Concurrent.ConcurrentDictionary() }

class FrameTimesViewModel =

    FixedUpdateTime: Observable<float64> get = Observable(0.0)
    Values: mutable float32[] get = Array.ZeroCreate(200)
    Offset: Observable<int32> get = Observable(0)
    MultiThreadingEnabled: Observable<bool> get = Observable(true)

test(): () =
    let edb = EntityDatabase()

    edb.Register<Camera>()
    edb.Register<Transform>()
    edb.Register<PlayerActionSnapshot>()

    edb.EntityCreated.Add(
        entId ->
            let result = edb.Has<Camera>(entId)
            let result = edb.Has<Transform>(entId)
            let result = edb.Has<Camera>(entId)
            let result = edb.Has<Transform>(entId)
    )

    let s = Stopwatch.StartNew()
    let mutable i = 0
    while (i < 65000)
        let entId = edb.Create(default: Transform, default: Camera)
        i <- i + 1
    s.Stop()
    printLine(s.Elapsed.TotalMilliseconds)

    let entId = edb.Create(default: Transform, default: Camera)
    let entId = edb.Create(default: Transform, default: Camera)

    let s = Stopwatch.StartNew()
    edb.ForEach<Transform, Camera>((mutable entId, transform, camera) -> ())
    edb.ForEach<Transform, Camera, PlayerActionSnapshot>((entId, transform, camera, playerActionSnapshot) -> printLine("failed"))

    edb.AddOrUpdate(entId, default: PlayerActionSnapshot)

    // let entIdsToDelete = List()
    // edb.ForEach<Transform, Camera>(
    //     (entId, transform, camera) ->
    //         entIdsToDelete.Add(entId)
    // )
   // ForEach(entIdsToDelete, entId -> edb.Delete(entId))
    edb.ForEach<Transform, Camera, PlayerActionSnapshot>((entId, transform, camera, playerActionSnapshot) -> ())

    let bstream = ByteStream()
    edb.Serialize(bstream)

    let stagingEdb = EntityDatabase()
    bstream.ResetPosition()
    EntityDatabase.DeserializeInto(bstream, stagingEdb)

    s.Stop()
    printLine(s.Elapsed.TotalMilliseconds)
    let s = Stopwatch.StartNew()
    bstream.ResetPosition()
    EntityDatabase.DeserializeInto(bstream, stagingEdb)
    s.Stop()
    printLine(s.Elapsed.TotalMilliseconds)

main(): () =
    let mutable i = 0
    while (i < 100)
        test()
        DotNet.GCCollect()
        i <- i + 1

    let options = RenderingOptions()
    let r = Rendering.Create(options)

    let deviceName = r.Gpu.DeviceName

    let image = createImageByFile("GameExample/Textures/flats/aqf068.png")
    r.Gpu.Sync(image)

    let frameTimesVM = FrameTimesViewModel()

    let uiNode = createUI(r.Gpu.DeviceName, r, frameTimesVM)
    let uiNode2 = createUI(r.Gpu.DeviceName, r, frameTimesVM)

    let globals =
        GpuMutableArray.Initialize(GpuArrayKind.Uniform, GpuMemoryKind.Shared, 1,
            i -> Globals()
        )

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices = 
        GpuMutableArray.Initialize(GpuArrayKind.Vertex, GpuMemoryKind.Local, quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )

    let indices =
        GpuMutableArray.Initialize(GpuArrayKind.Index, GpuMemoryKind.Local, quad.Indices.Length,
            i -> quad.Indices[i]
        )

    let gpuProgramUI = GpuProgramUI()
    r.Gpu.Sync(gpuProgramUI)

    let gpuFrame = GpuFrame()

    let gpuProgramUI2 = GpuProgramUI(gpuFrame)
    r.Gpu.Sync(gpuProgramUI2)

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuInputKind.UniformArray, GpuStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuInputKind.ImageOrFrame, GpuStageFlags.Fragment)
    gpuProgram.SetVertexInput<Vertex>()
    gpuProgram.VertexCode <- vertexShaderByteCode
    gpuProgram.FragmentCode <- fragmentShaderByteCode

    let gpuProgramReference = GpuProgramReference(gpuProgram)
    gpuProgramReference.AddGlobalInput(globals)
    gpuProgramReference.AddGlobalInput(gpuFrame)
    let gpuProgramInstance1 = GpuProgramInstance(gpuProgramReference)

    let gpuProgramReference2 = GpuProgramReference(gpuProgram)
    gpuProgramReference2.AddGlobalInput(globals)
    gpuProgramReference2.AddGlobalInput(image)
    let gpuProgramInstance2 = GpuProgramInstance(gpuProgramReference2, gpuFrame)

    let mutable vertexShaderByteCode2 = compileShaderByFile("Win32Example/default_instance.vert")
    let mutable fragmentShaderByteCode2 = compileShaderByFile("Win32Example/default_instance.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuInputKind.UniformArray, GpuStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuInputKind.ImageOrFrame, GpuStageFlags.Fragment)
    gpuProgram.AddGlobalInput(GpuInputKind.StorageArray, GpuStageFlags.Vertex)
    gpuProgram.SetVertexInput<Vertex>()
    gpuProgram.VertexCode <- vertexShaderByteCode2
    gpuProgram.FragmentCode <- fragmentShaderByteCode2

    let renderBox = GpuMutableArray.Initialize(GpuArrayKind.Storage, GpuMemoryKind.Local, EntityDatabase.MaxNumberOfEntities, i -> default: mat4)

    let world = ServerWorld()
    world.Initialize()
    let stagingWorld = SharedWorld()
    stagingWorld.Initialize()
    let clientWorld = ClientWorld(renderBox)
    clientWorld.Initialize()

    let gpuProgramReference3 = GpuProgramReference(gpuProgram)
    gpuProgramReference3.AddGlobalInput(globals)
    gpuProgramReference3.AddGlobalInput(image)
    gpuProgramReference3.AddGlobalInput(clientWorld.Render_Box)
    let gpuProgramInstance3 = GpuProgramInstance(gpuProgramReference3)

    let mutable pos = Vector3(2, 2, 2)

    r.Window.Show()

    let mutable m = Matrix4x4.Identity
    let mutable frame = 0
    let mutable canRender = false
    let mutable renderTime = 0: int64
    let mutable lastRenderTime = 0: int64

    let random = Random()

    let mutable cpuTime = Stopwatch.StartNew()

    world.SpawnPlayer(Vector3(0, 0, 5))

    let mutable is_w_pressed = false
    let mutable is_s_pressed = false
    let mutable is_a_pressed = false
    let mutable is_d_pressed = false
    let mutable currentCameraRotation = default

    let playerTick(deltaTime: float32, camera: byref<Camera>, rotation: quat) =
        let mutable acc = Vector3.Zero
            
        if (is_w_pressed)
            let v = camera.Transform.Forward
            acc <- Vector3(v.X, v.Y, v.Z)

        if (is_s_pressed)
            let v = camera.Transform.Back
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_a_pressed)
            let v = camera.Transform.Left
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_d_pressed)
            let v = camera.Transform.Right
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        acc <-
            if (acc != Vector3.Zero)
                Vector3.Normalize(acc) * (deltaTime * 5)
            else
                acc

        camera.Transform.Position <- camera.Transform.Position + acc
        camera.Transform <- Transform.Create(camera.Transform.Position, rotation, camera.Transform.Scale)

    let mutable cpuTimeValue = 0: float64
    let mutable spawnTime = 0: float32
    let serverTick(deltaTime: float32) =
        cpuTime.Restart()

        world.ForEachPlayer(
            (player, transform, camera) ->
                playerTick(deltaTime, &camera, currentCameraRotation)
        )

        spawnTime <- spawnTime + deltaTime

        if (spawnTime >= 1)
            spawnTime <- 0
            let mutable i = 0
            while (i < 4096)
                let position = Vector3(float32(i + 1) * 2, 0, 0)
                world.SpawnBox(position, quat.Identity, vec3.One)
                i <- i + 1

        world.ForEachBox(
            (box, transform, material) ->
                if (transform.Position.Z <= -10000)
                    world.DestroyBox(box)
        )

        world.Update(deltaTime)
        world.CopyTo(stagingWorld)
        cpuTimeValue <- cpuTime.Elapsed.TotalMilliseconds

    let sv = System.Threading.ManualResetEvent(false)
    let cl = System.Threading.ManualResetEvent(true)

    let Client_UpdatePlayerInput(deltaTime: float32): () =
        let inputSnapshot = r.Window.PumpEvents()

        let mutable yawAcc = 0: float32
        let mutable pitchAcc = 0: float32

        let mousePosition = inputSnapshot.MouseInfo.Delta
        let yawAcc = mousePosition.X * (float32(2) * deltaTime)
        let pitchAcc = mousePosition.Y * (-(float32(2)) * deltaTime)
        
        let mutable cameraRotation = Quaternion.Identity
        clientWorld.ForEachPlayer(
            (player, transform, cameraLerp, camera) ->
                cameraLerp.SetYawPitch(cameraLerp.Yaw + yawAcc, cameraLerp.Pitch + pitchAcc)
                cameraRotation <- cameraLerp.Transform.Rotation
        )

        ForEach(Cast(inputSnapshot.KeyEvents),
            (keyEvent: KeyEvent) ->
                if (keyEvent.Key == Key.W)
                    is_w_pressed <- keyEvent.IsDown

                if (keyEvent.Key == Key.S)
                    is_s_pressed <- keyEvent.IsDown

                if (keyEvent.Key == Key.A)
                    is_a_pressed <- keyEvent.IsDown

                if (keyEvent.Key == Key.D)
                    is_d_pressed <- keyEvent.IsDown                       
        )
        currentCameraRotation <- cameraRotation

    class ServerSimulation =
        field r: Rendering
        field frameTimesVM: FrameTimesViewModel
        field sv: System.Threading.ManualResetEvent
        field cl: System.Threading.ManualResetEvent
        field tick: float32 -> ()

        new(r: Rendering, frameTimesVM: FrameTimesViewModel, sv: System.Threading.ManualResetEvent, cl: System.Threading.ManualResetEvent, tick: float32 -> ()) =
            {
                r = r
                frameTimesVM = frameTimesVM
                sv = sv
                cl = cl
                tick = tick
            }

        Invoke(): () =
            while (!this.r.Window.IsClosed && this.frameTimesVM.MultiThreadingEnabled.Value) 
                let _ = this.sv.WaitOne()
                let _ = this.sv.Reset()
                this.tick(float32(GameLoop.FixedUpdateDeltaTimeInSeconds))
                let _ = this.cl.Set()
            let _ = this.cl.Set()

    let start = ServerSimulation(r, frameTimesVM, sv, cl, serverTick)

    let mutable task: System.Threading.Thread = null
    let gpuCommands = List<GpuCommand>()
    GameLoop.Start(
        frameTime -> 
            Client_UpdatePlayerInput(float32(frameTime)),
        () ->
            clientWorld.ForEachBox(
                (box, transformLerp, transform) ->
                    transformLerp <- transform
            )
            clientWorld.ForEachPlayer(
                (player, transform, cameraLerp, camera) ->
                    cameraLerp <- camera
            )
            if (frameTimesVM.MultiThreadingEnabled.Value)
                if (task === null)
                    let _ = sv.Reset()
                    let _ = cl.Set()
                    let threadStart = System.Threading.ThreadStart(start, nint(&&start.Invoke))
                    task <- System.Threading.Thread(threadStart)
                    task.Start()

                let _ = cl.WaitOne()
                let _ = cl.Reset()
                stagingWorld.Replicate(clientWorld)
                let _ = sv.Set()

                // prediction
                clientWorld.ForEachPlayer(
                    (player, transform, cameraLerp, camera) ->
                        // printLine("------")
                        // printLine(cameraLerp.Transform.Position)
                        // printLine(camera.Transform.Position)
                        playerTick(float32(GameLoop.FixedUpdateDeltaTimeInSeconds), &camera, currentCameraRotation)
                )
            else
                (
                    if (task !== null)
                        let _ = cl.WaitOne()
                        let _ = cl.Reset()
                        stagingWorld.Replicate(clientWorld)
                        let _ = sv.Set()
                        task.Join()
                        task <- null
                    else
                        serverTick(float32(GameLoop.FixedUpdateDeltaTimeInSeconds))
                        stagingWorld.Replicate(clientWorld)
                )

            frameTimesVM.FixedUpdateTime.Value <- cpuTimeValue

            r.Window.IsClosed,
        (mutable frameTime, alpha) ->
            
            let size = r.Window.Size
            if (!r.Window.IsClosed && !r.Window.IsHidden && size.X != 0 && size.Y != 0)
                renderTime <- renderTime + frameTime.Ticks

                let frameTimeMs = TimeSpan.FromTicks(renderTime - lastRenderTime).TotalMilliseconds
                frameTimesVM.Offset.Value <- frame % frameTimesVM.Values.Length
                frameTimesVM.Values[frame % frameTimesVM.Values.Length] <- float32(frameTimeMs)
                frame <- frame + 1

                gpuProgram.FragmentCode <- fragmentShaderByteCode
                
                clientWorld.ForEachPlayer(
                    (player, transform, cameraLerp, camera) ->
                        camera.SetYawPitch(cameraLerp.Yaw, cameraLerp.Pitch)

                        let view = Matrix4x4.Lerp(cameraLerp.Transform.WorldToLocalMatrix, camera.Transform.WorldToLocalMatrix, float32(alpha))

                        let mutable globals = globals.AsSpan()
                        let globals = &globals[0]
                        globals.Projection <- camera.Projection
                        globals.View <- view
                        globals.Model <- Matrix4x4.Identity
                )
                clientWorld.Update(float32(alpha))
                         
                gpuCommands.Add(GpuCommand.NewFrame(gpuFrame))
                gpuCommands.Add(GpuCommand.DrawIndexed(gpuProgramInstance2, vertices, indices, quad.Indices.Length, 1))
                gpuCommands.Add(GpuCommand.DrawUI(gpuProgramUI2, Cast([uiNode2])))
                gpuCommands.Add(GpuCommand.EndFrame())

                gpuCommands.Add(GpuCommand.DrawIndexed(gpuProgramInstance1, vertices, indices, quad.Indices.Length, 1))   
                gpuCommands.Add(GpuCommand.DrawIndexed(gpuProgramInstance3, vertices, indices, quad.Indices.Length, clientWorld.Render_Box.SyncLength))
                gpuCommands.Add(GpuCommand.DrawUI(gpuProgramUI, Cast([uiNode])))

                r.Gpu.Execute(gpuCommands)     

                gpuCommands.Clear()

                lastRenderTime <- renderTime
    )

    r.Dispose()
