#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.Game.Rendering
open Evergreen.UI
open Evergreen.Game

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias Array = OlyPrelude.Array

class ExternalProcess =
    implements IDisposable

    field p: Process

    new(filePath: string, args: string) =
        ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            field f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, nint(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, nint(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception("Failed process")

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

struct Vertex =
    public field Position: Vector3
    public field TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    public mutable field Model: Matrix4x4 = Matrix4x4.Identity
    public mutable field View: Matrix4x4 = Matrix4x4.Identity
    public mutable field Projection: Matrix4x4 = Matrix4x4.Identity

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

compileShaderByFile(path: string): ReadOnlyMemory<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlyMemory(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createUI(windowTitle: string, texture: GpuImage, deviceName: string): UINode =
    let windowModel = UI.WindowModel(windowTitle, Vector2.Zero, Vector2.Zero)
        
    let labelModel = UI.LabelModel("Device", deviceName)
    labelModel.IsEnabled <- false

    let imageModel = UI.ImageModel(texture, Vector2(256, 256))

    let textInputModel = UI.TextInputModel("Oly Input Text", "")
    let buttonModel = UI.ButtonModel("Oly Button")
    UI.Window(windowModel, 
        [
          //  UI.DemoWindow()
            UI.Label(labelModel)
            UI.Image(imageModel)
            UI.TextInput(textInputModel, m -> printLine(m.Text))
            UI.Button(buttonModel,
                _m ->
                    printLine("Clicked!")
                    textInputModel.Text <- textInputModel.Text + "doot"
            )
        ]
    )

main(): () =
    let options = RenderingOptions()
    let r = Rendering.Create(options)

    let image = GpuImage("GameExample/Textures/flats/aqf068.png")
    r.Gpu.Sync(image)

    let uiNode = createUI("Oly Window", image, r.Gpu.DeviceName)
    r.Gpu.Execute([])

    let globals =
        GpuMutableArray.Initialize(GpuArrayKind.Global, GpuMemoryKind.Shared, 1,
            i ->
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
        )

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices = 
        GpuMutableArray.Initialize(GpuArrayKind.Vertex, GpuMemoryKind.Local, quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )

    let indices =
        GpuMutableArray.Initialize(GpuArrayKind.Index, GpuMemoryKind.Local, quad.Indices.Length,
            i -> quad.Indices[i]
        )

    let gpuProgramUI = GpuProgramUI()
    r.Gpu.Sync(gpuProgramUI)

    let frame = GpuFrame()

    let gpuProgramUI2 = GpuProgramUI(frame)
    r.Gpu.Sync(gpuProgramUI2)

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuProgramInputKind.Array, GpuProgramStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuProgramInputKind.ImageOrFrame, GpuProgramStageFlags.Fragment)
    gpuProgram.SetVertexInput<Vertex>()
    gpuProgram.VertexCode <- vertexShaderByteCode
    gpuProgram.FragmentCode <- fragmentShaderByteCode

    let gpuProgramReference = GpuProgramReference(gpuProgram)
    gpuProgramReference.AddGlobalInput(globals)
    gpuProgramReference.AddGlobalInput(frame)
    let gpuProgramInstance1 = GpuProgramInstance(gpuProgramReference)

    let gpuProgramReference2 = GpuProgramReference(gpuProgram)
    gpuProgramReference2.AddGlobalInput(globals)
    gpuProgramReference2.AddGlobalInput(image)
    let gpuProgramInstance2 = GpuProgramInstance(gpuProgramReference2, frame)

    let gpuCommands =
        Array.Initialize(1000,
            i -> GpuCommand.DrawIndexed(gpuProgramInstance1, vertices, indices, quad.Indices.Length)
        )

    let gpuCommands = 
        Array.Add(
            [
                GpuCommand.NewFrame(frame)
                GpuCommand.DrawIndexed(gpuProgramInstance2, vertices, indices, quad.Indices.Length)
                GpuCommand.DrawUI(gpuProgramUI2, uiNode)
                GpuCommand.EndFrame()
            ],
            gpuCommands
        )
        
    let gpuCommands = Array.Add(gpuCommands, GpuCommand.DrawUI(gpuProgramUI, uiNode))

    let mutable pos = Vector3(2, 2, 2)

    r.Window.Show()
    while (!r.Window.IsClosed)
        let inputSnapshot = r.Window.PumpEvents()

        // TODO

        let size = r.Window.Size
        if (!r.Window.IsClosed && !r.Window.IsHidden && size.X != 0 && size.Y != 0)
            let mutable result = globals.AsSpan()
            let mutable x = &result[0]
          //  pos <- Vector3(2, 2, pos.Z + 0.01)

            x.View <- Matrix4x4.CreateLookAt(pos, Vector3(0, 0, 0), Vector3(0, 0, 1))
            gpuProgram.FragmentCode <- fragmentShaderByteCode
            r.Gpu.Execute(gpuCommands)

    r.Dispose()
