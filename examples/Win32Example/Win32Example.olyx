#target "dotnet: net7"

#load "*.oly"

#reference "../core/core.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"
#reference "../Evergreen/src/Physics/Evergreen.Physics.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.Graphics.Rendering
open Evergreen.Graphics.Rendering.UI

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

open static Game.Core

private alias Array = OlyPrelude.Array

class ExternalProcess =
    implements IDisposable

    field p: Process

    new(filePath: string, args: string) =
        ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            field f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, nint(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, nint(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception("Failed process")

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

struct Vertex =
    public field Position: Vector3
    public field TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    public mutable field Model: Matrix4x4 = Matrix4x4.Identity
    public mutable field View: Matrix4x4 = Matrix4x4.Identity
    public mutable field Projection: Matrix4x4 = Matrix4x4.Identity

compileShaderByFile(path: string): ReadOnlyMemory<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlyMemory(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createImageByFile(path: string): GpuImage =
    let image = Image.Load<Rgba32>(File.ReadAllBytes(path))

    let mutable imageSpan = default
    if (!image.TryGetSinglePixelSpan(&imageSpan))
        fail("Invalid image.")

    let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
    let mutable bytesSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
    let mutable bytes = Array.ZeroCreate<byte>(bytesSpan.Length)
    bytesSpan.CopyTo(Span(bytes))
    image.Dispose()

    GpuImage(image.Width, image.Height, ReadOnlyMemory(bytes))

createUI(deviceName: string, r: Rendering, frameTimesVM: FrameTimesViewModel): WindowView =
    let window = WindowView()
    window.Title <- "Window"

    window.Children.Add(
        let view = LabelView()
        view.Label <- "Device"
        view.Text <- deviceName
        view
    )

    let image = ImageView()
    window.Children.Add(
        let view = image
        view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf068.png")
        view.Size <- Vector2(64, 64)
        view
    )

    let textInput = TextInputView()
    textInput.Label <- "Oly Input Text"
    textInput.OnTextChanged <- (x: string, y: string) -> printLine(textInput.Text)
    window.Children.Add(textInput)

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Toggle Input Text"
        view.OnClicked <- () -> textInput.IsEnabled <- !textInput.IsEnabled
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Add Image"
        view.OnClicked <- 
            () ->
                image.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf066.png")
                window.Children.Add(
                    let view = ImageView()
                    view.GpuImage <- createImageByFile("GameExample/Textures/flats/aqf067.png")
                    view.Size <- Vector2(64, 64)
                    view
                )
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Move"
        view.IsChecked <- window.CanMove
        view.OnChecked <- (x: bool) -> window.CanMove <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Resize"
        view.IsChecked <- window.CanResize
        view.OnChecked <- (x: bool) -> window.CanResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Enable Auto-Resize"
        view.IsChecked <- window.CanAutoResize
        view.OnChecked <- (x: bool) -> window.CanAutoResize <- view.IsChecked
        view
    )

    window.Children.Add(
        let displayModes = r.Window.GetDisplayModes()
        let view = ComboBoxView()
        view.Label <- "Combo Box"
        view.Items <- Array.MapAsMutable(displayModes, x -> x.Width.ToString() + " x " + x.Height.ToString() + " | " + x.RefreshRate.ToString() + "hz")
        view.SelectedItemIndex <- Array.FindIndex(displayModes, (i, x) -> x.Equals(r.Window.CurrentDisplayMode))
        view.OnSelectedItemIndexChanged <- 
            (x: int32, y: int32) ->
                r.Window.ChangeDisplayMode(displayModes[y])
        view
    )

    window.Children.Add(
        let view = CheckboxView()
        view.Label <- "Fullscreen"
        view.IsChecked <- r.Window.IsFullscreen
        view.OnChecked <- (x: bool) -> r.Window.IsFullscreen <- view.IsChecked
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Close Window"
        view.OnClicked <- () -> window.IsOpen <- false
        view
    )

    window.Children.Add(
        let view = ButtonView()
        view.Label <- "Close Window"
        view.OnClicked <- () -> window.IsOpen <- false
        view
    )

    window.Children.Add(
        let view = LinePlotView()
        view.Label <- "Frame Times"
        view.Values <- frameTimesVM.Values
        view.ScaleMax <- 33
        view.ScaleMin <- 0
        let _ = frameTimesVM.Offset.Subscribe(x -> view.Offset <- x)
      //  view.ScaleMax <- 20
        view.Size <- Vector2(0, 100)
        view
    )

    window

class Subscription<T> =
    implements IDisposable

    private Unsubscribe: () -> () get

    new(unsubscribe: () -> ()) =
        {
            Unsubscribe = unsubscribe
        }

    Dispose(): () = this.Unsubscribe()

class Observable<T> =

    field subscribers: System.Collections.Generic.HashSet<T -> ()>
    mutable field value: T

    Subscribe(callback: T -> ()): Subscription<T> =
        let _ = this.subscribers.Add(callback)
        Subscription(() -> let _ = this.subscribers.Remove(callback))

    Value: T
        get() = this.value
        set(value) =
            this.value <- value
            ForEach(this.subscribers, callback -> callback(value))

    new(value: T) = { value = value; subscribers = System.Collections.Generic.HashSet() }

class FrameTimesViewModel =

    Values: mutable float32[] get = Array.ZeroCreate(100)
    Offset: Observable<int32> get = Observable(0)

main(): () =

    let world = ServerWorld()
    let stagingWorld = SharedWorld()
    let clientWorld = ClientWorld()

    let options = RenderingOptions()
    let r = Rendering.Create(options)

    let deviceName = r.Gpu.DeviceName

    let image = createImageByFile("GameExample/Textures/flats/aqf068.png")
    r.Gpu.Sync(image)

    let frameTimesVM = FrameTimesViewModel()

    let uiNode = createUI(r.Gpu.DeviceName, r, frameTimesVM)
    let uiNode2 = createUI(r.Gpu.DeviceName, r, frameTimesVM)

    let globals =
        GpuMutableArray.Initialize(GpuArrayKind.Global, GpuMemoryKind.Shared, 1,
            i ->
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
        )

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices = 
        GpuMutableArray.Initialize(GpuArrayKind.Vertex, GpuMemoryKind.Local, quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )

    let indices =
        GpuMutableArray.Initialize(GpuArrayKind.Index, GpuMemoryKind.Local, quad.Indices.Length,
            i -> quad.Indices[i]
        )

    let gpuProgramUI = GpuProgramUI()
    r.Gpu.Sync(gpuProgramUI)

    let frame = GpuFrame()

    let gpuProgramUI2 = GpuProgramUI(frame)
    r.Gpu.Sync(gpuProgramUI2)

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuInputKind.Array, GpuStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuInputKind.ImageOrFrame, GpuStageFlags.Fragment)
    gpuProgram.SetVertexInput<Vertex>()
    gpuProgram.VertexCode <- vertexShaderByteCode
    gpuProgram.FragmentCode <- fragmentShaderByteCode

    let gpuProgramReference = GpuProgramReference(gpuProgram)
    gpuProgramReference.AddGlobalInput(globals)
    gpuProgramReference.AddGlobalInput(frame)
    let gpuProgramInstance1 = GpuProgramInstance(gpuProgramReference)

    let gpuProgramReference2 = GpuProgramReference(gpuProgram)
    gpuProgramReference2.AddGlobalInput(globals)
    gpuProgramReference2.AddGlobalInput(image)
    let gpuProgramInstance2 = GpuProgramInstance(gpuProgramReference2, frame)

    let gpuCommands =
        Array.Initialize(1,
            i -> GpuCommand.DrawIndexed(gpuProgramInstance1, vertices, indices, quad.Indices.Length)
        )

    let gpuCommands = 
        Array.Add(
            [
                GpuCommand.NewFrame(frame)
                GpuCommand.DrawIndexed(gpuProgramInstance2, vertices, indices, quad.Indices.Length)
                GpuCommand.DrawUI(gpuProgramUI2, Cast([uiNode2]))
                GpuCommand.EndFrame()
            ],
            gpuCommands
        )
        
    let gpuCommands = Array.Add(gpuCommands, GpuCommand.DrawUI(gpuProgramUI, Cast([uiNode])))

    let mutable pos = Vector3(2, 2, 2)

    r.Window.Show()

    let mutable m = Matrix4x4.Identity
    let mutable frame = 0
    let mutable canRender = false
    let mutable renderTime = 0: int64
    let mutable lastRenderTime = 0: int64

    let random = Random()
    let mutable i = 0
    while (i < 8192)
        let position = Vector3(float32(random.Next()))
        let box = world.CreateBox(position, quat.Identity, vec3.One)
        i <- i + 1

    let mutable cpuTime = Stopwatch.StartNew()

    let lockObj = Object()
    let task =
        System.Threading.Tasks.Task.Run(
            () ->
                GameLoop.Start(
                    x -> (),
                    x ->
                        cpuTime.Restart()
                        world.Update(float32(x))

                        System.Threading.Monitor.Enter(lockObj)
                        world.CopyTo(stagingWorld)
                        System.Threading.Monitor.Exit(lockObj)

                        r.Window.IsClosed,
                    x ->
                        r.Window.IsClosed,
                    (frameTime, y) -> ()
                )
        )

    GameLoop.Start(
        x -> 
            System.Threading.Monitor.Enter(lockObj)
            stagingWorld.CopyTo(clientWorld)
            System.Threading.Monitor.Exit(lockObj)

            let _ = r.Window.PumpEvents(),
        x ->
            r.Window.IsClosed,
        x ->
            r.Window.IsClosed,
        (mutable frameTime, y) ->
            let size = r.Window.Size
            if (!r.Window.IsClosed && !r.Window.IsHidden && size.X != 0 && size.Y != 0)
                renderTime <- renderTime + frameTime.Ticks

                let frameTimeMs = TimeSpan.FromTicks(renderTime - lastRenderTime).TotalMilliseconds
                frameTimesVM.Offset.Value <- frame % frameTimesVM.Values.Length
                frameTimesVM.Values[frame % frameTimesVM.Values.Length] <- float32(frameTimeMs)
                frame <- frame + 1

                let mutable result = globals.AsSpan()
                let mutable x = &result[0]
                pos <- Vector3(2, 2, pos.Z + 0.01)
    
                x.View <- Matrix4x4.CreateLookAt(pos, Vector3(0, 0, 0), Vector3(0, 0, 1))
            //    gpuProgram.FragmentCode <- fragmentShaderByteCode
                r.Gpu.Execute(gpuCommands)     
                lastRenderTime <- renderTime
    )

    r.Dispose()
