namespace Evergreen.UI

open System
open System.Numerics
open System.Collections.Generic
open Evergreen
open Evergreen.Graphics

private alias Array = OlyPrelude.Array

interface IViewModel

class WindowViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true
    Size: Vector2 get, set = Vector2.Zero
    RelativePosition: Vector2 get, set = Vector2.Zero

    field titleBuffer: byte[||] = Array.ZeroCreate(256)
    mutable field titleBufferLength: int32 = 0
    mutable field title: string = string.Empty
    internal TitleSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.titleBuffer, 0, this.titleBufferLength)
    Title: string
        get() = this.title
        set(value) =
            this.title <- value
            this.titleBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.title, 0, this.title.Length, this.titleBuffer, 0)

class ButtonViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true
    Size: Vector2 get, set = Vector2.Zero

    field labelBuffer: byte[||] = Array.ZeroCreate(256)
    mutable field labelBufferLength: int32 = 0
    mutable field label: string = string.Empty
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(value) =
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

class TextInputViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true

    field labelBuffer: byte[||] = Array.ZeroCreate(256)
    mutable field labelBufferLength: int32 = 0
    mutable field label: string = string.Empty
    internal LabelSpan: ReadOnlySpan<byte> get() = ReadOnlySpan(this.labelBuffer, 0, this.labelBufferLength)
    Label: string
        get() = this.label
        set(value) =
            this.label <- value
            this.labelBufferLength <- System.Text.Encoding.UTF8.GetBytes(this.label, 0, this.label.Length, this.labelBuffer, 0)

    field textBuffer: byte[||] = Array.ZeroCreate(256)
    mutable field text: string = string.Empty
    internal TextSpan: Span<byte> get() = Span(this.textBuffer, 0, this.textBuffer.Length)
    Text: string
        get() = this.text
        set(value) = 
            this.text <- value
            let byteCount = System.Text.Encoding.UTF8.GetBytes(this.text, 0, this.text.Length, this.textBuffer, 0)

class Int32InputViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true
    Label: string get, set = string.Empty
    Value: int32 get, set = 0

class CheckboxViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true
    Label: string get, set = string.Empty
    IsChecked: bool get, set = false

class ComboBoxViewModel =
    implements IViewModel

    IsEnabled: bool get, set = true
    Label: string get, set = string.Empty
    SelectedItemIndex: int32 get, set = 0
    Items: string[||] get, set = [||]
    ItemCount: int32 get, set = 0

abstract class UINode =

    field Tag: int32
    private new(tag: int32) = { Tag = tag }

    internal class Window =
        inherits UINode

        State: WindowViewModel get
        Children: UINode[] get

        new(state: WindowViewModel, children: UINode[]) =
            base(0) with {
                State = state
                Children = children
            }

    pattern Window(node: UINode): (state: WindowViewModel, children: UINode[]) when (node.Tag == 0) =>
        let node = Unsafe.Cast<UINode.Window>(node)
        (node.State, node.Children)

    internal class Button =
        inherits UINode

        State: ButtonViewModel get
        OnClick: () -> () get

        new(state: ButtonViewModel, onClick: () -> ()) =
            base(1) with {
                State = state
                OnClick = onClick
            }

    pattern Button(node: UINode): (state: ButtonViewModel, onClick: () -> ()) when (node.Tag == 1) =>
        let node = Unsafe.Cast<UINode.Button>(node)
        (node.State, node.OnClick)

    internal class TextInput =
        inherits UINode

        State: TextInputViewModel get
        OnChanged: () -> () get

        new(state: TextInputViewModel, onChanged: () -> ()) =
            base(2) with {
                State = state
                OnChanged = onChanged
            }

    pattern TextInput(node: UINode): (state: TextInputViewModel, onChanged: () -> ()) when (node.Tag == 2) =>
        let node = Unsafe.Cast<UINode.TextInput>(node)
        (node.State, node.OnChanged)

    internal class Int32Input =
        inherits UINode

        State: Int32InputViewModel get
        OnChanged: () -> () get

        new(state: Int32InputViewModel, onChanged: () -> ()) =
            base(3) with {
                State = state
                OnChanged = onChanged
            }

    pattern Int32Input(node: UINode): (state: Int32InputViewModel, onChanged: () -> ()) when (node.Tag == 3) =>
        let node = Unsafe.Cast<UINode.Int32Input>(node)
        (node.State, node.OnChanged)

    internal class Checkbox =
        inherits UINode

        State: CheckboxViewModel get
        OnChanged: () -> () get

        new(state: CheckboxViewModel, onChanged: () -> ()) =
            base (10) with {
                State = state
                OnChanged = onChanged
            }

    pattern Checkbox(node: UINode): (state: CheckboxViewModel, onChanged: () -> ()) when (node.Tag == 10) =>
        let node = Unsafe.Cast<UINode.Checkbox>(node)
        (node.State, node.OnChanged)

    internal class ComboBox =
        inherits UINode

        State: ComboBoxViewModel get
        OnChanged: () -> () get

        new(state: ComboBoxViewModel, onChanged: () -> ()) =
            base (11) with {
                State = state
                OnChanged = onChanged
            }

    pattern ComboBox(node: UINode): (state: ComboBoxViewModel, onChanged: () -> ()) when (node.Tag == 11) =>
        let node = Unsafe.Cast<UINode.ComboBox>(node)
        (node.State, node.OnChanged)


module UI =

    private MakeNode(context: ImGui.ImGuiContext, node: UINode): () =
        match (node)
        | UINode.Window(state, children) =>
          //  ImGui.SetNextWindowSize(state.Size)
          //  ImGui.SetNextWindowPos(state.RelativePosition)
            ImGui.BeginDisabled(context, !state.IsEnabled)
            MakeWindow(context, state.TitleSpan, children)
            ImGui.EndDisabled(context)
        
        | UINode.Button(state, onClick) =>
            MakeButton(context, state, onClick)

        | UINode.TextInput(state, onChanged) =>
            MakeTextInput(context, state, onChanged)

        // | UINode.Int32Input(state, onChanged) =>
        //     MakeInt32Input(state, onChanged)

        // | UINode.Checkbox(state, onChanged) =>
        //     MakeCheckbox(state, onChanged)

        // | UINode.ComboBox(state, onChanged) =>
        //     MakeComboBox(state, onChanged)

        | _ =>
            ()

    private MakeWindow(context: ImGui.ImGuiContext, title: ReadOnlySpan<byte>, children: UINode[]): () =
        if (ImGui.Begin(context, title))
            let mutable i = 0
            while (i < children.Length)
                MakeNode(context, children[i])
                i <- i + 1
            ImGui.End(context)

    private MakeButton(context: ImGui.ImGuiContext, state: ButtonViewModel, onClick: () -> ()): () =
        ImGui.BeginDisabled(context, !state.IsEnabled)
        if (ImGui.Button(context, state.LabelSpan, state.Size))
            context.Callbacks.Enqueue(onClick)
        ImGui.EndDisabled(context)

    private MakeTextInput(context: ImGui.ImGuiContext, state: TextInputViewModel, onChanged: () -> ()): () =
        ImGui.BeginDisabled(context, !state.IsEnabled)
        if (ImGui.InputText(context, state.LabelSpan, state.TextSpan))
            let mutable textSpan = state.TextSpan
            if (textSpan[0] == 0)
                textSpan.Clear()
                state.Text <- String.Empty
            else
                state.Text <- System.Text.Encoding.UTF8.GetString(Span<_>.op_Implicit(state.TextSpan)).Trim('\0')
            context.Callbacks.Enqueue(onChanged)
        ImGui.EndDisabled(context)

    // private MakeInt32Input(state: Int32InputViewModel, onChanged: Int32InputViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.InputInt(state.Label, &state.Value))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeCheckbox(state: CheckboxViewModel, onChanged: CheckboxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Checkbox(state.Label, &state.IsChecked))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    // private MakeComboBox(state: ComboBoxViewModel, onChanged: ComboBoxViewModel -> ()): () =
    //     ImGui.BeginDisabled(!state.IsEnabled)
    //     if (ImGui.Combo(state.Label, &state.SelectedItemIndex, state.Items, state.ItemCount))
    //         onChanged(state)
    //     ImGui.EndDisabled()

    Window(state: WindowViewModel, children: UINode[]): UINode =
        UINode.Window(state, children)

    WindowModel(title: string, size: Vector2, relativePosition: Vector2): WindowViewModel =
        let vm = WindowViewModel()
        vm.Title <- title
        vm.Size <- size
        vm.RelativePosition <- relativePosition
        vm

    Button(state: ButtonViewModel, onClick: ButtonViewModel -> ()): UINode =
        UINode.Button(state, () -> onClick(state))

    ButtonModel(label: string, size: Vector2): ButtonViewModel =
        let vm = ButtonViewModel()
        vm.Label <- label
        vm.Size <- size
        vm

    ButtonModel(label: string): ButtonViewModel =
        ButtonModel(label, Vector2.Zero)

    TextInput(state: TextInputViewModel, onChanged: TextInputViewModel -> ()): UINode =
        UINode.TextInput(state, () -> onChanged(state))

    TextInputModel(label: string, text: string): TextInputViewModel =
        let vm = TextInputViewModel()
        vm.Label <- label
        vm.Text <- text
        vm

    Int32Input(state: Int32InputViewModel, onChanged: Int32InputViewModel -> ()): UINode =
        UINode.Int32Input(state, () -> onChanged(state))

    Int32InputModel(label: string, value: int32): Int32InputViewModel =
        let vm = Int32InputViewModel()
        vm.Label <- label
        vm.Value <- value
        vm

    Checkbox(state: CheckboxViewModel, onChanged: CheckboxViewModel -> ()): UINode =
        UINode.Checkbox(state, () -> onChanged(state))

    CheckboxModel(label: string, isChecked: bool): CheckboxViewModel =
        let vm = CheckboxViewModel()
        vm.Label <- label
        vm.IsChecked <- isChecked
        vm

    ComboBox(state: ComboBoxViewModel, onChanged: ComboBoxViewModel -> ()): UINode =
        UINode.ComboBox(state, () -> onChanged(state))

    ComboBoxModel(label: string, selectedItemIndex: int32, items: string[||], itemCount: int32): ComboBoxViewModel =
        let vm = ComboBoxViewModel()
        vm.Label <- label
        vm.SelectedItemIndex <- selectedItemIndex
        vm.Items <- items
        vm.ItemCount <- itemCount
        vm

    NewFrame(context: ImGui.ImGuiContext): () =
        ImGui.NewFrame(context)

    Show(context: ImGui.ImGuiContext, node: UINode): () =
        MakeNode(context, node)
        let mutable callback = unchecked default
        while (context.Callbacks.TryDequeue(&callback))
            callback()

    ShowDemoWindow(context: ImGui.ImGuiContext): () =
        ImGui.ShowDemoWindow(context)

    Draw(context: ImGui.ImGuiContext, commandBuffer: TerraFX.Interop.Vulkan.VkCommandBuffer, pipeline: TerraFX.Interop.Vulkan.VkPipeline): () =
        ImGui.Draw(context, commandBuffer, pipeline)
