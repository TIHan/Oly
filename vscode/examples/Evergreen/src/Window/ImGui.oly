module Evergreen.ImGui

open System
open Evergreen.Window
open System.Numerics
open Evergreen.Graphics.Backend.Vulkan
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan

alias ImGuiInputTextCallback = static blittable ImGuiInputTextCallbackData* -> int32

// enum ImGuiWindowFlags_
// {
//     ImGuiWindowFlags_None                   = 0,
//     ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
//     ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
//     ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
//     ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
//     ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
//     ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
//     ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
//     ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
//     ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
//     ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
//     ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
//     ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
//     ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
//     ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
//     ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
//     ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
//     ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
//     ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
//     ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
//     ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
//     ImGuiWindowFlags_NoDocking              = 1 << 21,  // Disable docking of this window

//     ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
//     ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
//     ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

//     // [Internal]
//     ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] On child window: allow gamepad/keyboard navigation to cross over parent border to this child or between sibling child windows.
//     ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
//     ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
//     ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
//     ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
//     ImGuiWindowFlags_ChildMenu              = 1 << 28,  // Don't use! For internal use by BeginMenu()
//     ImGuiWindowFlags_DockNodeHost           = 1 << 29,  // Don't use! For internal use by Begin()/NewFrame()

// TODO:
enum ImGuiWindowFlags =
    | None = 0

// TODO:
enum ImGuiInputTextFlags =
    | None = 0

struct ImFontConfig =
    mutable FontData: void* = default
    mutable FontDataSize: int32 = default
    mutable FontDataOwnedByAtlas: ImGuiBool = ImGuiBool(1)
    mutable FontNo: int32 = 0
    mutable SizePixels: float32 = default
    mutable OversampleH: int32 = 3
    mutable OversampleV: int32 = 1
    mutable PixelSnapH: ImGuiBool = ImGuiBool(2)
    mutable GlyphExtraSpacing: Vector2 = Vector2.Zero
    mutable GlyphOffset: Vector2 = Vector2.Zero
    mutable GlyphRanges: int16* = nullptr
    mutable GlyphMinAdvanceX: float32 = 0
    mutable GlyphMaxAdvanceX: float32 = float32.MaxValue
    mutable MergeMode: ImGuiBool = ImGuiBool(0)
    mutable FontBuilderFlags: uint32 = 0
    mutable RasterizerMultiply: float32 = 1
    mutable EllipsisChar: int16 = -1

newtype ImGuiBool =
    Value: byte

    static op_Equality(value1: ImGuiBool, value2: ImGuiBool): bool =
        value1.Value == value2.Value

    static op_Equality(value1: ImGuiBool, value2: bool): bool =
        value1.Value == byte(value2)

    static op_Inequality(value1: ImGuiBool, value2: bool): bool =
        value1.Value != byte(value2)

alias ImGuiKey = int32

struct ImGuiInputTextCallbackData =
    mutable Ctx: nint = default
    EventFlag: ImGuiInputTextFlags = default
    Flags: ImGuiInputTextFlags = default
    UserData: void* = default

    // -------------------------------------
    mutable EventChar: int16 = default
    EventKey: ImGuiKey = default
    mutable Buf: int8* = default
    mutable BufTextLen: int32 = default
    mutable BufSize: int32 = default
    mutable CursorPos: int32 = default
    mutable SelectionStart: int32 = default
    mutable SelectionEnd: int32 = default

private struct ImGuiIO =
    mutable ConfigFlags: int32 = 0
    mutable BackendFlags: int32 = 0
    mutable DisplaySize: Vector2 = Vector2.Zero
    mutable DeltaTime: float32 = 0
    mutable IniSavingRate: float32 = default
    mutable IniFilename: byte* = default
    mutable Logfilename: byte* = default
    mutable MouseDoubleClickTime: float32 = default
    mutable MouseDoubleClickMaxDist: float32 = default
    mutable MouseDragThreshold: float32 = default
    mutable KeyRepeatDelay: float32 = default
    mutable KeyRepeatRate: float32 = default
    mutable HoverDelayNormal: float32 = default
    mutable HoverDelayShort: float32 = default
    mutable UserData: void* = default

    mutable Fonts: nint = default
    // TODO: Add the rest of the fields
// {
//     //------------------------------------------------------------------
//     // Configuration                            // Default value
//     //------------------------------------------------------------------

//     ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
//     ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
//     ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
//     float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.

private struct ImGui_ImplVulkan_InitInfo =
    mutable Instance: VkInstance = default
    mutable PhysicalDevice: VkPhysicalDevice = default
    mutable Device: VkDevice = default
    mutable QueueFamily: uint32 = default
    mutable Queue: VkQueue = default
    mutable PipelineCache: VkPipelineCache = default
    mutable DescriptorPool: VkDescriptorPool = default
    mutable Subpass: uint32 = default
    mutable MinImageCount: uint32 = default // >= 2
    mutable ImageCount: uint32 = default // >= MinImageCount
    mutable MSAASamples: VkSampleCountFlags = default // >= VK_SAMPLE_COUNT_1_BIT (0 -> default to VK_SAMPLE_COUNT_1_BIT)
    mutable Allocator: VkAllocationCallbacks* = default
    mutable CheckVnResultVn: static blittable VkResult -> () = default



#[import("C", "imgui.dll", "igCreateContext")]
private igCreateContext(shared_font_atlas: void*): nint

#[import("C", "imgui.dll", "igDestroyContext")]
private igDestroyContext(ctx: nint): ()

#[import("C", "imgui.dll", "igNewFrame")]
private igNewFrame(): ()

#[import("C", "imgui.dll", "igRender")]
private igRender(): ()

#[import("C", "imgui.dll", "igGetDrawData")]
private igGetDrawData(): nint

#[import("C", "imgui.dll", "igGetIO")]
private igGetIO(): byref<ImGuiIO>

#[import("C", "imgui.dll", "igGetCurrentContext")]
private igGetCurrentContext(): nint

#[import("C", "imgui.dll", "igShowDemoWindow")]
private igShowDemoWindow(p_open: ImGuiBool*): ()

#[import("C", "imgui.dll", "igStyleColorsDark")]
private igStyleColorsDark(dst: void*): ()

#[import("C", "imgui.dll", "igStyleColorsClassic")]
private igStyleColorsClassic(dst: void*): ()

#[import("C", "imgui.dll", "igBegin")]
private igBegin(name: int8*, p_open: ImGuiBool*, flags: ImGuiWindowFlags): ImGuiBool

#[import("C", "imgui.dll", "igEnd")]
private igEnd(): ()

#[import("C", "imgui.dll", "igBeginDisabled")]
private igBeginDisabled(disabled: ImGuiBool): ()

#[import("C", "imgui.dll", "igEndDisabled")]
private igEndDisabled(): ()

#[import("C", "imgui.dll", "igInputText")]
private igInputText(label: int8*, buf: byte*, buf_size: nuint, flags: ImGuiInputTextFlags, callback: ImGuiInputTextCallback, user_data: void*): ImGuiBool

#[import("C", "imgui.dll", "ImFontAtlas_AddFontFromFileTTF")]
private ImFontAtlas_AddFontFromFileTTF(self: nint, filename: byte*, size_pixels: float32, font_cfg: ImFontConfig*, glyph_ranges: int16*): nint

#[import("C", "imgui.dll", "ImGui_ImplVulkan_Init")]
private ImGui_ImplVulkan_Init(info: ImGui_ImplVulkan_InitInfo*, render_pass: VkRenderPass): ImGuiBool

#[import("C", "imgui.dll", "ImGui_ImplVulkan_Shutdown")]
private ImGui_ImplVulkan_Shutdown(): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_NewFrame")]
private ImGui_ImplVulkan_NewFrame(): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_RenderDrawData")]
private ImGui_ImplVulkan_RenderDrawData(draw_data: nint, command_buffer: VkCommandBuffer, pipeline: VkPipeline): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_CreateFontsTexture")]
private ImGui_ImplVulkan_CreateFontsTexture(command_buffer: VkCommandBuffer): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_DestroyFontUploadObjects")]
private ImGui_ImplVulkan_DestroyFontUploadObjects(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_Init")]
private ImGui_ImplWin32_Init(hwnd: nint): ImGuiBool

#[import("C", "imgui.dll", "ImGui_ImplWin32_Shutdown")]
private ImGui_ImplWin32_Shutdown(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_NewFrame")]
private ImGui_ImplWin32_NewFrame(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_WndProcHandler")]
private ImGui_ImplWin32_WndProcHandler(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT

private fixed(o: object): GCHandle =
    System.Runtime.InteropServices.GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(System.Text.UTF8Encoding.UTF8.GetBytes(str))

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>])]
private CheckIntializeVulkan(result: VkResult): () =
    if (result != VkResult.VK_SUCCESS)
        fail("Failed to intialize ImGui.")

sealed class ImGuiContext =
    internal Context: nint
    internal Win32Handle: nint
    internal VulkanInfo: ImGui_ImplVulkan_InitInfo

    new(context: nint, hwnd: nint, info: ImGui_ImplVulkan_InitInfo) =
        {
            Context = context
            Win32Handle = hwnd
            VulkanInfo = info
        }

CreateContext(window: IWindow, app: VulkanApplication, swapChain: VulkanSwapChain, renderPass: VkRenderPass): ImGuiContext =
    let context = igCreateContext(nullptr)

    let io = &igGetIO()
   // io.ConfigFlags <- 1 // ImGuiConfigFlags_NavEnableKeyboard

    let mutable info = default: ImGui_ImplVulkan_InitInfo
    info.Instance <- app.Instance
    info.PhysicalDevice <- app.PhysicalDevice
    info.Device <- app.Device
    info.QueueFamily <- app.GraphicsQueueFamilyIndex
    info.Queue <- app.GraphicsQueue
    info.PipelineCache <- VkPipelineCache.NULL
    info.Subpass <- 0
    info.MinImageCount <- 2
    info.ImageCount <- 3
    info.MSAASamples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    info.Allocator <- nullptr
    info.CheckVnResultVn <- &&CheckIntializeVulkan

    let poolSizes =
        static let create(ty, count) =
            let mutable poolSize = default: VkDescriptorPoolSize
            poolSize.`type` <- ty
            poolSize.descriptorCount <- count
            poolSize
        [
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000)
        ]

    let mutable poolSizesHandle = fixed(poolSizes)

    let mutable poolInfo = default: VkDescriptorPoolCreateInfo
    poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
    poolInfo.flags <- VkDescriptorPoolCreateFlags.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT
    poolInfo.maxSets <- uint32(1000 * poolSizes.Length)
    poolInfo.poolSizeCount <- uint32(poolSizes.Length)
    poolInfo.pPoolSizes <- UnsafeCast(poolSizesHandle.AddrOfPinnedObject())

    if (vkCreateDescriptorPool(app.Device, &&poolInfo, nullptr, &&info.DescriptorPool) != VkResult.VK_SUCCESS)
        fail("Failed to create descriptor pool for ImGui.")

    poolSizesHandle.Free()

    let hwnd = window.HWND

    if (ImGui_ImplWin32_Init(hwnd) != true)
        fail("Failed to initialize ImGui for Win32.")
    
    if (ImGui_ImplVulkan_Init(&&info, renderPass) != true)
        fail("Failed to initialize ImGui for Vulkan.")

    ImGuiContext(context, hwnd, info)

DestroyContext(context: ImGuiContext): () =
    ImGui_ImplVulkan_Shutdown()
    ImGui_ImplWin32_Shutdown()
    vkDestroyDescriptorPool(context.VulkanInfo.Device, context.VulkanInfo.DescriptorPool, nullptr)
    igDestroyContext(context.Context)

AddFont(context: ImGuiContext, filePath: string): () =
    let mutable filePathHandle = fixedCopyUTF8(filePath)

    let mutable io = igGetIO()
    let font = ImFontAtlas_AddFontFromFileTTF(io.Fonts, UnsafeCast(filePathHandle.AddrOfPinnedObject()), 16, nullptr, nullptr)

    filePathHandle.Free()

UploadFonts(context: ImGuiContext, commandPool: VkCommandPool, commandBuffer: VkCommandBuffer): () =
    if (vkResetCommandPool(context.VulkanInfo.Device, commandPool, default) != VkResult.VK_SUCCESS)
        fail("Failed to reset command pool.")

    let mutable beginInfo = default: VkCommandBufferBeginInfo
    beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    beginInfo.flags <- VkCommandBufferUsageFlags.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT

    if (vkBeginCommandBuffer(commandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
        fail("Failed to begin command buffer.")

    ImGui_ImplVulkan_CreateFontsTexture(commandBuffer)

    let mutable endInfo = default: VkSubmitInfo
    endInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
    endInfo.commandBufferCount <- 1
    endInfo.pCommandBuffers <- &&commandBuffer

    if (vkEndCommandBuffer(commandBuffer) != VkResult.VK_SUCCESS)
        fail("Failed to end command buffer.")

    if (vkQueueSubmit(context.VulkanInfo.Queue, 1, &&endInfo, VkFence.NULL) != VkResult.VK_SUCCESS)
        fail("Failed to submit.")

    if (vkDeviceWaitIdle(context.VulkanInfo.Device) != VkResult.VK_SUCCESS)
        fail("Failed to wait idle for device.")

    ImGui_ImplVulkan_DestroyFontUploadObjects()

SetDarkMode(context: ImGuiContext): () =
    igStyleColorsDark(nullptr)

SetClassicMode(context: ImGuiContext): () =
    igStyleColorsClassic(nullptr)

NewFrame(context: ImGuiContext): () =
    ImGui_ImplVulkan_NewFrame()
    ImGui_ImplWin32_NewFrame()
    igNewFrame()

Draw(context: ImGuiContext, commandBuffer: VkCommandBuffer, pipeline: VkPipeline): () =
    igRender()
    let drawData = igGetDrawData()
    ImGui_ImplVulkan_RenderDrawData(drawData, commandBuffer, pipeline)

internal Win32ProcHandler(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): bool =
    !ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam).Equals(LRESULT(nint(0)))

//

ShowDemoWindow(context: ImGuiContext): () =
    let mutable p_open = ImGuiBool(1)
    igShowDemoWindow(&&p_open)

Begin(context: ImGuiContext, title: string): bool =
    let mutable titleHandle = fixedCopyUTF8(title)

    let mutable p_open = ImGuiBool(1)
    let result = igBegin(UnsafeCast(titleHandle.AddrOfPinnedObject()), &&p_open, ImGuiWindowFlags.None)

    titleHandle.Free()

    result == true

End(context: ImGuiContext): () =
    igEnd()

#[blittable]
callback(callbackData: ImGuiInputTextCallbackData*): int32 =
    0

InputText(context: ImGuiContext, label: string, mutable buffer: Span<byte>): bool =
    let mutable labelHandle = fixedCopyUTF8(label)

    let mutable bufferPtr = UnsafeCast(Unsafe.AsPointer(&buffer.GetPinnableReference()))

    let result =
        igInputText(
            UnsafeCast(labelHandle.AddrOfPinnedObject()),
            bufferPtr,
            nuint(buffer.Length),
            ImGuiInputTextFlags.None,
            &&callback,
            nullptr
        )

    result == true

