module Evergreen.ImGui

open System
open Evergreen.Window
open System.Numerics
open Evergreen.Graphics.Backend.Vulkan
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan

private alias VkDescriptorType = Evergreen.Graphics.Backend.Vulkan.VkDescriptorType

alias ImGuiInputTextCallback = static blittable ImGuiInputTextCallbackData* -> int32

// enum ImGuiWindowFlags_
// {
//     ImGuiWindowFlags_None                   = 0,
//     ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
//     ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
//     ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
//     ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
//     ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
//     ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
//     ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
//     ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
//     ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
//     ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
//     ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
//     ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
//     ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
//     ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
//     ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
//     ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
//     ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
//     ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
//     ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
//     ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
//     ImGuiWindowFlags_NoDocking              = 1 << 21,  // Disable docking of this window

//     ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
//     ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
//     ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

//     // [Internal]
//     ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] On child window: allow gamepad/keyboard navigation to cross over parent border to this child or between sibling child windows.
//     ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
//     ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
//     ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
//     ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
//     ImGuiWindowFlags_ChildMenu              = 1 << 28,  // Don't use! For internal use by BeginMenu()
//     ImGuiWindowFlags_DockNodeHost           = 1 << 29,  // Don't use! For internal use by Begin()/NewFrame()

// TODO:
enum ImGuiWindowFlags =
    | None = 0

// TODO:
enum ImGuiInputTextFlags =
    | None = 0

struct ImFontConfig =
    mutable FontData: void* = default
    mutable FontDataSize: int32 = default
    mutable FontDataOwnedByAtlas: ImGuiBool = default
    mutable FontNo: int32 = default
    mutable SizePixels: float32 = default
    mutable OversampleH: int32 = default
    mutable OversampleV: int32 = default
    mutable PixelSnapH: ImGuiBool = default
    mutable GlyphExtraSpacing: Vector2 = default
    mutable GlyphOffset: Vector2 = default
    mutable GlyphRanges: int16* = default
    mutable GlyphMinAdvanceX: float32 = default
    mutable GlyphMaxAdvanceX: float32 = default
    mutable MergeMode: ImGuiBool = default
    mutable FontBuilderFlags: uint32 = default
    mutable RasterizerMultiply: float32 = default
    mutable EllipsisChar: int16 = default

// TODO: Add fields
private struct ImFontAtlas

struct ImFont

newtype ImGuiBool =
    Value: byte

    static False: ImGuiBool get() = ImGuiBool(0)
    static True: ImGuiBool get() = ImGuiBool(1)

    static op_Equality(value1: ImGuiBool, value2: ImGuiBool): bool =
        value1.Value == value2.Value

    static op_Equality(value1: ImGuiBool, value2: bool): bool =
        value1.Value == byte(value2)

    static op_Inequality(value1: ImGuiBool, value2: bool): bool =
        value1.Value != byte(value2)

alias ImGuiKey = int32

struct ImGuiInputTextCallbackData =
    mutable Ctx: nint = default
    EventFlag: ImGuiInputTextFlags = default
    Flags: ImGuiInputTextFlags = default
    UserData: void* = default

    // -------------------------------------
    mutable EventChar: int16 = default
    EventKey: ImGuiKey = default
    mutable Buf: byte* = default
    mutable BufTextLen: int32 = default
    mutable BufSize: int32 = default
    mutable CursorPos: int32 = default
    mutable SelectionStart: int32 = default
    mutable SelectionEnd: int32 = default

private struct ImGuiIO =
    mutable ConfigFlags: int32 = 0
    mutable BackendFlags: int32 = 0
    mutable DisplaySize: Vector2 = Vector2.Zero
    mutable DeltaTime: float32 = 0
    mutable IniSavingRate: float32 = default
    mutable IniFilename: byte* = default
    mutable Logfilename: byte* = default
    mutable MouseDoubleClickTime: float32 = default
    mutable MouseDoubleClickMaxDist: float32 = default
    mutable MouseDragThreshold: float32 = default
    mutable KeyRepeatDelay: float32 = default
    mutable KeyRepeatRate: float32 = default
    mutable HoverDelayNormal: float32 = default
    mutable HoverDelayShort: float32 = default
    mutable UserData: void* = default

    mutable Fonts: ImFontAtlas* = default
    // TODO: Add the rest of the fields
// {
//     //------------------------------------------------------------------
//     // Configuration                            // Default value
//     //------------------------------------------------------------------

//     ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
//     ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
//     ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
//     float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.

private struct ImGui_ImplVulkan_InitInfo =
    mutable Instance: VkInstance = default
    mutable PhysicalDevice: VkPhysicalDevice = default
    mutable Device: VkDevice = default
    mutable QueueFamily: uint32 = default
    mutable Queue: VkQueue = default
    mutable PipelineCache: VkPipelineCache = default
    mutable DescriptorPool: VkDescriptorPool = default
    mutable Subpass: uint32 = default
    mutable MinImageCount: uint32 = default // >= 2
    mutable ImageCount: uint32 = default // >= MinImageCount
    mutable MSAASamples: VkSampleCountFlags = default // >= VK_SAMPLE_COUNT_1_BIT (0 -> default to VK_SAMPLE_COUNT_1_BIT)
    mutable Allocator: VkAllocationCallbacks* = default
    mutable CheckVnResultVn: static blittable VkResult -> () = default



#[import("C", "imgui.dll", "igCreateContext")]
private igCreateContext(shared_font_atlas: void*): nint

#[import("C", "imgui.dll", "igDestroyContext")]
private igDestroyContext(ctx: nint): ()

#[import("C", "imgui.dll", "igNewFrame")]
private igNewFrame(): ()

#[import("C", "imgui.dll", "igRender")]
private igRender(): ()

#[import("C", "imgui.dll", "igGetDrawData")]
private igGetDrawData(): nint

#[import("C", "imgui.dll", "igGetIO")]
private igGetIO(): byref<ImGuiIO>

#[import("C", "imgui.dll", "igGetCurrentContext")]
private igGetCurrentContext(): nint

#[import("C", "imgui.dll", "igShowDemoWindow")]
private igShowDemoWindow(p_open: ImGuiBool*): ()

#[import("C", "imgui.dll", "igStyleColorsDark")]
private igStyleColorsDark(dst: void*): ()

#[import("C", "imgui.dll", "igStyleColorsClassic")]
private igStyleColorsClassic(dst: void*): ()

#[import("C", "imgui.dll", "igBegin")]
private igBegin(name: byte*, p_open: ImGuiBool*, flags: ImGuiWindowFlags): ImGuiBool

#[import("C", "imgui.dll", "igEnd")]
private igEnd(): ()

#[import("C", "imgui.dll", "igBeginDisabled")]
private igBeginDisabled(disabled: ImGuiBool): ()

#[import("C", "imgui.dll", "igEndDisabled")]
private igEndDisabled(): ()

#[import("C", "imgui.dll", "igLabelText")]
private igLabelText(label: byte*, fmt: byte*): ()

#[import("C", "imgui.dll", "igButton")]
private igButton(label: byte*, size: Vector2): ImGuiBool

#[import("C", "imgui.dll", "igCheckbox")]
private igCheckbox(label: byte*, v: ImGuiBool*): ImGuiBool

#[import("C", "imgui.dll", "igInputText")]
private igInputText(label: byte*, buf: byte*, buf_size: nuint, flags: ImGuiInputTextFlags, callback: ImGuiInputTextCallback, user_data: void*): ImGuiBool

#[import("C", "imgui.dll", "igInputInt")]
private igInputInt(label: byte*, v: int32*, step: int32, step_fast: int32, flags: ImGuiInputTextFlags): ImGuiBool

#[import("C", "imgui.dll", "igCombo_Str_arr")]
private igCombo_Str_arr(label: byte*, current_item: int32*, items: (byte*)*, items_count: int32, popup_max_height_in_items: int32): ImGuiBool

#[import("C", "imgui.dll", "ImFontConfig_ImFontConfig")]
private ImFontConfig_ImFontConfig(): ImFontConfig*

#[import("C", "imgui.dll", "ImFontConfig_destroy")]
private ImFontConfig_destroy(self: ImFontConfig*): ()

#[import("C", "imgui.dll", "ImFontAtlas_AddFontDefault")]
private ImFontAtlas_AddFontDefault(self: ImFontAtlas*, font_cfg: ImFontConfig*): ImFont*

#[import("C", "imgui.dll", "ImFontAtlas_AddFontFromMemoryTTF")]
private ImFontAtlas_AddFontFromMemoryTTF(self: ImFontAtlas*, font_data: void*, font_size: int32, size_pixels: float32, font_cfg: ImFontConfig*, glyph_ranges: int16*): ImFont*

#[import("C", "imgui.dll", "ImFontAtlas_GetGlyphRangesGreek")]
private ImFontAtlas_GetGlyphRangesGreek(self: ImFontAtlas*): int16*

#[import("C", "imgui.dll", "ImGui_ImplVulkan_Init")]
private ImGui_ImplVulkan_Init(info: ImGui_ImplVulkan_InitInfo*, render_pass: VkRenderPass): ImGuiBool

#[import("C", "imgui.dll", "ImGui_ImplVulkan_Shutdown")]
private ImGui_ImplVulkan_Shutdown(): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_NewFrame")]
private ImGui_ImplVulkan_NewFrame(): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_RenderDrawData")]
private ImGui_ImplVulkan_RenderDrawData(draw_data: nint, command_buffer: VkCommandBuffer, pipeline: VkPipeline): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_CreateFontsTexture")]
private ImGui_ImplVulkan_CreateFontsTexture(command_buffer: VkCommandBuffer): ()

#[import("C", "imgui.dll", "ImGui_ImplVulkan_DestroyFontUploadObjects")]
private ImGui_ImplVulkan_DestroyFontUploadObjects(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_Init")]
private ImGui_ImplWin32_Init(hwnd: nint): ImGuiBool

#[import("C", "imgui.dll", "ImGui_ImplWin32_Shutdown")]
private ImGui_ImplWin32_Shutdown(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_NewFrame")]
private ImGui_ImplWin32_NewFrame(): ()

#[import("C", "imgui.dll", "ImGui_ImplWin32_WndProcHandler")]
private ImGui_ImplWin32_WndProcHandler(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT

private fixed(o: object): GCHandle =
    System.Runtime.InteropServices.GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(System.Text.UTF8Encoding.UTF8.GetBytes(str))

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>])]
private CheckIntializeVulkan(result: VkResult): () =
    if (result != VkResult.VK_SUCCESS)
        fail("Failed to intialize ImGui.")

sealed class ImGuiContext =
    internal Context: nint
    internal Win32Handle: nint
    internal VulkanInfo: ImGui_ImplVulkan_InitInfo

    new(context: nint, hwnd: nint, info: ImGui_ImplVulkan_InitInfo) =
        {
            Context = context
            Win32Handle = hwnd
            VulkanInfo = info
        }

CreateContext(window: IWindow, app: VulkanApplication, swapChain: VulkanSwapChain, renderPass: VkRenderPass): ImGuiContext =
    let context = igCreateContext(nullptr)

    let io = &igGetIO()
   // io.ConfigFlags <- 1 // ImGuiConfigFlags_NavEnableKeyboard

    let mutable info = default: ImGui_ImplVulkan_InitInfo
    info.Instance <- app.Instance
    info.PhysicalDevice <- app.PhysicalDevice
    info.Device <- app.Device
    info.QueueFamily <- app.GraphicsQueueFamilyIndex
    info.Queue <- app.GraphicsQueue
    info.PipelineCache <- VkPipelineCache.NULL
    info.Subpass <- 0
    info.MinImageCount <- 2
    info.ImageCount <- 3
    info.MSAASamples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    info.Allocator <- nullptr
    info.CheckVnResultVn <- &&CheckIntializeVulkan

    let poolSizes =
        static let create(ty, count) =
            let mutable poolSize = default: VkDescriptorPoolSize
            poolSize.`type` <- ty
            poolSize.descriptorCount <- count
            poolSize
        [
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000);
            create(VkDescriptorType.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000)
        ]

    let mutable poolSizesHandle = fixed(poolSizes)

    let mutable poolInfo = default: VkDescriptorPoolCreateInfo
    poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
    poolInfo.flags <- VkDescriptorPoolCreateFlags.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT
    poolInfo.maxSets <- uint32(1000 * poolSizes.Length)
    poolInfo.poolSizeCount <- uint32(poolSizes.Length)
    poolInfo.pPoolSizes <- UnsafeCast(poolSizesHandle.AddrOfPinnedObject())

    if (vkCreateDescriptorPool(app.Device, &&poolInfo, nullptr, &&info.DescriptorPool) != VkResult.VK_SUCCESS)
        fail("Failed to create descriptor pool for ImGui.")

    poolSizesHandle.Free()

    let hwnd = window.HWND

    if (ImGui_ImplWin32_Init(hwnd) != true)
        fail("Failed to initialize ImGui for Win32.")
    
    if (ImGui_ImplVulkan_Init(&&info, renderPass) != true)
        fail("Failed to initialize ImGui for Vulkan.")

    ImGuiContext(context, hwnd, info)

DestroyContext(context: ImGuiContext): () =
    ImGui_ImplVulkan_Shutdown()
    ImGui_ImplWin32_Shutdown()
    vkDestroyDescriptorPool(context.VulkanInfo.Device, context.VulkanInfo.DescriptorPool, nullptr)
    igDestroyContext(context.Context)

AddFontDefault(context: ImGuiContext): ImFont* =
    let mutable io = igGetIO()
    ImFontAtlas_AddFontDefault(io.Fonts, nullptr)

AddFont(context: ImGuiContext, filePath: string, pixelSize: float32): ImFont* =
    let fontData = System.IO.File.ReadAllBytes(filePath)
    let fontSize = fontData.Length
    let mutable fontDataHandle = fixed(fontData)

    let fontConfigPtr = ImFontConfig_ImFontConfig()
    let mutable fontConfig = &Unsafe.AsRef<ImFontConfig>(UnsafeCast<void*>(fontConfigPtr))
    // Do this to avoid memory corruption when destroying the context.
    fontConfig.FontDataOwnedByAtlas <- ImGuiBool.False

    let mutable io = igGetIO()
    let glyphRanges = ImFontAtlas_GetGlyphRangesGreek(io.Fonts)

    let fontPtr = ImFontAtlas_AddFontFromMemoryTTF(io.Fonts, UnsafeCast(fontDataHandle.AddrOfPinnedObject()), fontSize, pixelSize, &&fontConfig, glyphRanges)

    ImFontConfig_destroy(fontConfigPtr)
    fontDataHandle.Free()
    fontPtr

UploadFonts(context: ImGuiContext, commandPool: VkCommandPool, commandBuffer: VkCommandBuffer): () =
    if (vkResetCommandPool(context.VulkanInfo.Device, commandPool, default) != VkResult.VK_SUCCESS)
        fail("Failed to reset command pool.")

    let mutable beginInfo = default: VkCommandBufferBeginInfo
    beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    beginInfo.flags <- VkCommandBufferUsageFlags.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT

    if (vkBeginCommandBuffer(commandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
        fail("Failed to begin command buffer.")

    ImGui_ImplVulkan_CreateFontsTexture(commandBuffer)

    let mutable endInfo = default: VkSubmitInfo
    endInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
    endInfo.commandBufferCount <- 1
    endInfo.pCommandBuffers <- &&commandBuffer

    if (vkEndCommandBuffer(commandBuffer) != VkResult.VK_SUCCESS)
        fail("Failed to end command buffer.")

    if (vkQueueSubmit(context.VulkanInfo.Queue, 1, &&endInfo, VkFence.NULL) != VkResult.VK_SUCCESS)
        fail("Failed to submit.")

    if (vkDeviceWaitIdle(context.VulkanInfo.Device) != VkResult.VK_SUCCESS)
        fail("Failed to wait idle for device.")

    ImGui_ImplVulkan_DestroyFontUploadObjects()

SetDarkMode(context: ImGuiContext): () =
    igStyleColorsDark(nullptr)

SetClassicMode(context: ImGuiContext): () =
    igStyleColorsClassic(nullptr)

NewFrame(context: ImGuiContext): () =
    ImGui_ImplVulkan_NewFrame()
    ImGui_ImplWin32_NewFrame()
    igNewFrame()

Draw(context: ImGuiContext, commandBuffer: VkCommandBuffer, pipeline: VkPipeline): () =
    igRender()
    let drawData = igGetDrawData()
    ImGui_ImplVulkan_RenderDrawData(drawData, commandBuffer, pipeline)

internal Win32ProcHandler(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): bool =
    !ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam).Equals(LRESULT(nint(0)))

//

ShowDemoWindow(context: ImGuiContext): () =
    let mutable p_open = ImGuiBool.True
    igShowDemoWindow(&&p_open)

Begin(context: ImGuiContext, mutable title: ReadOnlySpan<byte>): bool =
    let titlePtr = &&title.GetPinnableReference()

    let mutable p_open = ImGuiBool.True
    let result = igBegin(titlePtr, &&p_open, ImGuiWindowFlags.None)

    result == true

End(context: ImGuiContext): () =
    igEnd()

BeginDisabled(context: ImGuiContext, isDisabled: bool): () =
    igBeginDisabled(if (isDisabled) ImGuiBool.True else ImGuiBool.False)

EndDisabled(context: ImGuiContext): () =
    igEndDisabled()

LabelText(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, mutable text: ReadOnlySpan<byte>): () =
    let labelPtr = &&label.GetPinnableReference()
    let textPtr = &&text.GetPinnableReference()

    igLabelText(labelPtr, textPtr)

InputText(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, mutable buffer: Span<byte>): bool =
    let labelPtr = &&label.GetPinnableReference()
    let bufferPtr = UnsafeCast(Unsafe.AsPointer(&buffer.GetPinnableReference()))

    let result =
        igInputText(
            labelPtr,
            bufferPtr,
            nuint(buffer.Length),
            ImGuiInputTextFlags.None,
            default,
            nullptr
        )

    result == true

InputInt(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, value: byref<int32>): bool =
    let labelPtr = &&label.GetPinnableReference()

    let result =
        igInputInt(
            labelPtr,
            &&value,
            1,
            0,
            ImGuiInputTextFlags.None
        )

    result == true

Checkbox(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, value: byref<bool>): bool =
    let labelPtr = &&label.GetPinnableReference()

    let mutable imValue = default: ImGuiBool
    let result = igCheckbox(labelPtr, &&imValue)

    if (imValue == true)
        value <- true
    else
        value <- false

    result == true

Button(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, size: Vector2): bool =
    let labelPtr = &&label.GetPinnableReference()

    igButton(labelPtr, size) == true

Combo(context: ImGuiContext, mutable label: ReadOnlySpan<byte>, selectedItemIndex: byref<int32>, mutable items: ReadOnlySpan<byte*>, popupMaxHeight: int32): bool =
    let labelPtr = &&label.GetPinnableReference()
    let itemsPtr = &&items.GetPinnableReference()

    let result =
        igCombo_Str_arr(
            labelPtr,
            &&selectedItemIndex,
            itemsPtr,
            items.Length,
            popupMaxHeight
        )

    result == true
