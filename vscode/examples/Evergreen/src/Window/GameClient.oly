namespace Evergreen.Game

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.UI

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

enum GpuProgramStageFlags =
    | Vertex    = 0b00001
    | Fragment  = 0b00010
    | Compute   = 0b00100

enum GpuArrayKind =
    | Uniform
    | Vertex
    | Index

interface IGpuArray =

    internal Buffers: VulkanBuffer[||] get, set
    DataSize: int32 get
    IsDirty: bool get, internal set
    Kind: GpuArrayKind get
    Length: int32 get

    internal Update(vk: VulkanApplication, frame: int32): ()

class GpuSharedArray<T> where T: unmanaged =
    implements IGpuArray

    internal Buffers: VulkanBuffer[||] get, set  
    DataSize: int32 get
    IsDirty: bool get, internal set
    Kind: GpuArrayKind get
    Length: int32 get() = this.bufferData.Length

    private Update(vk: VulkanApplication, frame: int32): () =
        let buffer = this.Buffers[frame]
        Vk.UpdateBuffer(vk, buffer, this.bufferData)

    field bufferData: T[||]  

    internal new(kind: GpuArrayKind, bufferData: T[||]) =
        {
            DataSize = sizeof<T>
            Kind = kind
            bufferData = bufferData
            Buffers = [||]
            IsDirty = true
        }

    get_Item(index: int32): T =
        this.bufferData[index]

    set_Item(index: int32, value: T): () =
        this.IsDirty <- true
        this.bufferData[index] <- value

    AsSpan(): Span<T> =
        this.IsDirty <- true
        Span(this.bufferData)

    AsReadOnlySpan(): ReadOnlySpan<T> =
        ReadOnlySpan(this.bufferData)

    static Initialize(kind: GpuArrayKind, size: int32, f: int32 -> T): GpuSharedArray<T> =
        let bufferData = Array.InitializeMutable(size, f)
        GpuSharedArray(kind, bufferData)

class GpuImage =
    FilePath: string get
    IsDirty: bool get, internal set
    internal VulkanImage: VulkanImage get, set
    internal VkImageView: VkImageView get, set
    internal VkSampler: VkSampler get, set

    new(filePath: string) =
        {
            FilePath = filePath
            IsDirty = true
            VulkanImage = unchecked default
            VkImageView = VkImageView.NULL
            VkSampler = VkSampler.NULL
        }

enum GpuProgramInputKind =
    | Array
    | Image

struct GpuProgramInput =
    Kind: GpuProgramInputKind get
    internal Image: GpuImage get
    internal Array: IGpuArray get

    private new(kind: GpuProgramInputKind, gpuImage: GpuImage, gpuArray: IGpuArray) =
        {
            Kind = kind
            Image = gpuImage
            Array = gpuArray
        }

    static CreateArray(gpuArray: IGpuArray): GpuProgramInput =
        GpuProgramInput(GpuProgramInputKind.Array, unchecked default, gpuArray)

    static CreateImage(gpuImage: GpuImage): GpuProgramInput =
        GpuProgramInput(GpuProgramInputKind.Image, gpuImage, unchecked default)

class GpuProgram =
    IsDirty: bool get, internal set

    mutable field vertexCode: ReadOnlyMemory<byte>
    VertexCode: ReadOnlyMemory<byte>
        get() = this.vertexCode
        set(value) =
            this.IsDirty <- true
            this.vertexCode <- value

    mutable field fragmentCode: ReadOnlyMemory<byte>
    FragmentCode: ReadOnlyMemory<byte>
        get() = this.fragmentCode
        set(value) =
            this.IsDirty <- true
            this.fragmentCode <- value

    mutable field computeCode: ReadOnlyMemory<byte>
    ComputeCode: ReadOnlyMemory<byte>
        get() = this.computeCode
        set(value) =
            this.IsDirty <- true
            this.computeCode <- value

    internal VulkanDescriptorBindingInfos: List<VulkanDescriptorBindingInfo> get
    internal VkDescriptorSetLayout: VkDescriptorSetLayout get, set
    internal VkVertexShaderModule: VkShaderModule get, set
    internal VkFragmentShaderModule: VkShaderModule get, set
    internal VkComputeShaderModule: VkShaderModule get, set
    internal VkPipelineLayout: VkPipelineLayout get, set

    internal VkVertexInputBindingDescriptions: VkVertexInputBindingDescription[] get, set
    internal VkVertexInputAttributeDescriptions: VkVertexInputAttributeDescription[] get, set
    internal VkPipeline: VkPipeline get, set

    internal Version: Guid get, set

    new() =
        {
            Version = default
            IsDirty = true

            vertexCode = ReadOnlyMemory<_>.Empty
            fragmentCode = ReadOnlyMemory<_>.Empty
            computeCode = ReadOnlyMemory<_>.Empty

            VulkanDescriptorBindingInfos = List()
            VkDescriptorSetLayout = VkDescriptorSetLayout.NULL
            VkVertexShaderModule = VkShaderModule.NULL
            VkFragmentShaderModule = VkShaderModule.NULL
            VkComputeShaderModule = VkShaderModule.NULL
            VkPipelineLayout = VkPipelineLayout.NULL

            VkVertexInputBindingDescriptions = []
            VkVertexInputAttributeDescriptions = []
            VkPipeline = VkPipeline.NULL
        }

    AddGlobalInput(kind: GpuProgramInputKind, stageFlags: GpuProgramStageFlags): () =
        this.IsDirty <- true

        let descriptorType =
            match (kind)
            | GpuProgramInputKind.Array =>
                VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
            | GpuProgramInputKind.Image =>
                VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
            | _ =>
                fail("Invalid gpu program input kind.")

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Vertex == GpuProgramStageFlags.Vertex)
                VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT
            else
                default

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Fragment == GpuProgramStageFlags.Fragment)
                shaderStageFlags | VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT
            else
                shaderStageFlags

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Compute == GpuProgramStageFlags.Compute)
                shaderStageFlags | VkShaderStageFlags.VK_SHADER_STAGE_COMPUTE_BIT
            else
                shaderStageFlags

        let binding = uint32(this.VulkanDescriptorBindingInfos.Count)
        let bindingInfo = VulkanDescriptorBindingInfo(binding, descriptorType, shaderStageFlags)
        this.VulkanDescriptorBindingInfos.Add(bindingInfo)

    SetVertexInput<T>(): () where T: unmanaged =
        this.IsDirty <- true

        this.VkVertexInputBindingDescriptions <- [Vk.CreateVertexBindingDescription<T>(0, false)]
        this.VkVertexInputAttributeDescriptions <- Vk.CreateVertexAttributeDescriptions<T>(0)

class GpuProgramGlobalInputs =
    IsDirty: bool get, internal set
    Program: GpuProgram get

    internal Inputs: List<GpuProgramInput> get

    internal VkDescriptorPool: VkDescriptorPool get, set
    internal VkDescriptorSets: VkDescriptorSet[] get, set

    internal Version: Guid get, set

    new(gpuProgram: GpuProgram) =
        {
            IsDirty = true
            Program = gpuProgram
            Inputs = List()
            VkDescriptorPool = VkDescriptorPool.NULL
            VkDescriptorSets = []
            Version = default
        }

    Add(input: GpuProgramInput): () =
        this.IsDirty <- true

        this.Inputs.Add(input)

class GpuProgramExecution =
    GlobalInputs: GpuProgramGlobalInputs get
    DrawIndexCount: int32 get, set

    Program: GpuProgram get() = this.GlobalInputs.Program

    internal VertexInput: IGpuArray get, set
    internal IndexInput: IGpuArray get, set

    new(gpuProgramGlobalInputs: GpuProgramGlobalInputs) =
        {
            DrawIndexCount = 0
            VertexInput = unchecked default
            IndexInput = unchecked default
            GlobalInputs = gpuProgramGlobalInputs
        }

    SetVertexInput(gpuArray: IGpuArray): () =
        this.VertexInput <- gpuArray

    SetIndexInput(gpuArray: IGpuArray): () =
        this.IndexInput <- gpuArray

#[open]
class Gpu =
    implements IDisposable

    private struct DelayedArrayUploadInfo =
        Frame: int32 get
        GpuArray: IGpuArray get

        new(frame: int32, gpuArray: IGpuArray) =
            {
                Frame = frame
                GpuArray = gpuArray
            }

    field window: IWindow
    field delayedArrayUploadSet: ConcurrentDictionary<IGpuArray, ()>
    field delayedArrayUpload: ConcurrentQueue<DelayedArrayUploadInfo>
    field gpuArrays: ConcurrentDictionary<IGpuArray, ()>
    field gpuImages: ConcurrentDictionary<GpuImage, ()>
    field gpuPrograms: ConcurrentDictionary<GpuProgram, ()>
    field gpuProgramGlobalInputsSet: ConcurrentDictionary<GpuProgramGlobalInputs, ()>

    field vk: VulkanApplication
    field vkCmdBuffers: VulkanCommandBuffer[||]

    mutable field imguiContext: ImGui.ImGuiContext // can be null
    mutable field swapChain: VulkanSwapChain
    mutable field swapChainFramebuffers: VkFramebuffer[]
    mutable field graphicsPipeline: VkPipeline
    mutable field renderPass: VkRenderPass

    internal new(window: IWindow, vk: VulkanApplication) =
        let vkCmdBuffers =
            let vkCmdBuffers = Array.ZeroCreate(vk.MaxFramesInFlight)
            let mutable i = 0
            while (i < vkCmdBuffers.Length)
                vkCmdBuffers[i] <- Vk.CreateGraphicsCommandBuffer(vk)
                i <- i + 1
            vkCmdBuffers
        {
            window = window       
            delayedArrayUploadSet = ConcurrentDictionary()
            delayedArrayUpload = ConcurrentQueue()
            gpuArrays = ConcurrentDictionary()
            gpuImages = ConcurrentDictionary()
            gpuPrograms = ConcurrentDictionary()
            gpuProgramGlobalInputsSet = ConcurrentDictionary()

            vk = vk
            vkCmdBuffers = vkCmdBuffers

            imguiContext = unchecked default
            swapChain = unchecked default
            swapChainFramebuffers = unchecked default
            graphicsPipeline = unchecked default
            renderPass = unchecked default
        }

    Upload(gpuArray: IGpuArray): () =
        if (gpuArray.IsDirty)
            gpuArray.IsDirty <- false

            if (gpuArray.Buffers.Length == 0)
                let usageFlags =
                    match (gpuArray.Kind)
                    | GpuArrayKind.Uniform => 
                        VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
                    | GpuArrayKind.Vertex =>
                        VkBufferUsageFlags.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
                    | GpuArrayKind.Index =>
                        VkBufferUsageFlags.VK_BUFFER_USAGE_INDEX_BUFFER_BIT
                    | _ =>
                        fail("Invalid 'GpuArrayKind'.")

           //     let usageFlags = usageFlags | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT

                let bufferSize = gpuArray.DataSize * gpuArray.Length
                let bufferSize = uint64(Math.Min(256, bufferSize))

                gpuArray.Buffers <-
                    Array.InitializeMutable(this.vk.MaxFramesInFlight, 
                        i ->
                            Vk.CreateBuffer(
                                this.vk,
                                bufferSize,
                                usageFlags,
                                VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
                              //  VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
                            )
                    )

                let mutable i = 0
                while (i < this.vk.MaxFramesInFlight)
                    gpuArray.Update(this.vk, i)
                    i <- i + 1

                this.gpuArrays[gpuArray] <- ()
            else
                let mutable i = 0
                while (i < this.vk.MaxFramesInFlight)
                    if (this.vk.PreviousFrame == i)
                        if (this.delayedArrayUploadSet.TryAdd(gpuArray, ()))
                            this.delayedArrayUpload.Enqueue(DelayedArrayUploadInfo(i, gpuArray))
                    else
                        gpuArray.Update(this.vk, i)
                    i <- i + 1

    Upload(gpuImage: GpuImage): () =
        if (gpuImage.IsDirty)
            gpuImage.IsDirty <- false

            let image = Image.Load<Rgba32>(File.ReadAllBytes(gpuImage.FilePath))
            let width = uint32(image.Width)
            let height = uint32(image.Height)
            let format = VkFormat.VK_FORMAT_R8G8B8A8_UNORM

            let mutable imageSpan = default
            if (!image.TryGetSinglePixelSpan(&imageSpan))
                fail("Invalid image.")

            let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
            let imageSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
            let vulkanImage = Vk.CreateImage(this.vk, width, height, format)
            Vk.UpdateImage(this.vk, vulkanImage, imageSpan)
            image.Dispose()

            let sampler = Vk.CreateSampler(this.vk)

            gpuImage.VulkanImage <- vulkanImage
            gpuImage.VkImageView <- Vk.CreateImageView(this.vk, vulkanImage, VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT)
            gpuImage.VkSampler <- sampler

            this.gpuImages[gpuImage] <- ()

    Upload(gpuProgram: GpuProgram): () =
        if (gpuProgram.IsDirty)
            this.Destroy(gpuProgram)
            gpuProgram.IsDirty <- false

            if (!gpuProgram.VertexCode.IsEmpty)
                gpuProgram.VkVertexShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.VertexCode.Span)

            if (!gpuProgram.FragmentCode.IsEmpty)
                gpuProgram.VkFragmentShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.FragmentCode.Span)

            if (!gpuProgram.ComputeCode.IsEmpty)
                gpuProgram.VkComputeShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.ComputeCode.Span)

            let bindingInfos = Span<_>.op_Implicit(CollectionsMarshal.AsSpan(gpuProgram.VulkanDescriptorBindingInfos))

            let setLayout = Vk.CreateDescriptorSetLayout(this.vk, bindingInfos)
            let pipelineLayout = Vk.CreatePipelineLayout(this.vk, [setLayout])

            gpuProgram.VkDescriptorSetLayout <- setLayout
            gpuProgram.VkPipelineLayout <- pipelineLayout

            gpuProgram.Version <- Guid.NewGuid()

            this.gpuPrograms[gpuProgram] <- ()

        if (gpuProgram.VkPipeline == VkPipeline.NULL)
            let vertexShader = gpuProgram.VkVertexShaderModule
            let fragmentShader = gpuProgram.VkFragmentShaderModule
            let computeShader = gpuProgram.VkComputeShaderModule
            if (vertexShader != VkShaderModule.NULL && fragmentShader != VkShaderModule.NULL)
                gpuProgram.VkPipeline <-
                    Vk.CreateGraphicsPipeline(
                        this.vk, 
                        this.swapChain, 
                        gpuProgram.VkVertexInputBindingDescriptions, 
                        gpuProgram.VkVertexInputAttributeDescriptions, 
                        gpuProgram.VkPipelineLayout, 
                        this.renderPass, 
                        VkCullModeFlags.VK_CULL_MODE_BACK_BIT, 
                        VkFrontFace.VK_FRONT_FACE_CLOCKWISE, 
                        vertexShader, 
                        fragmentShader
                    )
            else
                fail("Invalid gpu program.")

    Upload(gpuProgramGlobalInputs: GpuProgramGlobalInputs): () =
        this.Upload(gpuProgramGlobalInputs.Program)

        let mutable i = 0
        while (i < gpuProgramGlobalInputs.Inputs.Count)
            let globalInput = gpuProgramGlobalInputs.Inputs[i]
            match (globalInput.Kind)
            | GpuProgramInputKind.Array =>
                this.Upload(globalInput.Array)
            | GpuProgramInputKind.Image =>
                this.Upload(globalInput.Image)
            | _ =>
                fail("Invalid gpu program input kind.")
            i <- i + 1

        if (gpuProgramGlobalInputs.Version != Guid.Empty && gpuProgramGlobalInputs.Version != gpuProgramGlobalInputs.Program.Version)
            gpuProgramGlobalInputs.IsDirty <- true

        if (gpuProgramGlobalInputs.IsDirty)
            this.Destroy(gpuProgramGlobalInputs)
            gpuProgramGlobalInputs.IsDirty <- false

            let setLayout = gpuProgramGlobalInputs.Program.VkDescriptorSetLayout

            let mutable descriptorTypes = 
                ReadOnlySpan(
                    Array.InitializeMutable(gpuProgramGlobalInputs.Program.VulkanDescriptorBindingInfos.Count, 
                        i -> gpuProgramGlobalInputs.Program.VulkanDescriptorBindingInfos[i].DescriptorType
                    )
                )

            let descriptorPool = Vk.CreateDescriptorPool(this.vk, descriptorTypes, uint32(this.vk.MaxFramesInFlight))
            let descriptorSets = Vk.CreateDescriptorSets(this.vk, descriptorPool, uint32(this.vk.MaxFramesInFlight), setLayout)

            let mutable frame = 0
            while (frame < this.vk.MaxFramesInFlight)
                           
                let mutable i = 0
                while (i < descriptorTypes.Length)
                    let descriptorType = descriptorTypes[i]
                    let globalInput = gpuProgramGlobalInputs.Inputs[i]
                    
                    match (globalInput.Kind)
                    | GpuProgramInputKind.Array =>
                        Vk.UpdateDescriptorSet(this.vk, uint32(i), descriptorSets[frame], globalInput.Array.Buffers[frame], descriptorType)
                    | GpuProgramInputKind.Image =>
                        let vkImageView = globalInput.Image.VkImageView
                        let vkSampler = globalInput.Image.VkSampler
                        Vk.UpdateDescriptorSet(this.vk, 1, descriptorSets[frame], VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, vkImageView, vkSampler, descriptorType)
                    | _ =>
                        fail("Invalid gpu program input kind.")
                    i <- i + 1

                frame <- frame + 1
            
            gpuProgramGlobalInputs.VkDescriptorPool <- descriptorPool
            gpuProgramGlobalInputs.VkDescriptorSets <- descriptorSets
            gpuProgramGlobalInputs.Version <- gpuProgramGlobalInputs.Program.Version

            this.gpuProgramGlobalInputsSet[gpuProgramGlobalInputs] <- ()

    Destroy(gpuArray: IGpuArray): () =
        if (gpuArray.Buffers.Length != 0)
            let mutable i = 0
            while (i < gpuArray.Buffers.Length)
                Vk.DestroyBuffer(this.vk, gpuArray.Buffers[i])
                i <- i + 1
            gpuArray.Buffers <- [||]

            let mutable value = unchecked default
            let result = this.gpuArrays.TryRemove(gpuArray, &value)
            gpuArray.IsDirty <- true

    Destroy(gpuImage: GpuImage): () =
        if (gpuImage.VulkanImage !== unchecked default)
            Vk.DestroySampler(this.vk, gpuImage.VkSampler)
            Vk.DestroyImageView(this.vk, gpuImage.VkImageView)
            Vk.DestroyImage(this.vk, gpuImage.VulkanImage)

            let mutable value = unchecked default
            let result = this.gpuImages.TryRemove(gpuImage, &value)
            gpuImage.IsDirty <- true

    Destroy(gpuProgram: GpuProgram): () =
        if (gpuProgram.VkPipelineLayout != VkPipelineLayout.NULL)
            Vk.WaitForIdle(this.vk)

            Vk.DestroyPipeline(this.vk, gpuProgram.VkPipeline)
            Vk.DestroyDescriptorSetLayout(this.vk, gpuProgram.VkDescriptorSetLayout)
            Vk.DestroyPipelineLayout(this.vk, gpuProgram.VkPipelineLayout)

            if (gpuProgram.VkVertexShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkVertexShaderModule)

            if (gpuProgram.VkFragmentShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkFragmentShaderModule)

            if (gpuProgram.VkComputeShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkComputeShaderModule)

            gpuProgram.VkPipeline <- VkPipeline.NULL
            gpuProgram.VkDescriptorSetLayout <- VkDescriptorSetLayout.NULL
            gpuProgram.VkPipelineLayout <- VkPipelineLayout.NULL
            gpuProgram.VkVertexShaderModule <- VkShaderModule.NULL
            gpuProgram.VkFragmentShaderModule <- VkShaderModule.NULL
            gpuProgram.VkComputeShaderModule <- VkShaderModule.NULL

            let mutable value = unchecked default
            let result = this.gpuPrograms.TryRemove(gpuProgram, &value)
            gpuProgram.IsDirty <- true

    Destroy(gpuProgramGlobalInputs: GpuProgramGlobalInputs): () =
        if (gpuProgramGlobalInputs.VkDescriptorPool != VkDescriptorPool.NULL)
            Vk.DestroyDescriptorPool(this.vk, gpuProgramGlobalInputs.VkDescriptorPool)
            gpuProgramGlobalInputs.VkDescriptorPool <- VkDescriptorPool.NULL

            let mutable value = unchecked default
            let result = this.gpuProgramGlobalInputsSet.TryRemove(gpuProgramGlobalInputs, &value)
            gpuProgramGlobalInputs.IsDirty <- true

    Draw(uiNode: UINode, gpuProgramExecutions: GpuProgramExecution[]): () =
        if (this.swapChain === unchecked default)
            this.RecreateSwapChain()

        try
            UI.Update(this.imguiContext, uiNode)

            Vk.Draw(this.vk, this.swapChain, 
                (framebufferIndex, frame) -> 
                    let framebuffer = this.swapChainFramebuffers[framebufferIndex]
                    let extent = this.swapChain.Extent
                    let viewport = this.swapChain.Viewport
                    let scissor = this.swapChain.Scissor

                    // --------------------------------------------------
                    let commandBuffer = this.vkCmdBuffers[frame]

                    Vk.ResetCommandBuffer(this.vk, commandBuffer)

                    commandBuffer.Begin()
                    commandBuffer.BeginRenderPass(this.renderPass, framebuffer, extent)

                    let mutable currentPipeline = VkPipeline.NULL
                    let mutable currentGlobalInputs = unchecked default

                    let mutable i = 0
                    while (i < gpuProgramExecutions.Length)
                        let gpuProgramExecution = gpuProgramExecutions[i]
                        this.Upload(gpuProgramExecution.GlobalInputs)
                        this.Upload(gpuProgramExecution.VertexInput)
                        this.Upload(gpuProgramExecution.IndexInput)

                        let gpuProgram = gpuProgramExecution.Program

                        let descriptorSets = gpuProgramExecution.GlobalInputs.VkDescriptorSets

                        if (currentPipeline != gpuProgram.VkPipeline)
                            currentPipeline <- gpuProgram.VkPipeline

                            commandBuffer.BindPipeline(currentPipeline, VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
                            commandBuffer.SetViewport(viewport)
                            commandBuffer.SetScissor(scissor)

                        if (currentGlobalInputs !== gpuProgramExecution.GlobalInputs)
                            currentGlobalInputs <- gpuProgramExecution.GlobalInputs

                            let pipelineLayout = gpuProgramExecution.Program.VkPipelineLayout
                            let descriptorSet = descriptorSets[frame]
                            commandBuffer.BindDescriptorSet(VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, descriptorSet)

                        let vertexBuffer = gpuProgramExecution.VertexInput.Buffers[frame]
                        let indexBuffer = gpuProgramExecution.IndexInput.Buffers[frame]
                        let drawIndexCount = gpuProgramExecution.DrawIndexCount
                            
                        commandBuffer.BindVertexBuffer(vertexBuffer)
                        commandBuffer.BindIndexBuffer(indexBuffer)
                        commandBuffer.DrawIndexed(uint32(drawIndexCount), 1)

                        i <- i + 1

                    ImGui.Draw(this.imguiContext, commandBuffer, VkPipeline.NULL)

                    commandBuffer.EndRenderPass()
                    commandBuffer.End()

                    commandBuffer
            )
        catch (ex: VulkanSwapChainOutOfDateException) =>
            let size = this.window.Size
            if (!this.window.IsClosed && size.X != 0 && size.Y != 0)
                Vk.WaitForIdle(this.vk)
                this.CleanupSwapChain()
                try
                    this.RecreateSwapChain()
                catch (ex: VulkanSwapChainCreationFailedException) =>
                    // swap-chain failed to create, bail out of application
                    ()

        let mutable info = default
        while (this.delayedArrayUpload.TryDequeue(&info))
            info.GpuArray.Update(this.vk, info.Frame)
            let mutable result = unchecked default
            let result = this.delayedArrayUploadSet.TryRemove(info.GpuArray, &result)

    Dispose(): () =
        Vk.WaitForIdle(this.vk)

        let gpuProgramGlobalInputsLookup = this.gpuProgramGlobalInputsSet.ToArray()
        let mutable i = 0
        while (i < gpuProgramGlobalInputsLookup.Length)
            this.Destroy(gpuProgramGlobalInputsLookup[i].Key)
            i <- i + 1

        let gpuPrograms = this.gpuPrograms.ToArray()
        let mutable i = 0
        while (i < gpuPrograms.Length)
            this.Destroy(gpuPrograms[i].Key)
            i <- i + 1

        let gpuArrays = this.gpuArrays.ToArray()
        let mutable i = 0
        while (i < gpuArrays.Length)
            this.Destroy(gpuArrays[i].Key)
            i <- i + 1

        let gpuImages = this.gpuImages.ToArray()
        let mutable i = 0
        while (i < gpuImages.Length)
            this.Destroy(gpuImages[i].Key)
            i <- i + 1

        this.CleanupSwapChain()

        Vk.Destroy(this.vk)
            
    private RecreateSwapChain(): () =
        Vk.WaitForIdle(this.vk)
        
        let vulkanApp = this.vk

        let gpuPrograms = this.gpuPrograms.ToArray()
        let mutable i = 0
        while (i < gpuPrograms.Length)
            let gpuProgram = gpuPrograms[i].Key
            Vk.DestroyPipeline(this.vk, gpuProgram.VkPipeline)
            gpuProgram.VkPipeline <- VkPipeline.NULL
            i <- i + 1

        this.swapChain <- Vk.CreateSwapChain(vulkanApp, VkFormat.VK_FORMAT_B8G8R8A8_UNORM)
        this.renderPass <- Vk.CreateRenderPass(vulkanApp, this.swapChain)
        this.swapChainFramebuffers <- Vk.CreateSwapChainFramebuffers(vulkanApp, this.swapChain, this.renderPass)
        this.imguiContext <- ImGui.CreateContext(this.window, vulkanApp, this.swapChain, this.renderPass)

      //  let fullPath = Path.Combine(Environment.CurrentDirectory, "Win32Example/bin/dotnet/Win32Example.olyx/DroidSans.ttf")

        // Must do this first before NewFrame!
        let fontSize =
            let size = this.window.Size
            let ratio = (size.Y / 720)
            ratio * 16
        //fontHandle <- ImGui.AddFont(imguiContext, fullPath, fontSize)
        ImGui.UploadFonts(this.imguiContext, vulkanApp.GraphicsCommandPool, this.vkCmdBuffers[0])

        GC.Collect(2, GCCollectionMode.Forced, true)

    private CleanupSwapChain(): () =
        if (this.swapChain !== unchecked default)
            ImGui.DestroyContext(this.imguiContext)
            Vk.DestroyPipeline(this.vk, this.graphicsPipeline)
            Vk.DestroyFramebuffers(this.vk, this.swapChainFramebuffers)   
            Vk.DestroyRenderPass(this.vk, this.renderPass)
            Vk.DestroySwapChain(this.vk, this.swapChain)
            this.swapChain <- unchecked default

class GameClientOptions =
    WindowTitle: string get, set = "Game Client"
    InitialWindowSize: Vector2 get, set = Vector2(1280, 720)

class GameClient =
    implements IDisposable

    private new(window: IWindow, gpu: Gpu) =
        {
            Window = window
            Gpu = gpu
        }

    Window: IWindow get
    Gpu: Gpu get

    static Create(options: GameClientOptions): GameClient =
        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")
        
        let window = IWindow.CreateWin32(options.WindowTitle, Vector2(0, 0), options.InitialWindowSize)

        let vulkanAppOptions = VulkanApplicationOptions()
        vulkanAppOptions.ValidationEnabled <- true
        vulkanAppOptions.MaxFramesInFlight <- 2
        let vulkanApp = Vk.Initialize(window.HWND, window.HINSTANCE, vulkanAppOptions)

        let gpu = Gpu(window, vulkanApp)
        GameClient(window, gpu)

    Dispose(): () =
        this.Gpu.Dispose()
        this.Window.Dispose()