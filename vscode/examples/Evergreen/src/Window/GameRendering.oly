namespace Evergreen.Game.Rendering

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open System.Collections.Generic
open System.Collections.Concurrent
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.UI

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias Array = OlyPrelude.Array
private alias Unsafe = OlyPrelude.Unsafe

enum GpuProgramStageFlags =
    | Vertex    = 0b00001
    | Fragment  = 0b00010
    | Compute   = 0b00100

enum GpuMemoryKind =
    | Local
    | Shared

enum GpuArrayKind =
    | Global
    | Vertex
    | Index

interface IGpuArray =

    internal Buffers: VulkanBuffer[||] get, set
    DataSize: int32 get
    IsDirty: bool get, internal set
    Kind: GpuArrayKind get
    MemoryKind: GpuMemoryKind get
    Length: int32 get

    internal Update(vk: VulkanApplication, frame: int32): ()

class GpuMutableArray<T> where T: unmanaged =
    implements IGpuArray

    internal Buffers: VulkanBuffer[||] get, set  
    DataSize: int32 get
    IsDirty: bool get, internal set
    Kind: GpuArrayKind get
    MemoryKind: GpuMemoryKind get
    Length: int32 get() = this.bufferData.Length

    private Update(vk: VulkanApplication, frame: int32): () =
        let buffer = this.Buffers[frame]
        Vk.UpdateBuffer(vk, buffer, this.bufferData)

    field bufferData: T[||]  

    internal new(kind: GpuArrayKind, memoryKind: GpuMemoryKind, bufferData: T[||]) =
        {
            DataSize = sizeof<T>
            Kind = kind
            MemoryKind = memoryKind
            bufferData = bufferData
            Buffers = [||]
            IsDirty = true
        }

    get_Item(index: int32): T =
        this.bufferData[index]

    set_Item(index: int32, value: T): () =
        this.IsDirty <- true
        this.bufferData[index] <- value

    AsSpan(): Span<T> =
        this.IsDirty <- true
        Span(this.bufferData)

    AsReadOnlySpan(): ReadOnlySpan<T> =
        ReadOnlySpan(this.bufferData)

class GpuMutableArray =

    static Initialize<T>(kind: GpuArrayKind, memoryKind: GpuMemoryKind, size: int32, f: int32 -> T): GpuMutableArray<T> where T: unmanaged =
        let bufferData = Array.InitializeMutable(size, f)
        GpuMutableArray<T>(kind, memoryKind, bufferData)

class GpuImage =
    FilePath: string get
    IsDirty: bool get, internal set
    internal VulkanImage: VulkanImage get, set
    internal VkImageView: VkImageView get, set
    internal VkSampler: VkSampler get, set

    new(filePath: string) =
        {
            FilePath = filePath
            IsDirty = true
            VulkanImage = unchecked default
            VkImageView = VkImageView.NULL
            VkSampler = VkSampler.NULL
        }

enum GpuProgramInputKind =
    | Array
    | Image

internal struct GpuProgramInput =
    Kind: GpuProgramInputKind get
    Image: GpuImage get
    Array: IGpuArray get

    private new(kind: GpuProgramInputKind, gpuImage: GpuImage, gpuArray: IGpuArray) =
        {
            Kind = kind
            Image = gpuImage
            Array = gpuArray
        }

    static CreateArray(gpuArray: IGpuArray): GpuProgramInput =
        GpuProgramInput(GpuProgramInputKind.Array, unchecked default, gpuArray)

    static CreateImage(gpuImage: GpuImage): GpuProgramInput =
        GpuProgramInput(GpuProgramInputKind.Image, gpuImage, unchecked default)

class GpuProgram =
    IsDirty: bool get, internal set

    mutable field vertexCode: ReadOnlyMemory<byte>
    VertexCode: ReadOnlyMemory<byte>
        get() = this.vertexCode
        set(value) =
            this.IsDirty <- true
            this.vertexCode <- value

    mutable field fragmentCode: ReadOnlyMemory<byte>
    FragmentCode: ReadOnlyMemory<byte>
        get() = this.fragmentCode
        set(value) =
            this.IsDirty <- true
            this.fragmentCode <- value

    mutable field computeCode: ReadOnlyMemory<byte>
    ComputeCode: ReadOnlyMemory<byte>
        get() = this.computeCode
        set(value) =
            this.IsDirty <- true
            this.computeCode <- value

    internal VulkanDescriptorBindingInfos: List<VulkanDescriptorBindingInfo> get
    internal VkDescriptorSetLayout: VkDescriptorSetLayout get, set
    internal VkVertexShaderModule: VkShaderModule get, set
    internal VkFragmentShaderModule: VkShaderModule get, set
    internal VkComputeShaderModule: VkShaderModule get, set
    internal VkPipelineLayout: VkPipelineLayout get, set

    internal VkVertexInputBindingDescriptions: VkVertexInputBindingDescription[] get, set
    internal VkVertexInputAttributeDescriptions: VkVertexInputAttributeDescription[] get, set
    internal VkPipeline: VkPipeline get, set

    internal Version: Guid get, set

    new() =
        {
            Version = default
            IsDirty = true

            vertexCode = ReadOnlyMemory<_>.Empty
            fragmentCode = ReadOnlyMemory<_>.Empty
            computeCode = ReadOnlyMemory<_>.Empty

            VulkanDescriptorBindingInfos = List()
            VkDescriptorSetLayout = VkDescriptorSetLayout.NULL
            VkVertexShaderModule = VkShaderModule.NULL
            VkFragmentShaderModule = VkShaderModule.NULL
            VkComputeShaderModule = VkShaderModule.NULL
            VkPipelineLayout = VkPipelineLayout.NULL

            VkVertexInputBindingDescriptions = []
            VkVertexInputAttributeDescriptions = []
            VkPipeline = VkPipeline.NULL
        }

    AddGlobalInput(kind: GpuProgramInputKind, stageFlags: GpuProgramStageFlags): () =
        this.IsDirty <- true

        let descriptorType =
            match (kind)
            | GpuProgramInputKind.Array =>
                VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
            | GpuProgramInputKind.Image =>
                VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
            | _ =>
                fail("Invalid gpu program input kind.")

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Vertex == GpuProgramStageFlags.Vertex)
                VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT
            else
                default

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Fragment == GpuProgramStageFlags.Fragment)
                shaderStageFlags | VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT
            else
                shaderStageFlags

        let shaderStageFlags =
            if (stageFlags & GpuProgramStageFlags.Compute == GpuProgramStageFlags.Compute)
                shaderStageFlags | VkShaderStageFlags.VK_SHADER_STAGE_COMPUTE_BIT
            else
                shaderStageFlags

        let binding = uint32(this.VulkanDescriptorBindingInfos.Count)
        let bindingInfo = VulkanDescriptorBindingInfo(binding, descriptorType, shaderStageFlags)
        this.VulkanDescriptorBindingInfos.Add(bindingInfo)

    SetVertexInput<T>(): () where T: unmanaged =
        this.IsDirty <- true

        this.VkVertexInputBindingDescriptions <- [Vk.CreateVertexBindingDescription<T>(0, false)]
        this.VkVertexInputAttributeDescriptions <- Vk.CreateVertexAttributeDescriptions<T>(0)

class GpuProgramGlobalInputs =
    IsDirty: bool get, internal set
    Program: GpuProgram get

    internal Inputs: List<GpuProgramInput> get

    internal VkDescriptorPool: VkDescriptorPool get, set
    internal VkDescriptorSets: VkDescriptorSet[] get, set

    internal Version: Guid get, set

    new(gpuProgram: GpuProgram) =
        {
            IsDirty = true
            Program = gpuProgram
            Inputs = List()
            VkDescriptorPool = VkDescriptorPool.NULL
            VkDescriptorSets = []
            Version = default
        }

    Add(gpuArray: IGpuArray): () =
        this.IsDirty <- true

        this.Inputs.Add(GpuProgramInput(GpuProgramInputKind.Array, unchecked default, gpuArray))

    Add(gpuImage: GpuImage): () =
        this.IsDirty <- true

        this.Inputs.Add(GpuProgramInput(GpuProgramInputKind.Image, gpuImage, unchecked default))

abstract class GpuCommand =
    internal Tag: int32 get, set
    
    private class _DrawIndexed =
        inherits GpuCommand

        GlobalInputs: GpuProgramGlobalInputs get, set
        Vertices: IGpuArray get, set = unchecked default
        Indices: IGpuArray get, set = unchecked default
        IndexCount: int32 get, set = 0

    pattern DrawIndexed(cmd: GpuCommand): (globalInputs: GpuProgramGlobalInputs, vertices: IGpuArray, indices: IGpuArray, indexCount: int32) when (cmd.Tag == 0) =>
        let cmd = Unsafe.Cast<_DrawIndexed>(cmd)
        (cmd.GlobalInputs, cmd.Vertices, cmd.Indices, cmd.IndexCount)

    static DrawIndexed(globalInputs: GpuProgramGlobalInputs, vertices: IGpuArray, indices: IGpuArray, indexCount: int32): GpuCommand =
        let cmd = _DrawIndexed()
        cmd.Tag <- 0
        cmd.GlobalInputs <- globalInputs
        cmd.Vertices <- vertices
        cmd.Indices <- indices
        cmd.IndexCount <- indexCount
        cmd

    private class _DrawUI =
        inherits GpuCommand

        Node: UINode get, set = unchecked default

    pattern DrawUI(cmd: GpuCommand): UINode when (cmd.Tag == 1) =>
        let cmd = Unsafe.Cast<_DrawUI>(cmd)
        cmd.Node

    static DrawUI(uiNode: UINode): GpuCommand =
        let cmd = _DrawUI()
        cmd.Tag <- 1
        cmd.Node <- uiNode
        cmd

class Gpu =
    implements IDisposable

    private struct DelayedArrayUploadInfo =
        Frame: int32 get
        GpuArray: IGpuArray get

        new(frame: int32, gpuArray: IGpuArray) =
            {
                Frame = frame
                GpuArray = gpuArray
            }

    field window: IWindow
    field delayedArrayUploadSet: ConcurrentDictionary<IGpuArray, ()>
    field delayedArrayUpload: ConcurrentQueue<DelayedArrayUploadInfo>
    field gpuArrays: ConcurrentDictionary<IGpuArray, ()>
    field gpuImages: ConcurrentDictionary<GpuImage, ()>
    field gpuPrograms: ConcurrentDictionary<GpuProgram, ()>
    field gpuProgramGlobalInputsSet: ConcurrentDictionary<GpuProgramGlobalInputs, ()>

    field vk: VulkanApplication
    field vkCmdBuffers: VulkanCommandBuffer[||]

    mutable field imguiContext: ImGui.ImGuiContext // can be null
    mutable field swapChain: VulkanSwapChain
    mutable field swapChainFramebuffers: VkFramebuffer[]
    mutable field graphicsPipeline: VkPipeline
    mutable field renderPass: VkRenderPass

    internal new(window: IWindow, vk: VulkanApplication) =
        let vkCmdBuffers =
            let vkCmdBuffers = Array.ZeroCreate(vk.MaxFramesInFlight)
            let mutable i = 0
            while (i < vkCmdBuffers.Length)
                vkCmdBuffers[i] <- Vk.CreateGraphicsCommandBuffer(vk)
                i <- i + 1
            vkCmdBuffers
        {
            window = window       
            delayedArrayUploadSet = ConcurrentDictionary()
            delayedArrayUpload = ConcurrentQueue()
            gpuArrays = ConcurrentDictionary()
            gpuImages = ConcurrentDictionary()
            gpuPrograms = ConcurrentDictionary()
            gpuProgramGlobalInputsSet = ConcurrentDictionary()

            vk = vk
            vkCmdBuffers = vkCmdBuffers

            imguiContext = unchecked default
            swapChain = unchecked default
            swapChainFramebuffers = unchecked default
            graphicsPipeline = unchecked default
            renderPass = unchecked default
        }

    Upload(gpuArray: IGpuArray): () =
        if (gpuArray.IsDirty)
            gpuArray.IsDirty <- false

            if (gpuArray.Buffers.Length == 0)
                let usageFlags =
                    match (gpuArray.Kind)
                    | GpuArrayKind.Global => 
                        VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
                    | GpuArrayKind.Vertex =>
                        VkBufferUsageFlags.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
                    | GpuArrayKind.Index =>
                        VkBufferUsageFlags.VK_BUFFER_USAGE_INDEX_BUFFER_BIT
                    | _ =>
                        fail("Invalid 'GpuArrayKind'.")

                let usageFlags =
                    match (gpuArray.MemoryKind)
                    | GpuMemoryKind.Local =>
                        usageFlags | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT
                    | _ =>
                        usageFlags

                let bufferSize = gpuArray.DataSize * gpuArray.Length
                let bufferSize = uint64(Math.Min(256, bufferSize))

                let createFlags =
                    match (gpuArray.MemoryKind)
                    | GpuMemoryKind.Local =>
                        VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
                    | GpuMemoryKind.Shared =>
                        VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
                    | _ =>
                        fail("Invalid gpu memory kind.")

                gpuArray.Buffers <-
                    Array.InitializeMutable(this.vk.MaxFramesInFlight, 
                        i -> Vk.CreateBuffer(this.vk, bufferSize, usageFlags, createFlags)
                    )

                let mutable i = 0
                while (i < this.vk.MaxFramesInFlight)
                    gpuArray.Update(this.vk, i)
                    i <- i + 1

                this.gpuArrays[gpuArray] <- ()
            else
                let mutable i = 0
                while (i < this.vk.MaxFramesInFlight)
                    if (this.vk.PreviousFrame == i)
                        if (this.delayedArrayUploadSet.TryAdd(gpuArray, ()))
                            this.delayedArrayUpload.Enqueue(DelayedArrayUploadInfo(i, gpuArray))
                    else
                        gpuArray.Update(this.vk, i)
                    i <- i + 1

    Upload(gpuImage: GpuImage): () =
        if (gpuImage.IsDirty)
            gpuImage.IsDirty <- false

            let image = Image.Load<Rgba32>(File.ReadAllBytes(gpuImage.FilePath))
            let width = uint32(image.Width)
            let height = uint32(image.Height)
            let format = VkFormat.VK_FORMAT_R8G8B8A8_UNORM

            let mutable imageSpan = default
            if (!image.TryGetSinglePixelSpan(&imageSpan))
                fail("Invalid image.")

            let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
            let imageSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
            let vulkanImage = Vk.CreateImage(this.vk, width, height, format)
            Vk.UpdateImage(this.vk, vulkanImage, imageSpan)
            image.Dispose()

            let sampler = Vk.CreateSampler(this.vk)

            gpuImage.VulkanImage <- vulkanImage
            gpuImage.VkImageView <- Vk.CreateImageView(this.vk, vulkanImage, VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT)
            gpuImage.VkSampler <- sampler

            this.gpuImages[gpuImage] <- ()

    Upload(gpuProgram: GpuProgram): () =
        if (gpuProgram.IsDirty)
            this.Destroy(gpuProgram)
            gpuProgram.IsDirty <- false

            if (!gpuProgram.VertexCode.IsEmpty)
                gpuProgram.VkVertexShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.VertexCode.Span)

            if (!gpuProgram.FragmentCode.IsEmpty)
                gpuProgram.VkFragmentShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.FragmentCode.Span)

            if (!gpuProgram.ComputeCode.IsEmpty)
                gpuProgram.VkComputeShaderModule <- Vk.CreateShaderModule(this.vk, gpuProgram.ComputeCode.Span)

            let bindingInfos = Span<_>.op_Implicit(CollectionsMarshal.AsSpan(gpuProgram.VulkanDescriptorBindingInfos))

            let setLayout = Vk.CreateDescriptorSetLayout(this.vk, bindingInfos)
            let pipelineLayout = Vk.CreatePipelineLayout(this.vk, [setLayout])

            gpuProgram.VkDescriptorSetLayout <- setLayout
            gpuProgram.VkPipelineLayout <- pipelineLayout

            gpuProgram.Version <- Guid.NewGuid()

            this.gpuPrograms[gpuProgram] <- ()

        if (gpuProgram.VkPipeline == VkPipeline.NULL)
            let vertexShader = gpuProgram.VkVertexShaderModule
            let fragmentShader = gpuProgram.VkFragmentShaderModule
            let computeShader = gpuProgram.VkComputeShaderModule
            if (vertexShader != VkShaderModule.NULL && fragmentShader != VkShaderModule.NULL)
                gpuProgram.VkPipeline <-
                    Vk.CreateGraphicsPipeline(
                        this.vk, 
                        this.swapChain, 
                        gpuProgram.VkVertexInputBindingDescriptions, 
                        gpuProgram.VkVertexInputAttributeDescriptions, 
                        gpuProgram.VkPipelineLayout, 
                        this.renderPass, 
                        VkCullModeFlags.VK_CULL_MODE_BACK_BIT, 
                        VkFrontFace.VK_FRONT_FACE_CLOCKWISE, 
                        vertexShader, 
                        fragmentShader
                    )
            else
                fail("Invalid gpu program.")

    Upload(gpuProgramGlobalInputs: GpuProgramGlobalInputs): () =
        this.Upload(gpuProgramGlobalInputs.Program)

        let mutable i = 0
        while (i < gpuProgramGlobalInputs.Inputs.Count)
            let globalInput = gpuProgramGlobalInputs.Inputs[i]
            match (globalInput.Kind)
            | GpuProgramInputKind.Array =>
                this.Upload(globalInput.Array)
            | GpuProgramInputKind.Image =>
                this.Upload(globalInput.Image)
            | _ =>
                fail("Invalid gpu program input kind.")
            i <- i + 1

        if (gpuProgramGlobalInputs.Version != Guid.Empty && gpuProgramGlobalInputs.Version != gpuProgramGlobalInputs.Program.Version)
            gpuProgramGlobalInputs.IsDirty <- true

        if (gpuProgramGlobalInputs.IsDirty)
            this.Destroy(gpuProgramGlobalInputs)
            gpuProgramGlobalInputs.IsDirty <- false

            let setLayout = gpuProgramGlobalInputs.Program.VkDescriptorSetLayout

            let mutable descriptorTypes = 
                ReadOnlySpan(
                    Array.InitializeMutable(gpuProgramGlobalInputs.Program.VulkanDescriptorBindingInfos.Count, 
                        i -> gpuProgramGlobalInputs.Program.VulkanDescriptorBindingInfos[i].DescriptorType
                    )
                )

            let descriptorPool = Vk.CreateDescriptorPool(this.vk, descriptorTypes, uint32(this.vk.MaxFramesInFlight))
            let descriptorSets = Vk.CreateDescriptorSets(this.vk, descriptorPool, uint32(this.vk.MaxFramesInFlight), setLayout)

            let mutable frame = 0
            while (frame < this.vk.MaxFramesInFlight)
                           
                let mutable i = 0
                while (i < descriptorTypes.Length)
                    let descriptorType = descriptorTypes[i]
                    let globalInput = gpuProgramGlobalInputs.Inputs[i]
                    
                    match (globalInput.Kind)
                    | GpuProgramInputKind.Array =>
                        Vk.UpdateDescriptorSet(this.vk, uint32(i), descriptorSets[frame], globalInput.Array.Buffers[frame], descriptorType)
                    | GpuProgramInputKind.Image =>
                        let vkImageView = globalInput.Image.VkImageView
                        let vkSampler = globalInput.Image.VkSampler
                        Vk.UpdateDescriptorSet(this.vk, 1, descriptorSets[frame], VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, vkImageView, vkSampler, descriptorType)
                    | _ =>
                        fail("Invalid gpu program input kind.")
                    i <- i + 1

                frame <- frame + 1
            
            gpuProgramGlobalInputs.VkDescriptorPool <- descriptorPool
            gpuProgramGlobalInputs.VkDescriptorSets <- descriptorSets
            gpuProgramGlobalInputs.Version <- gpuProgramGlobalInputs.Program.Version

            this.gpuProgramGlobalInputsSet[gpuProgramGlobalInputs] <- ()

    Destroy(gpuArray: IGpuArray): () =
        if (gpuArray.Buffers.Length != 0)
            let mutable i = 0
            while (i < gpuArray.Buffers.Length)
                Vk.DestroyBuffer(this.vk, gpuArray.Buffers[i])
                i <- i + 1
            gpuArray.Buffers <- [||]

            let mutable value = unchecked default
            let result = this.gpuArrays.TryRemove(gpuArray, &value)
            gpuArray.IsDirty <- true

    Destroy(gpuImage: GpuImage): () =
        if (gpuImage.VulkanImage !== unchecked default)
            Vk.DestroySampler(this.vk, gpuImage.VkSampler)
            Vk.DestroyImageView(this.vk, gpuImage.VkImageView)
            Vk.DestroyImage(this.vk, gpuImage.VulkanImage)

            let mutable value = unchecked default
            let result = this.gpuImages.TryRemove(gpuImage, &value)
            gpuImage.IsDirty <- true

    Destroy(gpuProgram: GpuProgram): () =
        if (gpuProgram.VkPipelineLayout != VkPipelineLayout.NULL)
            Vk.WaitForIdle(this.vk)

            Vk.DestroyPipeline(this.vk, gpuProgram.VkPipeline)
            Vk.DestroyDescriptorSetLayout(this.vk, gpuProgram.VkDescriptorSetLayout)
            Vk.DestroyPipelineLayout(this.vk, gpuProgram.VkPipelineLayout)

            if (gpuProgram.VkVertexShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkVertexShaderModule)

            if (gpuProgram.VkFragmentShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkFragmentShaderModule)

            if (gpuProgram.VkComputeShaderModule != VkShaderModule.NULL)
                Vk.DestroyShaderModule(this.vk, gpuProgram.VkComputeShaderModule)

            gpuProgram.VkPipeline <- VkPipeline.NULL
            gpuProgram.VkDescriptorSetLayout <- VkDescriptorSetLayout.NULL
            gpuProgram.VkPipelineLayout <- VkPipelineLayout.NULL
            gpuProgram.VkVertexShaderModule <- VkShaderModule.NULL
            gpuProgram.VkFragmentShaderModule <- VkShaderModule.NULL
            gpuProgram.VkComputeShaderModule <- VkShaderModule.NULL

            let mutable value = unchecked default
            let result = this.gpuPrograms.TryRemove(gpuProgram, &value)
            gpuProgram.IsDirty <- true

    Destroy(gpuProgramGlobalInputs: GpuProgramGlobalInputs): () =
        if (gpuProgramGlobalInputs.VkDescriptorPool != VkDescriptorPool.NULL)
            Vk.DestroyDescriptorPool(this.vk, gpuProgramGlobalInputs.VkDescriptorPool)
            gpuProgramGlobalInputs.VkDescriptorPool <- VkDescriptorPool.NULL

            let mutable value = unchecked default
            let result = this.gpuProgramGlobalInputsSet.TryRemove(gpuProgramGlobalInputs, &value)
            gpuProgramGlobalInputs.IsDirty <- true

    Draw(gpuCommands: GpuCommand[]): () =
        if (this.swapChain === unchecked default)
            this.RecreateSwapChain()

        UI.NewFrame(this.imguiContext)

        try
            Vk.Draw(this.vk, this.swapChain, 
                (framebufferIndex, frame) -> 
                    let framebuffer = this.swapChainFramebuffers[framebufferIndex]
                    let extent = this.swapChain.Extent
                    let viewport = this.swapChain.Viewport
                    let scissor = this.swapChain.Scissor

                    // --------------------------------------------------
                    let commandBuffer = this.vkCmdBuffers[frame]

                    Vk.ResetCommandBuffer(this.vk, commandBuffer)

                    commandBuffer.Begin()
                    commandBuffer.BeginRenderPass(this.renderPass, framebuffer, extent)

                    let mutable currentPipeline = VkPipeline.NULL
                    let mutable currentGlobalInputs = unchecked default

                    let mutable i = 0
                    while (i < gpuCommands.Length)
                        let gpuCommand = gpuCommands[i]

                        match (gpuCommand)
                        | GpuCommand.DrawIndexed(globalInputs, vertices, indices, indexCount) =>
                            this.Upload(globalInputs)
                            this.Upload(vertices)
                            this.Upload(indices)

                            let gpuProgram = globalInputs.Program
                            let descriptorSets = globalInputs.VkDescriptorSets

                            if (currentPipeline != gpuProgram.VkPipeline)
                                currentPipeline <- gpuProgram.VkPipeline

                                commandBuffer.BindPipeline(currentPipeline, VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
                                commandBuffer.SetViewport(viewport)
                                commandBuffer.SetScissor(scissor)

                            if (currentGlobalInputs !== globalInputs)
                                currentGlobalInputs <- globalInputs

                                let pipelineLayout = gpuProgram.VkPipelineLayout
                                let descriptorSet = descriptorSets[frame]
                                commandBuffer.BindDescriptorSet(VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, descriptorSet)
                                
                            commandBuffer.BindVertexBuffer(vertices.Buffers[frame])
                            commandBuffer.BindIndexBuffer(indices.Buffers[frame])
                            commandBuffer.DrawIndexed(uint32(indexCount), 1)

                        | GpuCommand.DrawUI(uiNode) =>
                            UI.Show(this.imguiContext, uiNode)
                            UI.ShowDemoWindow(this.imguiContext)
                            UI.Draw(this.imguiContext, commandBuffer, VkPipeline.NULL)

                        | _ =>
                            ()

                        i <- i + 1

                    commandBuffer.EndRenderPass()
                    commandBuffer.End()

                    commandBuffer
            )
        catch (ex: VulkanSwapChainOutOfDateException) =>
            let size = this.window.Size
            if (!this.window.IsClosed && size.X != 0 && size.Y != 0)
                Vk.WaitForIdle(this.vk)
                this.CleanupSwapChain()
                try
                    this.RecreateSwapChain()
                catch (ex: VulkanSwapChainCreationFailedException) =>
                    // swap-chain failed to create, bail out of application
                    ()

        let mutable info = default
        while (this.delayedArrayUpload.TryDequeue(&info))
            info.GpuArray.Update(this.vk, info.Frame)
            let mutable result = unchecked default
            let result = this.delayedArrayUploadSet.TryRemove(info.GpuArray, &result)

    Dispose(): () =
        Vk.WaitForIdle(this.vk)

        let gpuProgramGlobalInputsLookup = this.gpuProgramGlobalInputsSet.ToArray()
        let mutable i = 0
        while (i < gpuProgramGlobalInputsLookup.Length)
            this.Destroy(gpuProgramGlobalInputsLookup[i].Key)
            i <- i + 1

        let gpuPrograms = this.gpuPrograms.ToArray()
        let mutable i = 0
        while (i < gpuPrograms.Length)
            this.Destroy(gpuPrograms[i].Key)
            i <- i + 1

        let gpuArrays = this.gpuArrays.ToArray()
        let mutable i = 0
        while (i < gpuArrays.Length)
            this.Destroy(gpuArrays[i].Key)
            i <- i + 1

        let gpuImages = this.gpuImages.ToArray()
        let mutable i = 0
        while (i < gpuImages.Length)
            this.Destroy(gpuImages[i].Key)
            i <- i + 1

        this.CleanupSwapChain()

        Vk.Destroy(this.vk)
            
    private RecreateSwapChain(): () =
        Vk.WaitForIdle(this.vk)
        
        let vulkanApp = this.vk

        let gpuPrograms = this.gpuPrograms.ToArray()
        let mutable i = 0
        while (i < gpuPrograms.Length)
            let gpuProgram = gpuPrograms[i].Key
            Vk.DestroyPipeline(this.vk, gpuProgram.VkPipeline)
            gpuProgram.VkPipeline <- VkPipeline.NULL
            i <- i + 1

        this.swapChain <- Vk.CreateSwapChain(vulkanApp, VkFormat.VK_FORMAT_B8G8R8A8_UNORM)
        this.renderPass <- Vk.CreateRenderPass(vulkanApp, this.swapChain)
        this.swapChainFramebuffers <- Vk.CreateSwapChainFramebuffers(vulkanApp, this.swapChain, this.renderPass)    
        this.imguiContext <- ImGui.CreateContext(this.window, vulkanApp, this.swapChain, this.renderPass)

      //  let fullPath = Path.Combine(Environment.CurrentDirectory, "Win32Example/bin/dotnet/Win32Example.olyx/DroidSans.ttf")

        // Must do this first before NewFrame!
        let fontSize =
            let size = this.window.Size
            let ratio = (size.Y / 720)
            ratio * 16
        //fontHandle <- ImGui.AddFont(imguiContext, fullPath, fontSize)
        ImGui.UploadFonts(this.imguiContext, vulkanApp.GraphicsCommandPool, this.vkCmdBuffers[0])

        GC.Collect(2, GCCollectionMode.Forced, true)

    private CleanupSwapChain(): () =
        if (this.swapChain !== unchecked default)
            ImGui.DestroyContext(this.imguiContext)
            Vk.DestroyPipeline(this.vk, this.graphicsPipeline)
            Vk.DestroyFramebuffers(this.vk, this.swapChainFramebuffers)   
            Vk.DestroyRenderPass(this.vk, this.renderPass)
            Vk.DestroySwapChain(this.vk, this.swapChain)
            this.swapChain <- unchecked default

class GameRenderingOptions =
    WindowTitle: string get, set = "Evergreen Engine"
    InitialWindowSize: Vector2 get, set = Vector2(1280, 720)

class GameRendering =
    implements IDisposable

    private new(window: IWindow, gpu: Gpu) =
        {
            Window = window
            Gpu = gpu
        }

    Window: IWindow get
    Gpu: Gpu get

    static Create(options: GameRenderingOptions): GameRendering =
        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")
        
        let window = IWindow.CreateWin32(options.WindowTitle, Vector2(0, 0), options.InitialWindowSize)

        let vulkanAppOptions = VulkanApplicationOptions()
        vulkanAppOptions.ValidationEnabled <- true
        vulkanAppOptions.MaxFramesInFlight <- 2
        let vulkanApp = Vk.Initialize(window.HWND, window.HINSTANCE, vulkanAppOptions)

        let gpu = Gpu(window, vulkanApp)
        GameRendering(window, gpu)

    Dispose(): () =
        this.Gpu.Dispose()
        this.Window.Dispose()