#target "dotnet: net7"
#library

#load "*.oly"

#reference "../../../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"
#package "Veldrid.ImGui,5.89.2-ga121087cad"
#package "Veldrid.ImageSharp,4.9.0"

namespace Evergreen.Graphics

open System
open System.Text
open System.Numerics
open System.Threading
open System.Collections.Concurrent
open System.Runtime.InteropServices
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV
open ImGuiNET
open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias VeldridShaderDescription = Veldrid.ShaderDescription
private alias VeldridShader = Veldrid.Shader

sealed class MeshDescription =
    mutable Vertices:   Vector3[||]
    mutable Indices:    uint32[||]
    mutable Normals:    Vector3[||]
    mutable TexCoords:  Vector2[||]

    new(vertices: Vector3[||], indices: uint32[||], normals: Vector3[||], texCoords: Vector2[||]) =
        {
            Vertices = vertices;
            Indices = indices;
            Normals = normals;
            TexCoords = texCoords
        }

    static CreateQuad(scale: float32): MeshDescription =
        let vertices =
            [|
                Vector3(-scale, -scale,  scale);
                Vector3(scale, -scale,  scale);
                Vector3(scale,  scale,  scale);
                Vector3(-scale,  scale,  scale)
            |]

        let normals =
            [|
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1)
            |]

        let texCoords =
            [|
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0)
            |]

        let indices =
            [|
                0;  1;  2;
                2;  3;  0: uint32
            |]
        
        MeshDescription(
            vertices, 
            indices,
            normals,
            texCoords
        )

    static CreateQuad(): MeshDescription =
        MeshDescription.CreateQuad(0.5)

    static CreateCube(): MeshDescription =
        let vertices =
            [|
                // front
                Vector3(-0.5, -0.5,  0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                // top
                Vector3(-0.5,  0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                // back
                Vector3(0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                // bottom
                Vector3(-0.5, -0.5, -0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(-0.5, -0.5,  0.5);
                // left
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5, -0.5);
                // right
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(0.5,  0.5,  0.5)
            |]

        let normals =
            [|
                // front
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                // top
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                // back
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                // bottom
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                // left
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                // right
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0)
            |]

        // let texCoords =
        //     [|
        //         // front
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // top
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // back
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // bottom
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // left
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // right
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0)
        //     |]
        let texCoords =
            [|
                // front
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // top
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                // back
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                // bottom
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // left
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                // right
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(-1.0, 0.0);
                Vector2(-1.0, 1.0)
            |]

        let indices =
            [|
                // front
                0;  1;  2;
                2;  3;  0: uint32;
                // top
                4;  5;  6;
                6;  7;  4: uint32;
                // back
                8;  9; 10;
                10; 11;  8;
                // bottom
                12; 13; 14;
                14; 15; 12;
                // left
                16; 17; 18;
                18; 19; 16: uint32;
                // right
                20; 21; 22;
                22; 23; 20: uint32
            |]
        
        MeshDescription(
            vertices, 
            indices,
            normals,
            texCoords
        )

sealed class ShaderDescription =
    internal mutable VertexLayouts:  VertexLayoutDescription[||]
    internal mutable VertexShader:   VeldridShaderDescription
    internal mutable FragmentShader: VeldridShaderDescription

    private new(vertexLayouts: VertexLayoutDescription[||], vertexShader: VeldridShaderDescription, fragmentShader: VeldridShaderDescription) =
        {
            VertexLayouts = vertexLayouts;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static CreateMeshShader(vertexShaderBytes: byte[||], fragmentShaderBytes: byte[||]): ShaderDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3);
                    VertexElementDescription("TexCoord", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float2);
                    VertexElementDescription("Normal", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3)
                |]
            )
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                vertexShaderBytes,
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                fragmentShaderBytes,
                "main"
            )

        ShaderDescription([|vertexLayout|], vertexShader, fragmentShader)

sealed class ComputeShaderDescription =
    internal mutable ComputeShader: VeldridShaderDescription

    private new(computeShader: VeldridShaderDescription) =
        {
            ComputeShader = computeShader
        }

    static CreateMeshLayout(computeShaderBytes: byte[||]): ComputeShaderDescription =
        let computeShader =
            ShaderDescription(
                ShaderStages.Compute,
                computeShaderBytes,
                "main"
            )

        ComputeShaderDescription(computeShader)

sealed class Mesh =
    implements IDisposable

    internal VertexBuffer:   DeviceBuffer
    internal IndexBuffer:    DeviceBuffer
    internal IndexCount:     uint32

    internal new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer, indexCount: uint32) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer;
            IndexCount = indexCount
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

sealed class Buffer<T> =
    implements IDisposable

    internal DeviceBuffer: DeviceBuffer

    internal new(deviceBuffer: DeviceBuffer) =
        {
            DeviceBuffer = deviceBuffer
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.DeviceBuffer)

#[null]
sealed class Texture2D =
    implements IDisposable

    internal Texture: Texture

    internal new(texture: Texture) =
        {
            Texture = texture
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.Texture)

private sealed class RenderTargetState =
    implements IDisposable

    Framebuffer: Framebuffer
    Texture: Texture2D

    /// This can be null.
    DepthTexture: Texture2D

    internal new(framebuffer: Framebuffer, texture: Texture2D, depthTexture: Texture2D) =
        {
            Framebuffer = framebuffer
            Texture = texture
            DepthTexture = depthTexture
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.Texture)
        Graphics.DisposeQueue.Enqueue(this.Framebuffer)

sealed class RenderTarget =
    implements IDisposable

    internal mutable State: RenderTargetState

    internal new(state: RenderTargetState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.Dispose()

sealed class Instances =
    implements IDisposable

    mutable Count: int32
    internal mutable InstanceBuffer: DeviceBuffer

    internal new(instanceBuffer: DeviceBuffer) =
        {
            Count = 0
            InstanceBuffer = instanceBuffer
        }

    Dispose(): () =
        this.InstanceBuffer.Dispose()

private sealed class ShaderState =
    internal VertexShader:   VeldridShader
    internal FragmentShader: VeldridShader
    internal Pipeline:       Pipeline

    internal new(vertexShader: VeldridShader, fragmentShader: VeldridShader, pipeline: Pipeline) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader;
            Pipeline = pipeline
        }

private sealed class ComputeShaderState =
    internal ComputeShader: VeldridShader
    internal Pipeline:      Pipeline

    internal new(computeShader: VeldridShader, pipeline: Pipeline) =
        {
            ComputeShader = computeShader;
            Pipeline = pipeline
        }

sealed class Shader =
    implements IDisposable

    internal mutable State: ShaderState

    internal new(state: ShaderState) =
        {
            State = state
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.State.Pipeline)
        Graphics.DisposeQueue.Enqueue(this.State.FragmentShader)
        Graphics.DisposeQueue.Enqueue(this.State.VertexShader)

sealed class ShaderTextureSet =
    implements IDisposable

    internal mutable ResourceSet: ResourceSet

    internal new(resourceSet: ResourceSet) =
        {
            ResourceSet = resourceSet
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.ResourceSet)

sealed class ShaderInstancesSet =
    implements IDisposable

    internal mutable ResourceSet: ResourceSet

    internal new(resourceSet: ResourceSet) =
        {
            ResourceSet = resourceSet
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.ResourceSet)

sealed class BufferSet =
    implements IDisposable

    internal mutable ResourceLayout: ResourceLayout
    internal mutable ResourceSet: ResourceSet

    internal new(resourceLayout: ResourceLayout, resourceSet: ResourceSet) =
        {
            ResourceLayout = resourceLayout
            ResourceSet = resourceSet
        }

    Dispose(): () =
        Graphics.DisposeQueue.Enqueue(this.ResourceLayout)
        Graphics.DisposeQueue.Enqueue(this.ResourceSet)

sealed class ComputeShader =
    implements IDisposable

    internal mutable State: ComputeShaderState

    internal new(state: ComputeShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.ComputeShader.Dispose()

enum DrawCommandKind =
    | SetWindowTarget
    | SetRenderTarget
    | DrawMesh
    | RunComputeShader
    | BindTextureSet
    | BindInstancesSet
    | BindBufferSet

enum BindResourceSetKind =
    | Graphics
    | Compute

class DrawCommand =
    Kind: DrawCommandKind

    new(kind: DrawCommandKind) =
        {
            Kind = kind
        }

    private sealed class SetWindowTarget =
        inherits DrawCommand

        new() =
            base(DrawCommandKind.SetWindowTarget) with
                {
                }

    static CreateSetWindowTarget(): DrawCommand =
        DrawCommand.SetWindowTarget()

    pattern SetWindowTarget(cmd: DrawCommand): () when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.SetWindowTarget)) =>
        let impl = UnsafeCast<DrawCommand.SetWindowTarget>(cmd)
        ()

    private sealed class SetRenderTarget =
        inherits DrawCommand

        RenderTarget: RenderTarget

        new(renderTarget: RenderTarget) =
            base(DrawCommandKind.SetRenderTarget) with
                {
                    RenderTarget = renderTarget
                }

    static CreateSetRenderTarget(renderTarget: RenderTarget): DrawCommand =
        DrawCommand.SetRenderTarget(renderTarget)

    pattern SetRenderTarget(cmd: DrawCommand): RenderTarget when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.SetRenderTarget)) =>
        let impl = UnsafeCast<DrawCommand.SetRenderTarget>(cmd)
        impl.RenderTarget

    private sealed class DrawMesh =
        inherits DrawCommand

        Mesh:      Mesh
        Shader:    Shader
        Instances: Instances

        new(mesh: Mesh, shader: Shader, instances: Instances) =
            base(DrawCommandKind.DrawMesh) with
                {
                    Mesh = mesh;
                    Shader = shader;
                    Instances = instances
                }

    static CreateDrawMesh(mesh: Mesh, shader: Shader, instances: Instances): DrawCommand =
        DrawCommand.DrawMesh(mesh, shader, instances)

    pattern DrawMesh(cmd: DrawCommand): (mesh: Mesh, shader: Shader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawMesh)) =>
        let impl = UnsafeCast<DrawCommand.DrawMesh>(cmd)
        (impl.Mesh, impl.Shader, impl.Instances)

    private sealed class RunComputeShader =
        inherits DrawCommand

        ComputeShader: ComputeShader
        Instances: Instances

        new(computeShader: ComputeShader, instances: Instances) =
            base(DrawCommandKind.RunComputeShader) with
                {
                    ComputeShader = computeShader
                    Instances = instances
                }

    static CreateRunComputeShader(computeShader: ComputeShader, instances: Instances): DrawCommand =
        DrawCommand.RunComputeShader(computeShader, instances)

    pattern RunComputeShader(cmd: DrawCommand): (computeShader: ComputeShader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.RunComputeShader)) =>
        let impl = UnsafeCast<DrawCommand.RunComputeShader>(cmd)
        (impl.ComputeShader, impl.Instances)

    private sealed class BindTextureSet =
        inherits DrawCommand

        TextureSet: ShaderTextureSet
        SetKind: BindResourceSetKind

        new(textureSet: ShaderTextureSet, kind: BindResourceSetKind) =
            base(DrawCommandKind.BindTextureSet) with
                {
                    TextureSet = textureSet
                    SetKind = kind
                }

    static CreateBindTextureSet(textureSet: ShaderTextureSet, kind: BindResourceSetKind): DrawCommand =
        DrawCommand.BindTextureSet(textureSet, kind)

    pattern BindTextureSet(cmd: DrawCommand): (ShaderTextureSet, BindResourceSetKind) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.BindTextureSet)) =>
        let impl = UnsafeCast<DrawCommand.BindTextureSet>(cmd)
        (impl.TextureSet, impl.SetKind)

    private sealed class BindInstancesSet =
        inherits DrawCommand

        InstancesSet: ShaderInstancesSet
        SetKind: BindResourceSetKind

        new(instancesSet: ShaderInstancesSet, kind: BindResourceSetKind) =
            base(DrawCommandKind.BindInstancesSet) with
                {
                    InstancesSet = instancesSet
                    SetKind = kind
                }

    static CreateBindInstancesSet(instancesSet: ShaderInstancesSet, kind: BindResourceSetKind): DrawCommand =
        DrawCommand.BindInstancesSet(instancesSet, kind)

    pattern BindInstancesSet(cmd: DrawCommand): (ShaderInstancesSet, BindResourceSetKind) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.BindInstancesSet)) =>
        let impl = UnsafeCast<DrawCommand.BindInstancesSet>(cmd)
        (impl.InstancesSet, impl.SetKind)

    private sealed class BindBufferSet =
        inherits DrawCommand

        BufferSet: BufferSet
        SetKind: BindResourceSetKind
        Slot: uint32

        new(BufferSet: BufferSet, kind: BindResourceSetKind, slot: uint32) =
            base(DrawCommandKind.BindBufferSet) with
                {
                    BufferSet = BufferSet
                    SetKind = kind
                    Slot = slot
                }

    static CreateBindBufferSet(BufferSet: BufferSet, kind: BindResourceSetKind, slot: uint32): DrawCommand =
        DrawCommand.BindBufferSet(BufferSet, kind, slot)

    pattern BindBufferSet(cmd: DrawCommand): (BufferSet, BindResourceSetKind, slot: uint32) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.BindBufferSet)) =>
        let impl = UnsafeCast<DrawCommand.BindBufferSet>(cmd)
        (impl.BufferSet, impl.SetKind, impl.Slot)

enum KeyEventKind =
    | Pressed
    | Released

alias KeyEvent = Veldrid.KeyEvent
alias Key = Veldrid.Key

alias MouseEvent = Veldrid.MouseEvent

sealed class InputState =
    KeyEvents: KeyEvent[||]
    MouseEvents: MouseEvent[||]
    mutable MousePosition: Vector2
    mutable MouseDelta: Vector2
    internal snapshot: InputSnapshot

    internal new(keyEvents: KeyEvent[||], mouseEvents: MouseEvent[||], snapshot: InputSnapshot) =
        {
            KeyEvents = keyEvents
            MouseEvents = mouseEvents
            MousePosition = Vector2.Zero
            MouseDelta = Vector2.Zero
            snapshot = snapshot
        }

sealed class Window =
    internal window: Sdl2Window

    internal new(x: int32, y: int32, width: int32, height: int32, title: string) =
        let windowCreateInfo = WindowCreateInfo(x, y, width, height, WindowState.Normal, title)
        let window = VeldridStartup.CreateWindow(windowCreateInfo)
        window.add_Moved(
            // We do this to re-create the swap-chain when the window moves.
            p ->
                Graphics.graphicsDevice.ResizeMainWindow(uint32(window.Width), uint32(window.Height))
        )
        {
            window = window
        }

    GetInputState(): InputState =
        let snapshot = this.window.PumpEvents()
        let keyEvents = System.Linq.Enumerable.ToArray<KeyEvent>(snapshot.KeyEvents)
        let mouseEvents = System.Linq.Enumerable.ToArray<MouseEvent>(snapshot.MouseEvents)
        let state = InputState(keyEvents, mouseEvents, snapshot)
        state.MousePosition <- snapshot.MousePosition
        state.MouseDelta <- this.window.MouseDelta
        state

    SetFullscreen(value: bool): () =
        if (value)
            this.window.WindowState <- WindowState.FullScreen
        else
            this.window.WindowState <- WindowState.Normal

    IsFullscreen: bool 
        get() = 
            fromEnum<WindowState>(this.window.WindowState) == fromEnum<WindowState>(WindowState.FullScreen)

    HideCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(true)
        this.window.CursorVisible <- false

    ShowCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(false)
        this.window.CursorVisible <- true

    IsCursorVisible: bool get() = this.window.CursorVisible

    internal SetSize(size: Vector2): () =
        this.window.Width <- int32(size.X)
        this.window.Height <- int32(size.Y)
        Graphics.graphicsDevice.ResizeMainWindow(uint32(size.X), uint32(size.Y)) // re-creates swap-chain
        Graphics.imGuiRenderer.WindowResized(this.window.Width, this.window.Height)

    Close(): () =
        this.window.Close()

    Exists: bool
        get() = this.window.Exists

sealed class DisplayMode =
    Width: uint32
    Height: uint32
    RefreshRate: uint32

    new(width: uint32, height: uint32, refreshRate: uint32) =
        {
            Width = width
            Height = height
            RefreshRate = refreshRate
        }

module Graphics =

    #[intrinsic("bitwise_or")]
    private (|)(ShaderStages, ShaderStages): ShaderStages

    private mutable window: Window = unchecked default
    internal mutable graphicsDevice: GraphicsDevice = null
    internal mutable imGuiRenderer: ImGuiRenderer = null
    private mutable factory: ResourceFactory = null
    private mutable commandList: CommandList = null

    private mutable globalUniformBuffer: DeviceBuffer = null
    private mutable globalResourceLayout: ResourceLayout = null
    private mutable globalResourceSet: ResourceSet = null
    
    private mutable instanceResourceLayout: ResourceLayout = null

    private mutable defaultResourceLayoutFragment: ResourceLayout = null
    private mutable depthResourceLayoutFragment: ResourceLayout = null

    private mutable pixelSampler: Sampler = null

    private mutable mainWindowRenderTarget: RenderTarget = unchecked default
    private mutable mainWindowRenderTargetCmds: DrawCommand[] = unchecked default
    private mutable mainWindowOutputs: OutputDescription = default
    private mutable mainWindowTextureSet: ShaderTextureSet = unchecked default

    DeviceName: string get() = graphicsDevice.DeviceName

    CreateWindow(x: int32, y: int32, width: int32, height: int32, title: string): Window =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window !== unchecked default)
            fail("Window already created.")

        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

        window <- Window(x, y, width, height, title)

        let mutable options = default: GraphicsDeviceOptions
        options.PreferStandardClipSpaceYDirection <- true
        options.PreferDepthRangeZeroToOne <- true  
#if DEBUG
        options.Debug <- true
#end   

        graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window.window, options, GraphicsBackend.Vulkan)
        factory <- graphicsDevice.ResourceFactory
        commandList <- factory.CreateCommandList()

        globalUniformBuffer <- createGlobalUniformBuffer(0)
        let globalResourceLayoutDesc =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Global", ResourceKind.UniformBuffer, ShaderStages.Vertex | ShaderStages.Fragment | ShaderStages.Compute)
                |]
            )
        globalResourceLayout <- factory.CreateResourceLayout(globalResourceLayoutDesc)
        globalResourceSet <- CreateResourceSet(globalResourceLayout, globalUniformBuffer)

        let instanceResourceLayoutDesc =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("InstanceData", ResourceKind.StructuredBufferReadOnly, ShaderStages.Vertex | ShaderStages.Compute)
                |]
            )
        instanceResourceLayout <- factory.CreateResourceLayout(instanceResourceLayoutDesc)

        let defaultResourceLayoutDescFragment =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Texture", ResourceKind.TextureReadOnly, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("Sampler", ResourceKind.Sampler, ShaderStages.Fragment)
                |]
            )
        defaultResourceLayoutFragment <- factory.CreateResourceLayout(defaultResourceLayoutDescFragment)

        let depthResourceLayoutDescFragment =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Texture", ResourceKind.TextureReadOnly, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("Sampler", ResourceKind.Sampler, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("DepthTexture", ResourceKind.TextureReadOnly, ShaderStages.Fragment)
                |]
            )
        depthResourceLayoutFragment <- factory.CreateResourceLayout(depthResourceLayoutDescFragment)

        let mutable pixelSamplerDesc = 
            SamplerDescription(
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerFilter.MinPoint_MagPoint_MipPoint,
                Nullable(ComparisonKind.LessEqual),
                1,
                0,
                10,
                0,
                SamplerBorderColor.TransparentBlack
            )
        pixelSampler <- factory.CreateSampler(pixelSamplerDesc)

        // ---------

        mainWindowRenderTarget <- CreateRenderTarget(uint32(width), uint32(height))
        mainWindowOutputs <- mainWindowRenderTarget.State.Framebuffer.OutputDescription
        mainWindowRenderTargetCmds <-
            let mesh = CreateMesh(MeshDescription.CreateQuad(1))
            let instances = CreateInstances([|Matrix4x4.Identity|])
            
            let desc = 
                ShaderDescription.CreateMeshShader(
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.vert")), 
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.frag"))
                )
            let shader = Graphics.CreateShader(desc, graphicsDevice.SwapchainFramebuffer.OutputDescription)

            let instancesSet = CreateShaderInstancesSet(instances)
            mainWindowTextureSet <- CreateShaderTextureSet(mainWindowRenderTarget)

            [
                DrawCommand.CreateBindInstancesSet(instancesSet, BindResourceSetKind.Graphics);
                DrawCommand.CreateBindTextureSet(mainWindowTextureSet, BindResourceSetKind.Graphics);
                DrawCommand.CreateDrawMesh(mesh, shader, instances)
            ]

        // ---------

        // -- ImGui Settings --
        let imGuiOutputDesc = mainWindowOutputs //graphicsDevice.SwapchainFramebuffer.OutputDescription
        imGuiRenderer <- ImGuiRenderer(graphicsDevice, imGuiOutputDesc, width, height, ColorSpaceHandling.Linear)
        //ImGuiNET.ImGui.StyleColorsClassic()
        // --

        Graphics.SetViewPort(Vector4(0, 0, float32(width), float32(height)))

        window

    #[StructLayout(LayoutKind.Sequential)]
    private struct VertexDatum =
        mutable Vertex: Vector3 = default
        mutable TexCoord: Vector2 = default
        mutable Normal: Vector3 = default

    CreateMesh(meshDesc: MeshDescription): Mesh =
        let vertices  = meshDesc.Vertices
        let indices   = meshDesc.Indices
        let normals   = meshDesc.Normals
        let texCoords = meshDesc.TexCoords
    
        let vertexCount = uint32(vertices.Length)
        let indexCount  = uint32(indices.Length)

        let vertexData =
            let vertexData = Array.ZeroCreate(int32(vertexCount))
            let mutable i = 0
            while (i < int32(vertexCount))
                vertexData[i] <- 
                    let mutable d = default: VertexDatum
                    d.Vertex <- vertices[i]
                    d.TexCoord <- texCoords[i]
                    d.Normal <- normals[i]
                    d
                i <- i + 1
            vertexData
    
        let vertexBuffer = factory.CreateBuffer(BufferDescription(vertexCount * uint32(sizeof<VertexDatum>), BufferUsage.VertexBuffer))
        let indexBuffer = factory.CreateBuffer(BufferDescription(indexCount * uint32(sizeof<uint32>), BufferUsage.IndexBuffer))
    
        graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertexData)
        graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)
    
        Mesh(vertexBuffer, indexBuffer, indexCount)

    CreateShaderInstancesSet(instances: Instances): ShaderInstancesSet =
        let resourceSet = CreateResourceSetForInstances(instances)
        ShaderInstancesSet(resourceSet)

    CreateShaderTextureSet(texture: Texture2D): ShaderTextureSet =
        let resourceSet = CreateResourceSetForTexture(texture, null)
        ShaderTextureSet(resourceSet)

    CreateShaderTextureSet(texture: Texture2D, depthTexture: Texture2D): ShaderTextureSet =
        let resourceSet = CreateResourceSetForTexture(texture, depthTexture)
        ShaderTextureSet(resourceSet)

    CreateShaderTextureSet(renderTarget: RenderTarget): ShaderTextureSet =
        let resourceSet = CreateResourceSetForTexture(renderTarget.State.Texture, renderTarget.State.DepthTexture)
        ShaderTextureSet(resourceSet)

    private CreateResourceSet(resourceLayout: ResourceLayout, bindableResource: BindableResource): ResourceSet =
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    bindableResource
                |]
            )
        factory.CreateResourceSet(resourceSetDesc)

    private CreateResourceSetForInstances(instances: Instances): ResourceSet =
        let resourceLayout =
            instanceResourceLayout

        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    (instances.InstanceBuffer: BindableResource)
                |]
            )
        factory.CreateResourceSet(resourceSetDesc)

    private CreateResourceSetForTexture(texture: Texture2D, depthTextureOption: Texture2D): ResourceSet =
        let resourceLayout = 
            if (depthTextureOption === null)
                defaultResourceLayoutFragment
            else
                depthResourceLayoutFragment
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                if (depthTextureOption === null)
                    [|
                        (texture.Texture: BindableResource);
                        pixelSampler
                    |]
                else
                    [|
                        (texture.Texture: BindableResource);
                        pixelSampler;
                        depthTextureOption.Texture
                    |]
            )
        factory.CreateResourceSet(resourceSetDesc)
    
    private CreateShaderState(shaderDesc: ShaderDescription, outputs: OutputDescription, useDepth: bool): ShaderState =
        let vertexLayouts      = shaderDesc.VertexLayouts
        let vertexShaderDesc   = shaderDesc.VertexShader
        let fragmentShaderDesc = shaderDesc.FragmentShader
    
        let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)
    
        let mutable pipelineDesc = default: GraphicsPipelineDescription
        pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend
    
        pipelineDesc.DepthStencilState <-
            let mutable desc = default: DepthStencilStateDescription
            desc.DepthTestEnabled <- true
            desc.DepthWriteEnabled <- true
            desc.DepthComparison <- ComparisonKind.LessEqual
            desc
    
        pipelineDesc.RasterizerState <-
            let mutable desc = default: RasterizerStateDescription
            desc.CullMode <- FaceCullMode.Back
            desc.FillMode <- PolygonFillMode.Solid
            desc.FrontFace <- FrontFace.CounterClockwise
            desc.DepthClipEnabled <- true
            desc.ScissorTestEnabled <- false
            desc
    
        pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleList

        pipelineDesc.ShaderSet <-
            let mutable desc = default: ShaderSetDescription
            desc.VertexLayouts <- vertexLayouts
            desc.Shaders <- shaders
            desc

        let fragmentResourceLayout =
            if (useDepth)
                depthResourceLayoutFragment
            else
                defaultResourceLayoutFragment
    
        pipelineDesc.ResourceLayouts <-
            [|
                globalResourceLayout;
                instanceResourceLayout;
                fragmentResourceLayout
            |]
        pipelineDesc.Outputs <- outputs
        let pipeline = factory.CreateGraphicsPipeline(pipelineDesc)
    
        ShaderState(shaders[0], shaders[1], pipeline)

    private CreateComputeShaderState(shaderDesc: ComputeShaderDescription): ComputeShaderState =
        let computeShaderDesc = shaderDesc.ComputeShader
    
        let shader = ResourceFactoryExtensions.CreateFromSpirv(factory, computeShaderDesc)
    
        let pipelineDesc = 
            ComputePipelineDescription(
                shader, 
                [|globalResourceLayout;instanceResourceLayout|], 
                1, 
                1, 
                1
            )

        let pipeline = factory.CreateComputePipeline(pipelineDesc)
    
        ComputeShaderState(shader, pipeline)

    CreateShader(shaderDesc: ShaderDescription, useDepth: bool): Shader =
        Shader(CreateShaderState(shaderDesc, mainWindowOutputs, useDepth))

    internal CreateShader(shaderDesc: ShaderDescription, outputs: OutputDescription): Shader =
        Shader(CreateShaderState(shaderDesc, outputs, true))

    CreateComputeShader(computeShaderDesc: ComputeShaderDescription): ComputeShader =
        ComputeShader(CreateComputeShaderState(computeShaderDesc))

    // UpdateShader(shader: Shader, texture2d: Texture2D, shaderDesc: ShaderDescription, instances: Instances): () =
    //     let newState = CreateShaderState(shaderDesc, texture2d, instances, mainWindowOutputs)
    //     let oldState = Interlocked.Exchange(&shader.State, newState)
    //     oldState.Pipeline.Dispose()
    //     oldState.FragmentShader.Dispose()
    //     oldState.VertexShader.Dispose()

    CreateTexture2D(filePath: string): Texture2D =
        let image = Veldrid.ImageSharp.ImageSharpTexture(filePath)
        let texture = image.CreateDeviceTexture(graphicsDevice, factory)
        Texture2D(texture)
        // let image = Image.Load<Rgba32>(System.IO.File.ReadAllBytes(filePath))
        // let width = uint32(image.Width)
        // let height = uint32(image.Height)

        // let mutable pixels = unchecked default: Memory<Rgba32>
        // let mutable result = AdvancedImageExtensions.GetPixelRowMemory(image, 0)
        // let sizeInBytes = width * height * 4

        // let mutable desc = default: TextureDescription
        // desc.Width <- width
        // desc.Height <- height
        // desc.Depth <- 1
        // desc.SampleCount <- TextureSampleCount.Count1
        // desc.Format <- PixelFormat.R8_G8_B8_A8_UNorm
        // desc.Type <- TextureType.Texture2D
        // desc.Usage <- TextureUsage.Sampled
        // desc.MipLevels <- 1
        // desc.ArrayLayers <- 1

        // let texture = factory.CreateTexture(desc)

        // let mutable sourceHandle = result.Pin()
        // let source = nint(sourceHandle.Pointer)

        // graphicsDevice.UpdateTexture(texture, source, sizeInBytes, 0, 0, 0, width, height, 1, 0, 0)
        // sourceHandle.Dispose()

        // Texture2D(texture)

    CreateBuffer<T>(buffer: T[||], index: uint32, count: uint32): Buffer<T> where T: unmanaged =
        let size = uint32(sizeof<T>) * count
        let deviceBuffer = factory.CreateBuffer(BufferDescription(size, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))

        graphicsDevice.UpdateBuffer(deviceBuffer, 0, buffer)

        Buffer<T>(deviceBuffer)

    CreateBufferSet<T>(buffer: Buffer<T>): BufferSet where T: unmanaged =
        let resourceLayoutDesc =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Buffer", ResourceKind.UniformBuffer, ShaderStages.Vertex | ShaderStages.Fragment | ShaderStages.Compute)
                |]
            )
        let resourceLayout = factory.CreateResourceLayout(resourceLayoutDesc)
        let resourceSet = CreateResourceSet(resourceLayout, buffer.DeviceBuffer)
        BufferSet(resourceLayout, resourceSet)

    private CreateRenderTargetState(width: uint32, height: uint32, useDepth: bool): RenderTargetState =
        let depthTexture =
            if (useDepth)
                let usages = toEnum<TextureUsage>(fromEnum(TextureUsage.DepthStencil) | fromEnum(TextureUsage.Sampled))
                factory.CreateTexture(
                    TextureDescription.Texture2D(width, height, 1, 1, PixelFormat.R16_UNorm, usages)
                )
            else
                null
        let usages = toEnum<TextureUsage>(fromEnum(TextureUsage.RenderTarget) | fromEnum(TextureUsage.Sampled))
        let colorTexture = 
            factory.CreateTexture(
                TextureDescription.Texture2D(width, height, 1, 1, PixelFormat.R32_G32_B32_A32_Float, usages)
            )
        let desc = FramebufferDescription(depthTexture, [|colorTexture|])
        let framebuffer = factory.CreateFramebuffer(desc)
        let depthTexture =
            if (depthTexture === null)
                null: Texture2D
            else
                Texture2D(depthTexture)
        RenderTargetState(framebuffer, Texture2D(colorTexture), depthTexture)

    CreateRenderTarget(width: uint32, height: uint32): RenderTarget =
        RenderTarget(CreateRenderTargetState(width, height, true))

    private createGlobalUniformBuffer(slot: uint32): DeviceBuffer =
        factory.CreateBuffer(BufferDescription(1024, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))

    UpdateRenderTarget(width: uint32, height: uint32, renderTarget: RenderTarget): () =
        let oldRenderTargetState = renderTarget.State
        renderTarget.State <- CreateRenderTargetState(width, height, true)
        DisposeQueue.Enqueue(oldRenderTargetState)

    UpdateTextureSet(renderTarget: RenderTarget, textureSet: ShaderTextureSet): () =
        let oldResourceSet = textureSet.ResourceSet
        textureSet.ResourceSet <- CreateResourceSetForTexture(renderTarget.State.Texture, renderTarget.State.DepthTexture)
        DisposeQueue.Enqueue(oldResourceSet)

    SetView(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 0, value)

    SetProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 64, value)

    SetNormalMatrix(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 128, value)

    SetPreviousView(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 192, value)

    SetPreviousViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 256, value)

    SetInverseViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 320, value)

    private SetViewPort(value: Vector4): () =
        // clamp
        let value = Vector4(float32(int32(value.X)), float32(int32(value.Y)), float32(uint32(value.Z)), float32(uint32(value.W)))

        graphicsDevice.UpdateBuffer(globalUniformBuffer, 384, value)

        UpdateRenderTarget(uint32(value.Z), uint32(value.W), mainWindowRenderTarget)
        UpdateTextureSet(mainWindowRenderTarget, mainWindowTextureSet)

    SetDeltaTime(value: float32): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 400, value)

    CreateInstances<T>(instanceData: T[||]): Instances where T: unmanaged =
        let usage: BufferUsage = BufferUsage.StructuredBufferReadWrite
        let instanceBuffer = factory.CreateBuffer(BufferDescription(uint32(instanceData.Length * sizeof<T>), usage, uint32(instanceData.Length * sizeof<T>)))
        graphicsDevice.UpdateBuffer(instanceBuffer, 0, instanceData)

        let instances = Instances(instanceBuffer)
        instances.Count <- instanceData.Length
        instances

    UpdateInstances<T>(instances: Instances, instanceData: T[||]): () where T: unmanaged =
        graphicsDevice.UpdateBuffer(instances.InstanceBuffer, 0, instanceData)

    private bindBufferSetCmds: System.Collections.Generic.Queue<DrawCommand> = System.Collections.Generic.Queue()
    private processBufferSetCmds(commandList: CommandList): () =
        let mutable cmd = unchecked default
        while (bindBufferSetCmds.TryDequeue(&cmd))
            match (cmd)
            | DrawCommand.BindBufferSet(bufferSet, setKind, slot) =>
                if (slot < 8)
                    fail("Binding a buffer set requires a slot greater than or equal to '8'.")
                if (slot >= 16)
                    fail("Binding a buffer set to a slot greater than '16' is not supported.")
                match (setKind)
                | BindResourceSetKind.Graphics =>
                    commandList.SetGraphicsResourceSet(slot, bufferSet.ResourceSet)
                | BindResourceSetKind.Compute =>
                    commandList.SetComputeResourceSet(slot, bufferSet.ResourceSet)
                | _ =>
                    fail("Invalid 'BindResourceSetKind'.")
            | _ =>
                ()

    internal DisposeQueue: ConcurrentQueue<IDisposable> = ConcurrentQueue()
    Draw(drawCmds: DrawCommand[]): () =
        let mutable disposable = default
        while (DisposeQueue.TryDequeue(&disposable))
            disposable.Dispose()

        // Begin() must be called before commands can be issued
        commandList.Begin()
    
        let mutable currentPipeline = unchecked default
        let mutable currentFramebuffer = unchecked default: Framebuffer

        let hasFramebuffer() = currentFramebuffer !== unchecked default

        let mutable currentTextureSet = unchecked default
        let mutable currentTextureSetKind = unchecked default
        let mutable currentInstancesSet = unchecked default
        let mutable currentInstancesSetKind = unchecked default

        let bindTextureSet() =
            if (currentTextureSet === unchecked default)
                fail("Texture set not bound.")
            match (currentTextureSetKind)
            | BindResourceSetKind.Graphics =>
                commandList.SetGraphicsResourceSet(2, currentTextureSet)
            | BindResourceSetKind.Compute =>
                commandList.SetComputeResourceSet(2, currentTextureSet)
            | _ =>
                fail("Invalid 'BindResourceSetKind'.")

        let bindInstancesSet() =
            if (currentInstancesSet === unchecked default)
                fail("Texture set not bound.")
            match (currentInstancesSetKind)
            | BindResourceSetKind.Graphics =>
                commandList.SetGraphicsResourceSet(1, currentInstancesSet)
            | BindResourceSetKind.Compute =>
                commandList.SetComputeResourceSet(1, currentInstancesSet)
            | _ =>
                fail("Invalid 'BindResourceSetKind'.")

        let handle(drawCmd) =
            match (drawCmd)
            | DrawCommand.BindBufferSet(_, _, _) =>
                bindBufferSetCmds.Enqueue(drawCmd)

            | DrawCommand.BindTextureSet(textureSet, kind) =>
                currentTextureSet <- textureSet.ResourceSet
                currentTextureSetKind <- kind

            | DrawCommand.BindInstancesSet(instancesSet, kind) =>
                currentInstancesSet <- instancesSet.ResourceSet
                currentInstancesSetKind <- kind

            | DrawCommand.RunComputeShader(computeShader, instances) =>
                let pipeline = computeShader.State.Pipeline
                if (pipeline !== currentPipeline)
                    commandList.SetPipeline(pipeline)
                    commandList.SetComputeResourceSet(0, globalResourceSet)
                    currentPipeline <- pipeline

                bindInstancesSet()
                processBufferSetCmds(commandList)

                commandList.Dispatch(uint32(instances.Count), 1, 1)

            | DrawCommand.SetWindowTarget =>
                currentFramebuffer <- mainWindowRenderTarget.State.Framebuffer

                // We want to render directly to the output window.
                commandList.SetFramebuffer(currentFramebuffer)
                commandList.ClearColorTarget(0, RgbaFloat.Black)
                commandList.ClearDepthStencil(1)

            | DrawCommand.SetRenderTarget(renderTarget) =>
                currentFramebuffer <- renderTarget.State.Framebuffer

                commandList.SetFramebuffer(currentFramebuffer)
                commandList.ClearColorTarget(0, RgbaFloat.Black)
                commandList.ClearDepthStencil(1)

            | DrawCommand.DrawMesh(mesh, shader, instances) when (hasFramebuffer()) =>
                let instanceCount = uint32(instances.Count)

                if (instanceCount > 0)   
                    let pipeline = shader.State.Pipeline
                    if (pipeline !== currentPipeline)
                        commandList.SetPipeline(pipeline)
                        commandList.SetGraphicsResourceSet(0, globalResourceSet)
                        currentPipeline <- pipeline

                    bindInstancesSet()
                    bindTextureSet()
                    processBufferSetCmds(commandList)

                    let vertexBuffer = mesh.VertexBuffer
                    let indexBuffer  = mesh.IndexBuffer
                    let indexCount   = mesh.IndexCount

                    commandList.SetVertexBuffer(0, vertexBuffer)
                    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt32)
            
                    commandList.DrawIndexed(
                        indexCount,     /* indexCount */
                        instanceCount,  /* instanceCount */
                        0,              /* indexStart */
                        0,              /* vertexOffset */
                        0               /* instanceStart */
                    )

            | _ =>
                ()

        let mutable i = 0
        let length = drawCmds.Length
        while (i < length)
            handle(drawCmds[i])
            i <- i + 1

        // Draw UI
        imGuiRenderer.Render(graphicsDevice, commandList)

        // Swap-chain frame
        commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
        commandList.ClearColorTarget(0, RgbaFloat.Black)
        let mutable i = 0
        while (i < mainWindowRenderTargetCmds.Length)
            handle(mainWindowRenderTargetCmds[i])
            i <- i + 1

        // End() must be called before commands can be submitted for execution.
        commandList.End()
        graphicsDevice.SubmitCommands(commandList)

        // Once commands have been submitted, the rendered image can be presented to the application window.
        graphicsDevice.SwapBuffers()

    DestroyWindow(): () =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window === unchecked default)
            fail("Window not created. Unable to destroy window.")

        window.Close()
        window <- unchecked default
        commandList.Dispose()
        graphicsDevice.Dispose()

    Wait(): () =
        graphicsDevice.WaitForIdle()

    SetVSync(enabled: bool): () =
        graphicsDevice.SyncToVerticalBlank <- enabled

    #[import("C", "Sdl2.dll", "SDL_GetNumDisplayModes")]
    private SDL_GetNumDisplayModes(displayIndex: int32): int32

    #[import("C", "Sdl2.dll", "SDL_GetDisplayMode")]
    private SDL_GetDisplayMode(displayIndex: int32, modeIndex: int32, mode: byref<SDL_DisplayMode>): int32

    #[import("C", "Sdl2.dll", "SDL_GetWindowDisplayMode")]
    private SDL_GetWindowDisplayMode(window: nint, mode: byref<SDL_DisplayMode>): int32

    #[import("C", "Sdl2.dll", "SDL_SetWindowDisplayMode")]
    private SDL_SetWindowDisplayMode(window: nint, mode: inref<SDL_DisplayMode>): int32

    GetDisplayModes(): DisplayMode[] =
        let displayModes = System.Collections.Generic.List<DisplayMode>()

        let displayCount = Sdl2Native.SDL_GetNumVideoDisplays()

        let mutable i = 0
        while (i < displayCount)
            let displayModeCount = SDL_GetNumDisplayModes(i)

            let mutable j = 0
            while (j < displayModeCount)
                let mutable mode = default
                let result = SDL_GetDisplayMode(i, j, &mode)

                match (UnsafeCast<PixelFormat>(mode.format))
                | PixelFormat.R32_G32_B32_A32_Float =>
                    displayModes.Add(DisplayMode(uint32(mode.w), uint32(mode.h), uint32(mode.refresh_rate)))
                | _ =>
                    ()
                j <- j + 1
            i <- i + 1

        UnsafeCast<_[]>(displayModes.ToArray())

    GetCurrentDisplayModeIndex(): int32 =
        let displayIndex = Sdl2Native.SDL_GetWindowDisplayIndex(SDL_Window(window.window.SdlWindowHandle))

        let mutable sdlDisplayMode = default
        let result = SDL_GetWindowDisplayMode(window.window.SdlWindowHandle, &sdlDisplayMode)

        let displayCount = Sdl2Native.SDL_GetNumVideoDisplays()

        let mutable displayModeIndex = -1

        let mutable count = 0

        let mutable i = 0
        while (i < displayCount)
            let displayModeCount = SDL_GetNumDisplayModes(i)

            let mutable j = 0
            while (j < displayModeCount)
                let mutable mode = default
                let result = SDL_GetDisplayMode(i, j, &mode)

                match (UnsafeCast<PixelFormat>(mode.format))
                | PixelFormat.R32_G32_B32_A32_Float =>
                    if (i == displayIndex && 
                            (sdlDisplayMode.w == mode.w) && 
                                (sdlDisplayMode.h == mode.h) && 
                                    (sdlDisplayMode.refresh_rate == mode.refresh_rate) && 
                                        (sdlDisplayMode.format == mode.format))
                        displayModeIndex <- count
                    count <- count + 1
                | _ =>
                    ()
                j <- j + 1
            i <- i + 1

        if (displayModeIndex == -1)
            fail("Unable to get current display mode.")

        displayModeIndex

    SetDisplayMode(displayMode: DisplayMode): () =
        let mutable sdl2DisplayMode = default: SDL_DisplayMode

        sdl2DisplayMode.format <- UnsafeCast(PixelFormat.R32_G32_B32_A32_Float)
        sdl2DisplayMode.w <- int32(displayMode.Width)
        sdl2DisplayMode.h <- int32(displayMode.Height)
        sdl2DisplayMode.refresh_rate <- int32(displayMode.RefreshRate)

        let result = SDL_SetWindowDisplayMode(window.window.SdlWindowHandle, &sdl2DisplayMode)
        if (result != 0)
            fail("Window display error.")
        
        SetViewPort(Vector4(0, 0, float32(displayMode.Width), float32(displayMode.Height)))
        window.SetSize(Vector2(float32(displayMode.Width), float32(displayMode.Height)))
