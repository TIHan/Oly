#target "dotnet: net7"
#library

#load "*.oly"

#reference "../../../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"
#package "Veldrid.ImGui,5.89.2-ga121087cad"
#package "Veldrid.ImageSharp,4.9.0"

namespace Evergreen.Graphics

open System
open System.Text
open System.Numerics
open System.Threading
open System.Collections.Concurrent
open System.Runtime.InteropServices
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV
open ImGuiNET
open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias VeldridShaderDescription = Veldrid.ShaderDescription
private alias VeldridShader = Veldrid.Shader

sealed class MeshDescription =
    mutable Vertices:   Vector3[||]
    mutable Indices:    uint32[||]
    mutable Normals:    Vector3[||]
    mutable TexCoords:  Vector2[||]

    new(vertices: Vector3[||], indices: uint32[||], normals: Vector3[||], texCoords: Vector2[||]) =
        {
            Vertices = vertices;
            Indices = indices;
            Normals = normals;
            TexCoords = texCoords
        }

    static CreateQuad(scale: float32): MeshDescription =
        let vertices =
            [|
                Vector3(-scale, -scale,  scale);
                Vector3(scale, -scale,  scale);
                Vector3(scale,  scale,  scale);
                Vector3(-scale,  scale,  scale)
            |]

        let normals =
            [|
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1)
            |]

        let texCoords =
            [|
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0)
            |]

        let indices =
            [|
                0;  1;  2;
                2;  3;  0: uint32
            |]
        
        MeshDescription(
            vertices, 
            indices,
            normals,
            texCoords
        )

    static CreateQuad(): MeshDescription =
        MeshDescription.CreateQuad(0.5)

    static CreateCube(): MeshDescription =
        let vertices =
            [|
                // front
                Vector3(-0.5, -0.5,  0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                // top
                Vector3(-0.5,  0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                // back
                Vector3(0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                // bottom
                Vector3(-0.5, -0.5, -0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(-0.5, -0.5,  0.5);
                // left
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5, -0.5);
                // right
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(0.5,  0.5,  0.5)
            |]

        let normals =
            [|
                // front
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                // top
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                // back
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                // bottom
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                // left
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                // right
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0)
            |]

        // let texCoords =
        //     [|
        //         // front
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // top
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // back
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // bottom
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // left
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0);
        //         // right
        //         Vector2(0.0, 0.0);
        //         Vector2(1.0, 0.0);
        //         Vector2(1.0, 1.0);
        //         Vector2(0.0, 1.0)
        //     |]
        let texCoords =
            [|
                // front
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // top
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                // back
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                // bottom
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // left
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                // right
                Vector2(0.0, 1.0);
                Vector2(0.0, 0.0);
                Vector2(-1.0, 0.0);
                Vector2(-1.0, 1.0)
            |]

        let indices =
            [|
                // front
                0;  1;  2;
                2;  3;  0: uint32;
                // top
                4;  5;  6;
                6;  7;  4: uint32;
                // back
                8;  9; 10;
                10; 11;  8;
                // bottom
                12; 13; 14;
                14; 15; 12;
                // left
                16; 17; 18;
                18; 19; 16: uint32;
                // right
                20; 21; 22;
                22; 23; 20: uint32
            |]
        
        MeshDescription(
            vertices, 
            indices,
            normals,
            texCoords
        )

sealed class ShaderDescription =
    internal mutable VertexLayouts:  VertexLayoutDescription[||]
    internal mutable VertexShader:   VeldridShaderDescription
    internal mutable FragmentShader: VeldridShaderDescription

    private new(vertexLayouts: VertexLayoutDescription[||], vertexShader: VeldridShaderDescription, fragmentShader: VeldridShaderDescription) =
        {
            VertexLayouts = vertexLayouts;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static CreateMeshShader(vertexShaderBytes: byte[||], fragmentShaderBytes: byte[||]): ShaderDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3);
                    VertexElementDescription("TexCoord", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float2);
                    VertexElementDescription("Normal", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3)
                |]
            )
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                vertexShaderBytes,
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                fragmentShaderBytes,
                "main"
            )

        ShaderDescription([|vertexLayout|], vertexShader, fragmentShader)

sealed class ComputeShaderDescription =
    internal mutable ComputeShader: VeldridShaderDescription

    private new(computeShader: VeldridShaderDescription) =
        {
            ComputeShader = computeShader
        }

    static CreateMeshLayout(computeShaderBytes: byte[||]): ComputeShaderDescription =
        let computeShader =
            ShaderDescription(
                ShaderStages.Compute,
                computeShaderBytes,
                "main"
            )

        ComputeShaderDescription(computeShader)

sealed class Mesh =
    implements IDisposable

    internal VertexBuffer:   DeviceBuffer
    internal IndexBuffer:    DeviceBuffer
    internal IndexCount:     uint32

    internal new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer, indexCount: uint32) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer;
            IndexCount = indexCount
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

#[null]
sealed class Texture2D =
    implements IDisposable

    internal Texture: Texture

    internal new(texture: Texture) =
        {
            Texture = texture
        }

    Dispose(): () =
        this.Texture.Dispose()

private sealed class RenderTargetState =
    implements IDisposable

    Framebuffer: Framebuffer
    Texture: Texture2D

    /// This can be null.
    DepthTexture: Texture2D

    internal new(framebuffer: Framebuffer, texture: Texture2D, depthTexture: Texture2D) =
        {
            Framebuffer = framebuffer
            Texture = texture
            DepthTexture = depthTexture
        }

    Dispose(): () =
        this.Framebuffer.Dispose()
        this.Texture.Dispose()

sealed class RenderTarget =
    implements IDisposable

    internal mutable State: RenderTargetState

    internal new(state: RenderTargetState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.Dispose()

sealed class Instances =
    implements IDisposable

    mutable Count: int32
    internal mutable InstanceBuffer: DeviceBuffer

    internal new(instanceBuffer: DeviceBuffer) =
        {
            Count = 0
            InstanceBuffer = instanceBuffer
        }

    Dispose(): () =
        this.InstanceBuffer.Dispose()

private sealed class ShaderState =
    internal VertexShader:   VeldridShader
    internal FragmentShader: VeldridShader
    internal ResourceSets:    ResourceSet[||]
    internal Pipeline:       Pipeline

    internal new(vertexShader: VeldridShader, fragmentShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

private sealed class ComputeShaderState =
    internal ComputeShader: VeldridShader
    internal ResourceSets:   ResourceSet[||]
    internal Pipeline:      Pipeline

    internal new(computeShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            ComputeShader = computeShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

sealed class Shader =
    implements IDisposable

    internal mutable State: ShaderState

    internal new(state: ShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.VertexShader.Dispose()
        this.State.FragmentShader.Dispose()
        let mutable i = 1
        while (i < this.State.ResourceSets.Length)
            this.State.ResourceSets[i].Dispose()
            i <- i + 1
        this.State.Pipeline.Dispose()

sealed class ComputeShader =
    implements IDisposable

    internal mutable State: ComputeShaderState

    internal new(state: ComputeShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.ComputeShader.Dispose()

enum DrawCommandKind =
    | SetWindowTarget
    | SetRenderTarget
    | DrawMesh
    | DrawUI
    | RunComputeShader
    | SetTexture0

class DrawCommand =
    Kind: DrawCommandKind

    new(kind: DrawCommandKind) =
        {
            Kind = kind
        }

    private sealed class SetWindowTarget =
        inherits DrawCommand

        new() =
            base(DrawCommandKind.SetWindowTarget) with
                {
                }

    static CreateSetWindowTarget(): DrawCommand =
        DrawCommand.SetWindowTarget()

    pattern SetWindowTarget(cmd: DrawCommand): () when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.SetWindowTarget)) =>
        let impl = UnsafeCast<DrawCommand.SetWindowTarget>(cmd)
        ()

    private sealed class SetRenderTarget =
        inherits DrawCommand

        RenderTarget: RenderTarget

        new(renderTarget: RenderTarget) =
            base(DrawCommandKind.SetRenderTarget) with
                {
                    RenderTarget = renderTarget
                }

    static CreateSetRenderTarget(renderTarget: RenderTarget): DrawCommand =
        DrawCommand.SetRenderTarget(renderTarget)

    pattern SetRenderTarget(cmd: DrawCommand): RenderTarget when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.SetRenderTarget)) =>
        let impl = UnsafeCast<DrawCommand.SetRenderTarget>(cmd)
        impl.RenderTarget

    private sealed class DrawMesh =
        inherits DrawCommand

        Mesh:      Mesh
        Shader:    Shader
        Instances: Instances

        new(mesh: Mesh, shader: Shader, instances: Instances) =
            base(DrawCommandKind.DrawMesh) with
                {
                    Mesh = mesh;
                    Shader = shader;
                    Instances = instances
                }

    static CreateDrawMesh(mesh: Mesh, shader: Shader, instances: Instances): DrawCommand =
        DrawCommand.DrawMesh(mesh, shader, instances)

    pattern DrawMesh(cmd: DrawCommand): (mesh: Mesh, shader: Shader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawMesh)) =>
        let impl = UnsafeCast<DrawCommand.DrawMesh>(cmd)
        (impl.Mesh, impl.Shader, impl.Instances)

    private sealed class DrawUI =
        inherits DrawCommand

        new() =
            base(DrawCommandKind.DrawUI) with
                {
                }

    static CreateDrawUI(): DrawCommand =
        DrawCommand.DrawUI()

    pattern DrawUI(cmd: DrawCommand): () when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawUI)) =>
        let impl = UnsafeCast<DrawCommand.DrawUI>(cmd)
        ()

    private sealed class RunComputeShader =
        inherits DrawCommand

        ComputeShader: ComputeShader
        Instances: Instances

        new(computeShader: ComputeShader, instances: Instances) =
            base(DrawCommandKind.RunComputeShader) with
                {
                    ComputeShader = computeShader
                    Instances = instances
                }

    static CreateRunComputeShader(computeShader: ComputeShader, instances: Instances): DrawCommand =
        DrawCommand.RunComputeShader(computeShader, instances)

    pattern RunComputeShader(cmd: DrawCommand): (computeShader: ComputeShader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.RunComputeShader)) =>
        let impl = UnsafeCast<DrawCommand.RunComputeShader>(cmd)
        (impl.ComputeShader, impl.Instances)

enum KeyEventKind =
    | Pressed
    | Released

alias KeyEvent = Veldrid.KeyEvent
alias Key = Veldrid.Key

alias MouseEvent = Veldrid.MouseEvent

sealed class InputState =
    KeyEvents: KeyEvent[||]
    MouseEvents: MouseEvent[||]
    mutable MousePosition: Vector2
    mutable MouseDelta: Vector2
    internal snapshot: InputSnapshot

    internal new(keyEvents: KeyEvent[||], mouseEvents: MouseEvent[||], snapshot: InputSnapshot) =
        {
            KeyEvents = keyEvents
            MouseEvents = mouseEvents
            MousePosition = Vector2.Zero
            MouseDelta = Vector2.Zero
            snapshot = snapshot
        }

sealed class Window =
    internal window: Sdl2Window

    internal new(x: int32, y: int32, width: int32, height: int32, title: string) =
        let windowCreateInfo = WindowCreateInfo(x, y, width, height, WindowState.Normal, title)
        let window = VeldridStartup.CreateWindow(windowCreateInfo)
        {
            window = window
        }

    GetInputState(): InputState =
        let snapshot = this.window.PumpEvents()
        let keyEvents = System.Linq.Enumerable.ToArray<KeyEvent>(snapshot.KeyEvents)
        let mouseEvents = System.Linq.Enumerable.ToArray<MouseEvent>(snapshot.MouseEvents)
        let state = InputState(keyEvents, mouseEvents, snapshot)
        state.MousePosition <- snapshot.MousePosition
        state.MouseDelta <- this.window.MouseDelta
        state

    SetFullscreen(value: bool): () =
        if (value)
            this.window.WindowState <- WindowState.FullScreen
        else
            this.window.WindowState <- WindowState.Normal

    IsFullscreen: bool 
        get() = 
            fromEnum<WindowState>(this.window.WindowState) == fromEnum<WindowState>(WindowState.FullScreen)

    HideCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(true)
        this.window.CursorVisible <- false

    ShowCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(false)
        this.window.CursorVisible <- true

    IsCursorVisible: bool get() = this.window.CursorVisible

    SetSize(size: Vector2): () =
        this.window.Width <- int32(size.X)
        this.window.Height <- int32(size.Y)

    Close(): () =
        this.window.Close()

    Exists: bool
        get() = this.window.Exists

module Graphics =

    #[intrinsic("bitwise_or")]
    private (|)(ShaderStages, ShaderStages): ShaderStages

    private mutable window: Window = unchecked default
    private mutable graphicsDevice: GraphicsDevice = null
    internal mutable imGuiRenderer: ImGuiRenderer = null
    private mutable factory: ResourceFactory = null
    private mutable commandList: CommandList = null

    private mutable globalUniformBuffer: DeviceBuffer = null
    private mutable globalResourceLayoutVertex: ResourceLayout = null
    private mutable globalResourceLayoutCompute: ResourceLayout = null
    private mutable globalResourceSetVertex: ResourceSet = null
    private mutable globalResourceSetCompute: ResourceSet = null
    
    private mutable instanceResourceLayoutVertex: ResourceLayout = null
    private mutable instanceResourceLayoutCompute: ResourceLayout = null

    private mutable defaultResourceLayoutFragment: ResourceLayout = null
    private mutable depthResourceLayoutFragment: ResourceLayout = null

    private mutable pixelSampler: Sampler = null

    private mutable mainWindowRenderTarget: RenderTarget = unchecked default
    private mutable mainWindowRenderTargetCmd: DrawCommand = unchecked default
    private mutable mainWindowOutputs: OutputDescription = default

    DeviceName: string get() = graphicsDevice.DeviceName

    CreateWindow(x: int32, y: int32, width: int32, height: int32, title: string): Window =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window !== unchecked default)
            fail("Window already created.")

        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

        window <- Window(x, y, width, height, title)

        let mutable options = default: GraphicsDeviceOptions
        options.PreferStandardClipSpaceYDirection <- true
        options.PreferDepthRangeZeroToOne <- true  
#if DEBUG
        options.Debug <- true
#end   

        graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window.window, options, GraphicsBackend.Vulkan)
        factory <- graphicsDevice.ResourceFactory
        commandList <- factory.CreateCommandList()

        globalUniformBuffer <- createGlobalUniformBuffer(0)
        let globalResourceLayoutDescVertex =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Global", ResourceKind.UniformBuffer, ShaderStages.Vertex | ShaderStages.Fragment)
                |]
            )
        globalResourceLayoutVertex <- factory.CreateResourceLayout(globalResourceLayoutDescVertex)
        globalResourceSetVertex <- CreateResourceSet(globalResourceLayoutVertex, globalUniformBuffer)
        let globalResourceLayoutDescCompute =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Global", ResourceKind.UniformBuffer, ShaderStages.Compute)
                |]
            )
        globalResourceLayoutCompute <- factory.CreateResourceLayout(globalResourceLayoutDescCompute)
        globalResourceSetCompute <- CreateResourceSet(globalResourceLayoutCompute, globalUniformBuffer)
        let instanceResourceLayoutDescVertex =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("InstanceData", ResourceKind.StructuredBufferReadOnly, ShaderStages.Vertex)
                |]
            )
        instanceResourceLayoutVertex <- factory.CreateResourceLayout(instanceResourceLayoutDescVertex)
        let instanceResourceLayoutDescCompute =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("InstanceData", ResourceKind.StructuredBufferReadWrite, ShaderStages.Compute)
                |]
            )
        instanceResourceLayoutCompute <- factory.CreateResourceLayout(instanceResourceLayoutDescCompute)

        let defaultResourceLayoutDescFragment =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Texture", ResourceKind.TextureReadOnly, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("Sampler", ResourceKind.Sampler, ShaderStages.Fragment)
                |]
            )
        defaultResourceLayoutFragment <- factory.CreateResourceLayout(defaultResourceLayoutDescFragment)

        let depthResourceLayoutDescFragment =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Texture", ResourceKind.TextureReadOnly, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("Sampler", ResourceKind.Sampler, ShaderStages.Fragment);
                    ResourceLayoutElementDescription("DepthTexture", ResourceKind.TextureReadOnly, ShaderStages.Fragment)
                |]
            )
        depthResourceLayoutFragment <- factory.CreateResourceLayout(depthResourceLayoutDescFragment)

        let mutable pixelSamplerDesc = 
            SamplerDescription(
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerFilter.MinPoint_MagPoint_MipPoint,
                Nullable(ComparisonKind.LessEqual),
                1,
                0,
                10,
                0,
                SamplerBorderColor.TransparentBlack
            )
        pixelSampler <- factory.CreateSampler(pixelSamplerDesc)

        // ---------

        mainWindowRenderTarget <- CreateRenderTarget(uint32(width), uint32(height))
        mainWindowOutputs <- mainWindowRenderTarget.State.Framebuffer.OutputDescription
        mainWindowRenderTargetCmd <-
            let mesh = CreateMesh(MeshDescription.CreateQuad(1))
            let instances = CreateInstances([|Matrix4x4.Identity|])
            let desc = 
                ShaderDescription.CreateMeshShader(
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.vert")), 
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.frag"))
                )
            let shader = Graphics.CreateShader(desc, mainWindowRenderTarget.State.Texture, instances, graphicsDevice.SwapchainFramebuffer.OutputDescription)
            DrawCommand.CreateDrawMesh(mesh, shader, instances)

        // ---------

        // -- ImGui Settings --
        let imGuiOutputDesc = mainWindowOutputs
        imGuiRenderer <- ImGuiRenderer(graphicsDevice, imGuiOutputDesc, width, height, ColorSpaceHandling.Linear)
        //ImGuiNET.ImGui.StyleColorsClassic()
        // --

        window

    #[StructLayout(LayoutKind.Sequential)]
    private struct VertexDatum =
        mutable Vertex: Vector3 = default
        mutable TexCoord: Vector2 = default
        mutable Normal: Vector3 = default

    CreateMesh(meshDesc: MeshDescription): Mesh =
        let vertices  = meshDesc.Vertices
        let indices   = meshDesc.Indices
        let normals   = meshDesc.Normals
        let texCoords = meshDesc.TexCoords
    
        let vertexCount = uint32(vertices.Length)
        let indexCount  = uint32(indices.Length)

        let vertexData =
            let vertexData = Array.ZeroCreate(int32(vertexCount))
            let mutable i = 0
            while (i < int32(vertexCount))
                vertexData[i] <- 
                    let mutable d = default: VertexDatum
                    d.Vertex <- vertices[i]
                    d.TexCoord <- texCoords[i]
                    d.Normal <- normals[i]
                    d
                i <- i + 1
            vertexData
    
        let vertexBuffer = factory.CreateBuffer(BufferDescription(vertexCount * uint32(sizeof<VertexDatum>), BufferUsage.VertexBuffer))
        let indexBuffer = factory.CreateBuffer(BufferDescription(indexCount * uint32(sizeof<uint32>), BufferUsage.IndexBuffer))
    
        graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertexData)
        graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)
    
        Mesh(vertexBuffer, indexBuffer, indexCount)

    private struct ResourceSetGroup =
        ResourceLayouts: ResourceLayout[||]
        ResourceSets: ResourceSet[||]

        new(resourceLayouts: ResourceLayout[||], resourceSets: ResourceSet[||]) =
            {
                ResourceLayouts = resourceLayouts;
                ResourceSets = resourceSets
            }

    private CreateResourceSet(resourceLayout: ResourceLayout, bindableResource: BindableResource): ResourceSet =
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    bindableResource
                |]
            )
        factory.CreateResourceSet(resourceSetDesc)
            
    private CreateResourceSets(texture2d: Texture2D, instances: Instances, shaderStages: ShaderStages, depthTextureOption: Texture2D): ResourceSetGroup =
        // ------------------------------------------------------------
        let resourceLayout =
            match (shaderStages)
            | ShaderStages.Vertex =>
                globalResourceLayoutVertex
            | _ =>
                globalResourceLayoutCompute

        let resourceSet =
            match (shaderStages)
            | ShaderStages.Vertex =>
                globalResourceSetVertex
            | _ =>
                globalResourceSetCompute

        let resourceLayout2 =
            match (shaderStages)
            | ShaderStages.Vertex =>
                instanceResourceLayoutVertex
            | _ =>
                instanceResourceLayoutCompute

        let resourceSet2 = CreateResourceSet(resourceLayout2, instances.InstanceBuffer)

        match (shaderStages)
        | ShaderStages.Vertex =>
            let resourceLayout3 = 
                if (depthTextureOption === null)
                    defaultResourceLayoutFragment
                else
                    depthResourceLayoutFragment
            let resourceSetDesc3 = 
                ResourceSetDescription(
                    resourceLayout3,
                    if (depthTextureOption === null)
                        [|
                            (texture2d.Texture: BindableResource);
                            pixelSampler
                        |]
                    else
                        [|
                            (texture2d.Texture: BindableResource);
                            pixelSampler;
                            depthTextureOption.Texture
                        |]
                )
            let resourceSet3 = factory.CreateResourceSet(resourceSetDesc3)
            ResourceSetGroup([|resourceLayout;resourceLayout2;resourceLayout3|], [|resourceSet;resourceSet2;resourceSet3|])
        | _ =>
            ResourceSetGroup([|resourceLayout;resourceLayout2|], [|resourceSet;resourceSet2|])
        // ----------------------------------------------------------------
    
    private CreateShaderState(shaderDesc: ShaderDescription, texture2d: Texture2D, instances: Instances, outputs: OutputDescription, depthTextureOption: Texture2D): ShaderState =
        let vertexLayouts      = shaderDesc.VertexLayouts
        let vertexShaderDesc   = shaderDesc.VertexShader
        let fragmentShaderDesc = shaderDesc.FragmentShader
    
        let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)
    
        let mutable pipelineDesc = default: GraphicsPipelineDescription
        pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend
    
        pipelineDesc.DepthStencilState <-
            let mutable desc = default: DepthStencilStateDescription
            desc.DepthTestEnabled <- true
            desc.DepthWriteEnabled <- true
            desc.DepthComparison <- ComparisonKind.LessEqual
            desc
    
        pipelineDesc.RasterizerState <-
            let mutable desc = default: RasterizerStateDescription
            desc.CullMode <- FaceCullMode.Back
            desc.FillMode <- PolygonFillMode.Solid
            desc.FrontFace <- FrontFace.CounterClockwise
            desc.DepthClipEnabled <- true
            desc.ScissorTestEnabled <- false
            desc
    
        pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleList

        pipelineDesc.ShaderSet <-
            let mutable desc = default: ShaderSetDescription
            desc.VertexLayouts <- vertexLayouts
            desc.Shaders <- shaders
            desc

        let resourceSetGroup = CreateResourceSets(texture2d, instances, ShaderStages.Vertex, depthTextureOption)
    
        pipelineDesc.ResourceLayouts <- resourceSetGroup.ResourceLayouts
        pipelineDesc.Outputs <- outputs
        let pipeline = factory.CreateGraphicsPipeline(pipelineDesc)
    
        ShaderState(shaders[0], shaders[1], resourceSetGroup.ResourceSets, pipeline)

    private CreateComputeShaderState(shaderDesc: ComputeShaderDescription, instances: Instances): ComputeShaderState =
        let computeShaderDesc = shaderDesc.ComputeShader
    
        let shader = ResourceFactoryExtensions.CreateFromSpirv(factory, computeShaderDesc)

        let resourceSetGroup = CreateResourceSets(unchecked default, instances, ShaderStages.Compute, null)
    
        let pipelineDesc = 
            ComputePipelineDescription(
                shader, 
                resourceSetGroup.ResourceLayouts, 
                1, 
                1, 
                1
            )

        let pipeline = factory.CreateComputePipeline(pipelineDesc)
    
        ComputeShaderState(shader, resourceSetGroup.ResourceSets, pipeline)

    CreateShader(shaderDesc: ShaderDescription, texture: Texture2D, instances: Instances): Shader =
        Shader(CreateShaderState(shaderDesc, texture, instances, mainWindowOutputs, null))

    CreateShader(shaderDesc: ShaderDescription, texture: Texture2D, depthTexture: Texture2D, instances: Instances): Shader =
        Shader(CreateShaderState(shaderDesc, texture, instances, mainWindowOutputs, depthTexture))

    CreateShader(shaderDesc: ShaderDescription, renderTarget: RenderTarget, instances: Instances): Shader =
        Shader(CreateShaderState(shaderDesc, renderTarget.State.Texture, instances, mainWindowOutputs, renderTarget.State.DepthTexture))

    internal CreateShader(shaderDesc: ShaderDescription, texture2d: Texture2D, instances: Instances, outputs: OutputDescription): Shader =
        Shader(CreateShaderState(shaderDesc, texture2d, instances, outputs, null))

    CreateComputeShader(computeShaderDesc: ComputeShaderDescription, instances: Instances): ComputeShader =
        ComputeShader(CreateComputeShaderState(computeShaderDesc, instances))

    // UpdateShader(shader: Shader, texture2d: Texture2D, shaderDesc: ShaderDescription, instances: Instances): () =
    //     let newState = CreateShaderState(shaderDesc, texture2d, instances, mainWindowOutputs)
    //     let oldState = Interlocked.Exchange(&shader.State, newState)
    //     oldState.Pipeline.Dispose()
    //     oldState.FragmentShader.Dispose()
    //     oldState.VertexShader.Dispose()

    CreateTexture2D(filePath: string): Texture2D =
        let image = Veldrid.ImageSharp.ImageSharpTexture(filePath)
        let texture = image.CreateDeviceTexture(graphicsDevice, factory)
        Texture2D(texture)
        // let image = Image.Load<Rgba32>(System.IO.File.ReadAllBytes(filePath))
        // let width = uint32(image.Width)
        // let height = uint32(image.Height)

        // let mutable pixels = unchecked default: Memory<Rgba32>
        // let mutable result = AdvancedImageExtensions.GetPixelRowMemory(image, 0)
        // let sizeInBytes = width * height * 4

        // let mutable desc = default: TextureDescription
        // desc.Width <- width
        // desc.Height <- height
        // desc.Depth <- 1
        // desc.SampleCount <- TextureSampleCount.Count1
        // desc.Format <- PixelFormat.R8_G8_B8_A8_UNorm
        // desc.Type <- TextureType.Texture2D
        // desc.Usage <- TextureUsage.Sampled
        // desc.MipLevels <- 1
        // desc.ArrayLayers <- 1

        // let texture = factory.CreateTexture(desc)

        // let mutable sourceHandle = result.Pin()
        // let source = nint(sourceHandle.Pointer)

        // graphicsDevice.UpdateTexture(texture, source, sizeInBytes, 0, 0, 0, width, height, 1, 0, 0)
        // sourceHandle.Dispose()

        // Texture2D(texture)

    private CreateRenderTargetState(width: uint32, height: uint32, useDepth: bool): RenderTargetState =
        let depthTexture =
            if (useDepth)
                let usages = toEnum<TextureUsage>(fromEnum(TextureUsage.DepthStencil) | fromEnum(TextureUsage.Sampled))
                factory.CreateTexture(
                    TextureDescription.Texture2D(width, height, 1, 1, PixelFormat.R16_UNorm, usages)
                )
            else
                null
        let usages = toEnum<TextureUsage>(fromEnum(TextureUsage.RenderTarget) | fromEnum(TextureUsage.Sampled))
        let colorTexture = 
            factory.CreateTexture(
                TextureDescription.Texture2D(width, height, 1, 1, PixelFormat.R32_G32_B32_A32_Float, usages)
            )
        let desc = FramebufferDescription(depthTexture, [|colorTexture|])
        let framebuffer = factory.CreateFramebuffer(desc)
        let depthTexture =
            if (depthTexture === null)
                null: Texture2D
            else
                Texture2D(depthTexture)
        RenderTargetState(framebuffer, Texture2D(colorTexture), depthTexture)

    CreateRenderTarget(width: uint32, height: uint32): RenderTarget =
        RenderTarget(CreateRenderTargetState(width, height, true))

    private createGlobalUniformBuffer(slot: uint32): DeviceBuffer =
        factory.CreateBuffer(BufferDescription(1024, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))

    SetView(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 0, value)

    SetProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 64, value)

    SetNormalMatrix(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 128, value)

    SetPreviousView(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 192, value)

    SetPreviousViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 256, value)

    SetInverseViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 320, value)

    SetViewPort(value: Vector4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 384, value)

        if (mainWindowRenderTarget !== unchecked default)
            match (mainWindowRenderTargetCmd)
            | DrawCommand.DrawMesh(mesh, shader, instances) =>
                instances.Dispose()
                mesh.Dispose()
                shader.Dispose()
            | _ =>
                ()
            mainWindowRenderTarget.Dispose()

        mainWindowRenderTarget <- CreateRenderTarget(uint32(value.Z), uint32(value.W))
        mainWindowOutputs <- mainWindowRenderTarget.State.Framebuffer.OutputDescription
        mainWindowRenderTargetCmd <-
            let mesh = CreateMesh(MeshDescription.CreateQuad(1))
            let instances = CreateInstances([|Matrix4x4.Identity|])
            let desc = 
                ShaderDescription.CreateMeshShader(
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.vert")), 
                    Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.frag"))
                )
            let shader = Graphics.CreateShader(desc, mainWindowRenderTarget.State.Texture, instances, graphicsDevice.SwapchainFramebuffer.OutputDescription)
            DrawCommand.CreateDrawMesh(mesh, shader, instances)


    SetDeltaTime(value: float32): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 400, value)

    CreateInstances<T>(instanceData: T[||]): Instances where T: unmanaged =
        let usage: BufferUsage = BufferUsage.StructuredBufferReadWrite
        let instanceBuffer = factory.CreateBuffer(BufferDescription(uint32(instanceData.Length * sizeof<T>), usage, uint32(instanceData.Length * sizeof<T>)))
        graphicsDevice.UpdateBuffer(instanceBuffer, 0, instanceData)

        let instances = Instances(instanceBuffer)
        instances.Count <- instanceData.Length
        instances

    UpdateInstances<T>(instances: Instances, instanceData: T[||]): () where T: unmanaged =
        graphicsDevice.UpdateBuffer(instances.InstanceBuffer, 0, instanceData)

    Draw(drawCmds: DrawCommand[]): () =
        // Begin() must be called before commands can be issued
        commandList.Begin()
    
        let mutable currentPipeline = unchecked default
        let mutable currentFramebuffer = unchecked default: Framebuffer

        let hasFramebuffer() = currentFramebuffer !== unchecked default

        let mutable i = 0
        let length = drawCmds.Length
        while (i <= length)
            let drawCmd =
                if (i == length)
                    commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
                    commandList.ClearColorTarget(0, RgbaFloat.Black)
                    mainWindowRenderTargetCmd
                else
                    drawCmds[i]
            match (drawCmd)
            | DrawCommand.RunComputeShader(computeShader, instances) =>
                let pipeline = computeShader.State.Pipeline
                if (pipeline !== currentPipeline)
                    let resourceSets = computeShader.State.ResourceSets
                    commandList.SetPipeline(pipeline)
                    let mutable i = 0
                    while (i < resourceSets.Length)
                        commandList.SetComputeResourceSet(uint32(i), resourceSets[i])
                        i <- i + 1
                    currentPipeline <- pipeline

                commandList.Dispatch(uint32(instances.Count), 1, 1)

            | DrawCommand.SetWindowTarget =>
                currentFramebuffer <- mainWindowRenderTarget.State.Framebuffer

                // We want to render directly to the output window.
                commandList.SetFramebuffer(currentFramebuffer)
                commandList.ClearColorTarget(0, RgbaFloat.Black)
                commandList.ClearDepthStencil(1)

            | DrawCommand.SetRenderTarget(renderTarget) =>
                currentFramebuffer <- renderTarget.State.Framebuffer

                commandList.SetFramebuffer(currentFramebuffer)
                commandList.ClearColorTarget(0, RgbaFloat.Black)
                commandList.ClearDepthStencil(1)

            | DrawCommand.DrawUI when (hasFramebuffer()) =>
                imGuiRenderer.Render(graphicsDevice, commandList)

            | DrawCommand.DrawMesh(mesh, shader, instances) when (hasFramebuffer()) =>
                let instanceCount = uint32(instances.Count)

                if (instanceCount > 0)   
                    let pipeline = shader.State.Pipeline
                    if (pipeline !== currentPipeline)
                        let resourceSets = shader.State.ResourceSets
                        commandList.SetPipeline(pipeline)
                        let mutable i = 0
                        while (i < resourceSets.Length)
                            commandList.SetGraphicsResourceSet(uint32(i), resourceSets[i])
                            i <- i + 1
                        currentPipeline <- pipeline

                    let vertexBuffer   = mesh.VertexBuffer
                    let indexBuffer    = mesh.IndexBuffer
                    let indexCount     = mesh.IndexCount

                    commandList.SetVertexBuffer(0, vertexBuffer)
                    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt32)
            
                    commandList.DrawIndexed(
                        indexCount,     /* indexCount */
                        instanceCount,  /* instanceCount */
                        0,              /* indexStart */
                        0,              /* vertexOffset */
                        0               /* instanceStart */
                    )

            | _ =>
                ()
    
            i <- i + 1

        

        // End() must be called before commands can be submitted for execution.
        commandList.End()
        graphicsDevice.SubmitCommands(commandList)

        // Once commands have been submitted, the rendered image can be presented to the application window.
        graphicsDevice.SwapBuffers()

    DestroyWindow(): () =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window === unchecked default)
            fail("Window not created. Unable to destroy window.")

        window.Close()
        window <- unchecked default
        commandList.Dispose()
        graphicsDevice.Dispose()

    SetVSync(enabled: bool): () =
        graphicsDevice.SyncToVerticalBlank <- enabled
