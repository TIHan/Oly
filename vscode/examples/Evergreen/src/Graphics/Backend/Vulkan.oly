module Evergreen.Graphics.Backend.Vulkan

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan

#[open]
extension VkResultExtensions =
    inherits VkResult

    static op_Equality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) == fromEnum(result2)

    static op_Inequality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) != fromEnum(result2)

#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageSeverityFlagsEXT): VkDebugUtilsMessageSeverityFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT): VkDebugUtilsMessageTypeFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkDebugReportFlagsEXT, VkDebugReportFlagsEXT): VkDebugReportFlagsEXT

#[intrinsic("bitwise_and")]
(&)(VkQueueFlags, VkQueueFlags): VkQueueFlags

#[intrinsic("equal")]
(==)(VkQueueFlags, VkQueueFlags): bool

sealed class VulkanApplication =
    ValidationLayersEnabled: bool
    Instance: VkInstance
    PhysicalDevice: VkPhysicalDevice
    Device: VkDevice
    GraphicsQueue: VkQueue
    ComputeQueue: VkQueue
    TransferQueue: VkQueue
    DebugMessenger: VkDebugUtilsMessengerEXT
    DebugReportCallback: VkDebugReportCallbackEXT

    new(validationLayersEnabled: bool, instance: VkInstance, physicalDevice: VkPhysicalDevice, device: VkDevice, graphicsQueue: VkQueue, computeQueue: VkQueue, transferQueue: VkQueue, debugMessenger: VkDebugUtilsMessengerEXT, debugReportCallback: VkDebugReportCallbackEXT) =
        {
            ValidationLayersEnabled = validationLayersEnabled
            Instance = instance
            PhysicalDevice = physicalDevice
            Device = device
            GraphicsQueue = graphicsQueue
            ComputeQueue = computeQueue
            TransferQueue = transferQueue
            DebugMessenger = debugMessenger
            DebugReportCallback = debugReportCallback
        }

sealed class PtrPtrHandle =
    implements IDisposable

    private mutable handles: GCHandle[||]
    private mutable ptrPtr: GCHandle

    new(handles: GCHandle[||], ptrPtr: GCHandle) =
        {
            handles = handles
            ptrPtr = ptrPtr
        }

    Pointer: void* get() = UnsafeCast(this.ptrPtr.AddrOfPinnedObject())

    Dispose(): () =
        let mutable i = 0
        while (i < this.handles.Length)
            let mutable handle = this.handles[i]
            handle.Free()
            i <- i + 1
        this.ptrPtr.Free()

private fixed(o: object): GCHandle =
    GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(UTF8Encoding.UTF8.GetBytes(str))

private fixedCopy(strs: string[]): PtrPtrHandle =
    let bytePtrs = Array.ZeroCreate<byte*>(strs.Length)
    let handles = Array.ZeroCreate(strs.Length)

    let mutable i = 0
    while (i < handles.Length)
        let mutable gcHandle = fixedCopyUTF8(strs[i])
        handles[i] <- gcHandle
        bytePtrs[i] <- UnsafeCast(gcHandle.AddrOfPinnedObject())
        i <- i + 1

    let gcHandle = GCHandle.Alloc(bytePtrs, GCHandleType.Pinned)
    PtrPtrHandle(handles, gcHandle)

// ---------------------------------------------------------------------

Initialize(): VulkanApplication =
    let enableValidationLayers = true
    let validationLayers = ["VK_LAYER_KHRONOS_validation"]
    let instance = createInstance(enableValidationLayers, validationLayers)

    let mutable debugMessenger = default
    setupDebugMessenger(enableValidationLayers, instance, &&debugMessenger)

    let mutable debugReportCallback = default
    setupDebugReportCallback(enableValidationLayers, instance, &&debugReportCallback)

    let physicalDevices = getPhysicalDevices(instance)
    let physicalDevice = findSuitableDevice(physicalDevices)

    let queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(physicalDevice)
    let graphicsFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_GRAPHICS_BIT) == VkQueueFlags.VK_QUEUE_GRAPHICS_BIT)
    let computeFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_COMPUTE_BIT) == VkQueueFlags.VK_QUEUE_COMPUTE_BIT)
    let transferFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_TRANSFER_BIT) == VkQueueFlags.VK_QUEUE_TRANSFER_BIT)

    let device = createDevice(enableValidationLayers, validationLayers, physicalDevice, graphicsFamilyIndex, computeFamilyIndex, transferFamilyIndex)


    if (graphicsFamilyIndex != computeFamilyIndex || graphicsFamilyIndex != transferFamilyIndex)
        fail("Queue families are not handled properly.")

    let mutable graphicsQueue = default
    vkGetDeviceQueue(device, uint32(graphicsFamilyIndex), 0, &&graphicsQueue)

    let mutable computeQueue = default
    vkGetDeviceQueue(device, uint32(computeFamilyIndex), 0, &&computeQueue)

    let mutable transferQueue = default
    vkGetDeviceQueue(device, uint32(transferFamilyIndex), 0, &&transferQueue)

    VulkanApplication(enableValidationLayers, instance, physicalDevice, device, graphicsQueue, computeQueue, transferQueue, debugMessenger, debugReportCallback)

Destroy(app: VulkanApplication): () =
    vkDestroyDevice(app.Device, nullptr)

    if (app.ValidationLayersEnabled)
        destroyDebugReportCallbackEXT(app.Instance, app.DebugReportCallback, nullptr)
        destroyDebugUtilsMessengerEXT(app.Instance, app.DebugMessenger, nullptr)

    vkDestroyInstance(app.Instance, nullptr)

// ---------------------------------------------------------------------

private alias PFN_vkCreateDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerCreateInfoEXT*, VkAllocationCallbacks*, VkDebugUtilsMessengerEXT*) -> VkResult
private alias PFN_vkDestroyDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerEXT, VkAllocationCallbacks*) -> ()

private createDebugUtilsMessengerEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugMessenger: VkDebugUtilsMessengerEXT*
        ): VkResult =

    let pName = "vkCreateDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugUtilsMessengerEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugMessenger)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugUtilsMessengerEXT(instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugUtilsMessengerEXT>(func)
        func(instance, debugMessenger, pAllocator)

private alias PFN_vkCreateDebugReportCallbackEXT = static blittable (VkInstance, VkDebugReportCallbackCreateInfoEXT*, VkAllocationCallbacks*, VkDebugReportCallbackEXT*) -> VkResult
private alias PFN_vkDestroyDebugReportCallbackEXT = static blittable (VkInstance, VkDebugReportCallbackEXT, VkAllocationCallbacks*) -> ()

private createDebugReportCallbackEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugReportCallbackCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugReportCallback: VkDebugReportCallbackEXT*
        ): VkResult =

    let pName = "vkCreateDebugReportCallbackEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugReportCallbackEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugReportCallback)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugReportCallbackEXT(instance: VkInstance, debugReportCallback: VkDebugReportCallbackEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugReportCallbackEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugReportCallbackEXT>(func)
        func(instance, debugReportCallback, pAllocator)

private getRequiredExtensions(enableValidationLayers: bool): string[] =
    if (enableValidationLayers)
        [
            Encoding.UTF8.GetString(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
            Encoding.UTF8.GetString(VK_EXT_DEBUG_REPORT_EXTENSION_NAME)
        ]
    else
        []

#[blittable]
private debugCallback(messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT*, pUserData: void*): VkBool32 =
    print("validation layer: ")
    let callback = *pCallbackData
    let str = String(UnsafeCast<int8*>(callback.pMessage))
    printLine(str)
    VkBool32.FALSE

#[blittable]
private debugReportCallback(flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, a: uint64, b: nuint, c: int32, d: int8*, pMessage: int8*, f: void*): VkBool32 =
    print("validation layer: ")
    let str = String(UnsafeCast<int8*>(pMessage))
    printLine(str)
    VkBool32.FALSE

private populateDebugMessengerCreateInfo(createInfo: byref<VkDebugUtilsMessengerCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
    createInfo.messageSeverity <- VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
    createInfo.messageType <- VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
    createInfo.pfnUserCallback <- __oly_load_function_ptr(debugCallback)

private setupDebugMessenger(enableValidationLayers: bool, instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&createInfo)

        if (createDebugUtilsMessengerEXT(instance, &&createInfo, nullptr, debugMessenger) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug messenger.")

private populateDebugReportCallbackCreateInfo(createInfo: byref<VkDebugReportCallbackCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
    createInfo.flags <- VkDebugReportFlagsEXT.VK_DEBUG_REPORT_WARNING_BIT_EXT | VkDebugReportFlagsEXT.VK_DEBUG_REPORT_ERROR_BIT_EXT
    createInfo.pfnCallback <- __oly_load_function_ptr(debugReportCallback)

private setupDebugReportCallback(enableValidationLayers: bool, instance: VkInstance, debugReportCallback: VkDebugReportCallbackEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugReportCallbackCreateInfoEXT
        populateDebugReportCallbackCreateInfo(&createInfo)

        if (createDebugReportCallbackEXT(instance, &&createInfo, nullptr, debugReportCallback) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug report callback.")

private createInstance(enableValidationLayers: bool, validationLayers: string[]): VkInstance =
    if (enableValidationLayers && !checkValidationLayerSupport(validationLayers))
        fail("Validation layers were requested, but not available.")

    let appName = "Vulkan Application"
    let engineName = "Vulkan Engine"

    let mutable appNameHandle = fixed(appName)
    let mutable engineNameHandle = fixed(engineName)

    let mutable appInfo = default: VkApplicationInfo
    appInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO
    appInfo.pApplicationName <- UnsafeCast(appNameHandle.AddrOfPinnedObject())
    appInfo.applicationVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.pEngineName <- UnsafeCast(engineNameHandle.AddrOfPinnedObject())
    appInfo.engineVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.apiVersion <- VK_API_VERSION_1_3

    let mutable createInfo = default: VkInstanceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    createInfo.pApplicationInfo <- &&appInfo

    let extensions = getRequiredExtensions(enableValidationLayers)
    let extensionsHandle = fixedCopy(extensions)
    let validationLayersHandle = fixedCopy(validationLayers)

    createInfo.enabledExtensionCount <- uint32(extensions.Length)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(extensionsHandle.Pointer)

    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)

        let mutable debugCreateInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&debugCreateInfo)
        createInfo.pNext <- UnsafeCast(&&debugCreateInfo)
    else
        createInfo.enabledLayerCount <- 0
        createInfo.pNext <- nullptr

    let mutable instance = default

    if (vkCreateInstance(&&createInfo, nullptr, &&instance) != VkResult.VK_SUCCESS)
        fail("Failed to create instance.")

    // Cleanup
    appNameHandle.Free()
    engineNameHandle.Free()
    validationLayersHandle.Dispose()
    extensionsHandle.Dispose()

    instance

private createDevice(enableValidationLayers: bool, validationLayers: string[], physicalDevice: VkPhysicalDevice, graphicsFamilyIndex: int32, computeFamilyIndex: int32, transferFamilyIndex: int32): VkDevice =
    // Graphics Queue
    let mutable graphicsQueuePriority = 1.0: float32
    let mutable graphicsQueueCreateInfo = default: VkDeviceQueueCreateInfo
    graphicsQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    graphicsQueueCreateInfo.queueFamilyIndex <- uint32(graphicsFamilyIndex)
    graphicsQueueCreateInfo.queueCount <- 1
    graphicsQueueCreateInfo.pQueuePriorities <- &&graphicsQueuePriority

    // // Compute Queue
    // let mutable computeQueuePriority = 1.0: float32
    // let mutable computeQueueCreateInfo = default: VkDeviceQueueCreateInfo
    // computeQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    // computeQueueCreateInfo.queueFamilyIndex <- uint32(computeFamilyIndex)
    // computeQueueCreateInfo.queueCount <- 1
    // computeQueueCreateInfo.pQueuePriorities <- &&computeQueuePriority

    // // Transfer Queue
    // let mutable transferQueuePriority = 1.0: float32
    // let mutable transferQueueCreateInfo = default: VkDeviceQueueCreateInfo
    // transferQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    // transferQueueCreateInfo.queueFamilyIndex <- uint32(transferFamilyIndex)
    // transferQueueCreateInfo.queueCount <- 1
    // transferQueueCreateInfo.pQueuePriorities <- &&transferQueuePriority

    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    let mutable createInfo = default: VkDeviceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO

    // Queues
    let queueCreateInfos = [graphicsQueueCreateInfo] //;computeQueueCreateInfo;transferQueueCreateInfo]
    let mutable queueCreateInfosHandle = fixed(queueCreateInfos)
    createInfo.queueCreateInfoCount <- uint32(queueCreateInfos.Length)
    createInfo.pQueueCreateInfos <- UnsafeCast(queueCreateInfosHandle.AddrOfPinnedObject())
    createInfo.pEnabledFeatures <- &&deviceFeatures
    createInfo.enabledExtensionCount <- 0

    let validationLayersHandle = fixedCopy(validationLayers)
    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)
    else
        createInfo.enabledLayerCount <- 0

    let mutable device = default
    if (vkCreateDevice(physicalDevice, &&createInfo, nullptr, &&device) != VkResult.VK_SUCCESS)
        fail("Failed to create device.")

    // Cleanup
    queueCreateInfosHandle.Free()

    device

// -----------------------------------------------------------------------

private getInstanceLayerProperties(): VkLayerProperties[] =
    let mutable layerCount = 0: uint32

    if (vkEnumerateInstanceLayerProperties(&&layerCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")

    let availableLayers = Array.ZeroCreate<VkLayerProperties>(int32(layerCount))
    let mutable availableLayersHandle = fixed(availableLayers)
    if (vkEnumerateInstanceLayerProperties(&&layerCount, UnsafeCast(availableLayersHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")
    availableLayersHandle.Free()

    UnsafeCast<VkLayerProperties[]>(availableLayers)

private getPhysicalDevices(instance: VkInstance): VkPhysicalDevice[] =
    let mutable deviceCount = 0: uint32

    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")

    let availableDevices = Array.ZeroCreate<VkPhysicalDevice>(int32(deviceCount))
    let mutable availableDevicesHandle = fixed(availableDevices)
    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, UnsafeCast(availableDevicesHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")
    availableDevicesHandle.Free()

    UnsafeCast<VkPhysicalDevice[]>(availableDevices)

private getPhysicalDeviceQueueFamilyProperties(device: VkPhysicalDevice): VkQueueFamilyProperties[] =
    let mutable queueFamilyCount = 0: uint32

    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, nullptr)

    let queueFamilies = Array.ZeroCreate<VkQueueFamilyProperties>(int32(queueFamilyCount))
    let mutable queueFamiliesHandle = fixed(queueFamilies)
    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, UnsafeCast(queueFamiliesHandle.AddrOfPinnedObject()))
    queueFamiliesHandle.Free()

    UnsafeCast<VkQueueFamilyProperties[]>(queueFamilies)

// -----------------------------------------------------------------------

private findSuitableDevice(devices: VkPhysicalDevice[]): VkPhysicalDevice =
    Array.Find(devices, isDeviceSuitable)

private isDeviceSuitable(device: VkPhysicalDevice): bool =
    let mutable deviceProperties = default: VkPhysicalDeviceProperties
    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    vkGetPhysicalDeviceProperties(device, &&deviceProperties)
    vkGetPhysicalDeviceFeatures(device, &&deviceFeatures)

    match (deviceProperties.deviceType)
    | VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU when (deviceFeatures.geometryShader == VkBool32.TRUE) =>
        true
    | _ =>
        false

private checkValidationLayerSupport(validationLayers: string[]): bool =
    if (validationLayers.Length == 0)
        true
    else
        let availableLayers = getInstanceLayerProperties()

        let mutable found = true

        let mutable i = 0
        while (i < validationLayers.Length)
            let mutable foundLayer = false

            let mutable j = 0
            while (j < availableLayers.Length)
                let layerProperties = availableLayers[j]
                let layerName = String(UnsafeCast<int8*>(&&layerProperties.layerName))
                if (layerName == validationLayers[i])
                    foundLayer <- true
                j <- j + 1

            if (!foundLayer)
                found <- false

            i <- i + 1

        found