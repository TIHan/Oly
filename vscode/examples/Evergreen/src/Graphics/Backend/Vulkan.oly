module Evergreen.Graphics.Backend.Vulkan

open System
open System.Text
open System.Numerics
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan
open static Evergreen.Graphics.Backend.Interop.VulkanMemoryAllocator

sealed class VulkanSwapChainOutOfDateException =
    inherits Exception

    internal new() = base()

sealed class VulkanSwapChainCreationFailedException =
    inherits Exception

    internal new() = base()

sealed class VulkanValidationException =
    inherits Exception

    internal new(msg: string) = base(msg)

private success(result: VkResult): bool =
    result == VkResult.VK_SUCCESS

sealed class VulkanApplication =
    ValidationLayersEnabled: bool
    Instance: VkInstance
    Surface: VkSurfaceKHR
    PhysicalDevice: VkPhysicalDevice
    Device: VkDevice
    GraphicsQueue: VkQueue
    GraphicsQueueFamilyIndex: uint32
    GraphicsCommandPool: VkCommandPool
    ComputeQueue: VkQueue
    ComputeQueueFamilyIndex: uint32
    ComputeCommandPool: VkCommandPool
    TransferQueue: VkQueue
    TransferQueueFamilyIndex: uint32
    TransferCommandPool: VkCommandPool
    PresentQueue: VkQueue
    PresentQueueFamilyIndex: uint32
    DebugMessenger: VkDebugUtilsMessengerEXT
    ImageAvailableSemaphores: VkSemaphore[]
    RenderFinishedSemaphores: VkSemaphore[]
    InFlightFences: VkFence[]
    Allocator: VmaAllocator

    internal mutable currentFrame: int32
    internal mutable framebufferResized: bool

    MaxFramesInFlight: int32 get() = this.InFlightFences.Length
    CurrentFrame: int32 get() = this.currentFrame

    GetDeviceName(): string =
        let mutable deviceProperties = default
        vkGetPhysicalDeviceProperties(this.PhysicalDevice, &&deviceProperties)
        String(UnsafeCast<int8*>(&&deviceProperties.deviceName))

    new(validationLayersEnabled: bool, instance: VkInstance, surface: VkSurfaceKHR, physicalDevice: VkPhysicalDevice, device: VkDevice, graphicsQueue: VkQueue, graphicsQueueFamilyIndex: uint32, computeQueue: VkQueue, computeQueueFamilyIndex: uint32, transferQueue: VkQueue, transferQueueFamilyIndex: uint32, presentQueue: VkQueue, presentQueueFamilyIndex: uint32, debugMessenger: VkDebugUtilsMessengerEXT, imageAvailableSemaphores: VkSemaphore[], renderFinishedSemaphores: VkSemaphore[], inFlightFences: VkFence[], allocator: VmaAllocator) =
        let graphicsCommandPool = createCommandPool(device, graphicsQueueFamilyIndex)
        let computeCommandPool = createCommandPool(device, computeQueueFamilyIndex)
        let transferCommandPool = createCommandPool(device, transferQueueFamilyIndex)
        {
            ValidationLayersEnabled = validationLayersEnabled
            Instance = instance
            Surface = surface
            PhysicalDevice = physicalDevice
            Device = device
            GraphicsQueue = graphicsQueue
            GraphicsQueueFamilyIndex = graphicsQueueFamilyIndex
            GraphicsCommandPool = graphicsCommandPool
            ComputeQueue = computeQueue
            ComputeQueueFamilyIndex = computeQueueFamilyIndex
            ComputeCommandPool = computeCommandPool
            TransferQueue = transferQueue
            TransferQueueFamilyIndex = transferQueueFamilyIndex
            TransferCommandPool = transferCommandPool
            PresentQueue = presentQueue
            PresentQueueFamilyIndex = presentQueueFamilyIndex
            DebugMessenger = debugMessenger
            ImageAvailableSemaphores = imageAvailableSemaphores
            RenderFinishedSemaphores = renderFinishedSemaphores
            InFlightFences = inFlightFences
            currentFrame = 0
            framebufferResized = false
            Allocator = allocator
        }

sealed class VulkanSwapChainSupportDetails =
    Capabilities: VkSurfaceCapabilitiesKHR
    Formats: VkSurfaceFormatKHR[]
    PresentModes: VkPresentModeKHR[]

    new(capabilities: VkSurfaceCapabilitiesKHR, formats: VkSurfaceFormatKHR[], presentModes: VkPresentModeKHR[]) =
        {
            Capabilities = capabilities
            Formats = formats
            PresentModes = presentModes
        }

sealed class VulkanSwapChain =
  //  Device: VkDevice
    SwapChain: VkSwapchainKHR
    Images: VkImage[]
    ImageViews: VkImageView[]
    Extent: VkExtent2D
    Viewport: VkViewport
    Scissor: VkRect2D
    ImageFormat: VkFormat

    new(device: VkDevice, swapChain: VkSwapchainKHR, images: VkImage[], imageViews: VkImageView[], extent: VkExtent2D, viewport: VkViewport, scissor: VkRect2D, imageFormat: VkFormat) =
        {
      //      Device = device
            SwapChain = swapChain
            Images = images
            ImageViews = imageViews
            Extent = extent
            Viewport = viewport
            Scissor = scissor
            ImageFormat = imageFormat
        }

private sealed class PtrPtrHandle =
    implements IDisposable

    private mutable handles: GCHandle[||]
    private mutable ptrPtr: GCHandle

    new(handles: GCHandle[||], ptrPtr: GCHandle) =
        {
            handles = handles
            ptrPtr = ptrPtr
        }

    Pointer: void* get() = UnsafeCast(this.ptrPtr.AddrOfPinnedObject())

    Dispose(): () =
        let mutable i = 0
        while (i < this.handles.Length)
            let mutable handle = this.handles[i]
            handle.Free()
            i <- i + 1
        this.ptrPtr.Free()

private fixed(o: object): GCHandle =
    GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(UTF8Encoding.UTF8.GetBytes(str))

private fixedCopy(strs: string[]): PtrPtrHandle =
    let bytePtrs = Array.ZeroCreate<byte*>(strs.Length)
    let handles = Array.ZeroCreate(strs.Length)

    let mutable i = 0
    while (i < handles.Length)
        let mutable gcHandle = fixedCopyUTF8(strs[i])
        handles[i] <- gcHandle
        bytePtrs[i] <- UnsafeCast(gcHandle.AddrOfPinnedObject())
        i <- i + 1

    let gcHandle = GCHandle.Alloc(bytePtrs, GCHandleType.Pinned)
    PtrPtrHandle(handles, gcHandle)

// ---------------------------------------------------------------------

sealed class VulkanApplicationOptions =
    MaxFramesInFlight: int32 set, get = 2
    ValidationEnabled: bool set, get = false

private validateOptions(options: VulkanApplicationOptions): () =
    if (options.MaxFramesInFlight <= 0)
        fail("'MaxFramesInFlight' cannot be less than or equal to zero.")

Initialize(hwnd: nint, hinstance: nint, options: VulkanApplicationOptions): VulkanApplication =
    validateOptions(options)

    let maxFramesInFlight = options.MaxFramesInFlight
    let enableValidationLayers = options.ValidationEnabled
    
    let validationLayers = if (enableValidationLayers) ["VK_LAYER_KHRONOS_validation"] else []
    let instance = createInstance(enableValidationLayers, validationLayers)

    let mutable debugMessenger = default
    setupDebugMessenger(enableValidationLayers, instance, &&debugMessenger)

    let surface = createSurface(instance, hwnd, hinstance)

    let physicalDevices = getPhysicalDevices(instance)
    let physicalDevice = findSuitableDevice(physicalDevices)

    let queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(physicalDevice)
    let graphicsFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_GRAPHICS_BIT) == VkQueueFlags.VK_QUEUE_GRAPHICS_BIT)
    let computeFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_COMPUTE_BIT) == VkQueueFlags.VK_QUEUE_COMPUTE_BIT)
    let transferFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_TRANSFER_BIT) == VkQueueFlags.VK_QUEUE_TRANSFER_BIT)
    let presentFamilyIndex = 
        Array.FindIndex(queueFamilyProperties, 
            (i: int32, x: VkQueueFamilyProperties) ->
                let mutable isPresentSupported = VkBool32.FALSE
                if (vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, uint32(i), surface, &&isPresentSupported) != VkResult.VK_SUCCESS)
                    fail("Failed to get physical device surface support.")
                isPresentSupported == VkBool32.TRUE
        )

    let device = createDevice(enableValidationLayers, validationLayers, physicalDevice, graphicsFamilyIndex, computeFamilyIndex, transferFamilyIndex, presentFamilyIndex)

    let mutable graphicsQueue = default
    vkGetDeviceQueue(device, uint32(graphicsFamilyIndex), uint32(graphicsFamilyIndex), &&graphicsQueue)

    let mutable computeQueue = default
    vkGetDeviceQueue(device, uint32(computeFamilyIndex), uint32(computeFamilyIndex), &&computeQueue)

    let mutable transferQueue = default
    vkGetDeviceQueue(device, uint32(transferFamilyIndex), uint32(transferFamilyIndex), &&transferQueue)

    let mutable presentQueue = default
    vkGetDeviceQueue(device, uint32(presentFamilyIndex), uint32(presentFamilyIndex), &&presentQueue)

    // Sync objects
    let mutable semaphoreInfo = default: VkSemaphoreCreateInfo
    semaphoreInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO

    let mutable fenceInfo = default: VkFenceCreateInfo
    fenceInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
    fenceInfo.flags <- VkFenceCreateFlags.VK_FENCE_CREATE_SIGNALED_BIT

    let inFlightFences = Array.ZeroCreate(maxFramesInFlight)
    let imageAvailableSemaphores = Array.ZeroCreate(inFlightFences.Length)
    let renderFinishedSemaphores = Array.ZeroCreate(inFlightFences.Length)

    let mutable i = 0
    while (i < inFlightFences.Length)
        let imageAvailableSemaphore = &imageAvailableSemaphores[i]
        let renderFinishedSemaphore = &renderFinishedSemaphores[i]
        let inFlightFence = &inFlightFences[i]

        if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&imageAvailableSemaphore) != VkResult.VK_SUCCESS)
            fail("Failed to create semaphore.")

        if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&renderFinishedSemaphore) != VkResult.VK_SUCCESS)
            fail("Failed to create semaphore.")

        if (vkCreateFence(device, &&fenceInfo, nullptr, &&inFlightFence) != VkResult.VK_SUCCESS)
            fail("Failed to create fence.")

        i <- i + 1

    let mutable vulkanFunctions = default: VmaVulkanFunctions
    vulkanFunctions.vkGetInstanceProcAddr <- &&vkGetInstanceProcAddr
    vulkanFunctions.vkGetDeviceProcAddr <- &&vkGetDeviceProcAddr

    let mutable allocatorCreateInfo = default: VmaAllocatorCreateInfo
    allocatorCreateInfo.vulkanApiVersion <- VK_API_VERSION_1_3
    allocatorCreateInfo.physicalDevice <- physicalDevice
    allocatorCreateInfo.device <- device
    allocatorCreateInfo.instance <- instance
    allocatorCreateInfo.pVulkanFunctions <- &&vulkanFunctions

    let mutable allocator = default: VmaAllocator
    if (vmaCreateAllocator(&&allocatorCreateInfo, &&allocator) != VkResult.VK_SUCCESS)
        fail("Failed to create allocator.")

    VulkanApplication(enableValidationLayers, instance, surface, physicalDevice, device, graphicsQueue, uint32(graphicsFamilyIndex), computeQueue, uint32(computeFamilyIndex), transferQueue, uint32(transferFamilyIndex), presentQueue, uint32(presentFamilyIndex), debugMessenger, UnsafeCast(imageAvailableSemaphores), UnsafeCast(renderFinishedSemaphores), UnsafeCast(inFlightFences), allocator)

CreateSwapChain(app: VulkanApplication): VulkanSwapChain =
    createSwapChain(app.PhysicalDevice, app.Device, app.Surface, app.GraphicsQueueFamilyIndex, app.PresentQueueFamilyIndex)

DestroySwapChain(app: VulkanApplication, swapChain: VulkanSwapChain): () =
    let mutable i = 0
    while (i < swapChain.ImageViews.Length)
        vkDestroyImageView(app.Device, swapChain.ImageViews[i], nullptr)
        i <- i + 1
    vkDestroySwapchainKHR(app.Device, swapChain.SwapChain, nullptr)

Destroy(app: VulkanApplication): () =

    vmaDestroyAllocator(app.Allocator)

    let mutable i = 0
    while (i < app.InFlightFences.Length)
        vkDestroyFence(app.Device, app.InFlightFences[i], nullptr)
        vkDestroySemaphore(app.Device, app.ImageAvailableSemaphores[i], nullptr)
        vkDestroySemaphore(app.Device, app.RenderFinishedSemaphores[i], nullptr)
        i <- i + 1
    
    vkDestroyCommandPool(app.Device, app.GraphicsCommandPool, nullptr)
    vkDestroyCommandPool(app.Device, app.ComputeCommandPool, nullptr)
    vkDestroyCommandPool(app.Device, app.TransferCommandPool, nullptr)
    vkDestroyDevice(app.Device, nullptr)

    vkDestroySurfaceKHR(app.Instance, app.Surface, nullptr)

    if (app.ValidationLayersEnabled)
        destroyDebugUtilsMessengerEXT(app.Instance, app.DebugMessenger, nullptr)

    vkDestroyInstance(app.Instance, nullptr)

CreateShaderModule(app: VulkanApplication, byteCode: ReadOnlySpan<byte>): VkShaderModule =
    createShaderModule(app.Device, byteCode)

DestroyShaderModule(app: VulkanApplication, shaderModule: VkShaderModule): () =
    vkDestroyShaderModule(app.Device, shaderModule, nullptr)

CreatePipelineLayout(app: VulkanApplication): VkPipelineLayout =
    createPipelineLayout(app.Device)

DestroyPipelineLayout(app: VulkanApplication, pipelineLayout: VkPipelineLayout): () =
    vkDestroyPipelineLayout(app.Device, pipelineLayout, nullptr)

CreateRenderPass(app: VulkanApplication, swapChain: VulkanSwapChain): VkRenderPass =
    createRenderPass(app.Device, swapChain.ImageFormat)

DestroyRenderPass(app: VulkanApplication, renderPass: VkRenderPass): () =
    vkDestroyRenderPass(app.Device, renderPass, nullptr)

CreateGraphicsPipeline(app: VulkanApplication, swapChain: VulkanSwapChain, vertexBindingDescriptions: VkVertexInputBindingDescription[], vertexAttributeDescriptions: VkVertexInputAttributeDescription[], pipelineLayout: VkPipelineLayout, renderPass: VkRenderPass, vertexShaderModule: VkShaderModule, fragmentShaderModule: VkShaderModule): VkPipeline =
    let stages =
        [|
            createShaderStageInfo(vertexShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT);
            createShaderStageInfo(fragmentShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT)
        |]
    createGraphicsPipeline(app.Device, pipelineLayout, renderPass, stages, vertexBindingDescriptions, vertexAttributeDescriptions, swapChain.Extent)

DestroyPipeline(app: VulkanApplication, pipeline: VkPipeline): () =
    vkDestroyPipeline(app.Device, pipeline, nullptr)

CreateSwapChainFramebuffers(app: VulkanApplication, swapChain: VulkanSwapChain, renderPass: VkRenderPass): VkFramebuffer[||] =
    Array.MapAsMutable(swapChain.ImageViews, x -> createFramebuffer(app.Device, renderPass, x, swapChain.Extent.width, swapChain.Extent.height))

DestroyFramebuffer(app: VulkanApplication, framebuffer: VkFramebuffer): () =
    vkDestroyFramebuffer(app.Device, framebuffer, nullptr)

DestroyFramebuffers(app: VulkanApplication, mutable framebuffers: ReadOnlySpan<VkFramebuffer>): () =
    let mutable i = 0
    while (i < framebuffers.Length)
        DestroyFramebuffer(app, framebuffers[i])
        i <- i + 1

CreateGraphicsCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
    VulkanCommandBuffer(createCommandBuffer(app.Device, app.GraphicsCommandPool))

CreateComputeCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
    VulkanCommandBuffer(createCommandBuffer(app.Device, app.ComputeCommandPool))

CreateTransferCommandBuffer(app: VulkanApplication): VulkanCommandBuffer =
    VulkanCommandBuffer(createCommandBuffer(app.Device, app.TransferCommandPool))

ResetCommandBuffer(app: VulkanApplication, commandBuffer: VulkanCommandBuffer): () =
    if (vkResetCommandBuffer(commandBuffer.CommandBuffer, default) != VkResult.VK_SUCCESS)
        fail("Failed to reset command buffer.!")

ResizeFramebuffer(app: VulkanApplication): () =
    app.framebufferResized <- true

CreateVertexBindingDescription<T>(binding: uint32, isInstance: bool): VkVertexInputBindingDescription where T: unmanaged =
    createVertexInputBindingDescription<T>(binding, isInstance)

CreateVertexAttributeDescriptions<T>(binding: uint32): VkVertexInputAttributeDescription[] where T: unmanaged =
    createVertexInputAttributeDescriptions<T>(binding)

CreateBuffer(app: VulkanApplication, size: uint64, usage: VkBufferUsageFlags, flags: VmaAllocationCreateFlags): VulkanBuffer =
    match (createBuffer(app.Allocator, size, usage, flags, nullptr))
    | (buffer, allocation) =>
        VulkanBuffer(buffer, allocation, size)
    | _ =>
        fail("Should not happen")

UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, mutable bufferData: ReadOnlySpan<T>): () where T: unmanaged =
    let mutable memPropFlags = default: VkMemoryPropertyFlags
    vmaGetAllocationMemoryProperties(app.Allocator, buffer.Allocation, &&memPropFlags)

    if ((memPropFlags & VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
        let mutable pData = default: void*
        if (vmaMapMemory(app.Allocator, buffer.Allocation, &&pData) != VkResult.VK_SUCCESS)
            fail("Failed to map memory.")

        bufferData.CopyTo(Span(pData, bufferData.Length))
    
        vmaUnmapMemory(app.Allocator, buffer.Allocation)
    else
        let mutable allocationInfo = default
        let stagingBuffer = 
            createBuffer(
                app.Allocator, 
                buffer.Size, 
                VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT,
                &&allocationInfo
            )
        match (stagingBuffer)
        | (stagingBuffer, stagingAllocation) =>
            let bufferSpan = Span<T>(allocationInfo.pMappedData, bufferData.Length)
            bufferData.CopyTo(bufferSpan)
            if (!success(vmaFlushAllocation(app.Allocator, stagingAllocation, 0, VK_WHOLE_SIZE)))
                fail("Failed to flush allocation.")
            
            let mutable bufferCopy = default: VkBufferCopy
            bufferCopy.srcOffset <- 0
            bufferCopy.dstOffset <- 0
            bufferCopy.size <- uint64(sizeof<T> * bufferData.Length)

            let mutable commandBuffer = createCommandBuffer(app.Device, app.TransferCommandPool)

            let mutable beginInfo = default: VkCommandBufferBeginInfo
            beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
            beginInfo.flags <- default // Optional
            beginInfo.pInheritanceInfo <- nullptr // Optional

            if (!success(vkBeginCommandBuffer(commandBuffer, &&beginInfo)))
                fail("Failed to begin command buffer.")

            vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer.Buffer, 1, &&bufferCopy)

            if (!success(vkEndCommandBuffer(commandBuffer)))
                fail("Failed to end command buffer.")
            
            let mutable submitInfo = default: VkSubmitInfo
            submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO
            submitInfo.commandBufferCount <- 1
            submitInfo.pCommandBuffers <- &&commandBuffer

            if (!success(vkQueueSubmit(app.TransferQueue, 1, &&submitInfo, default)))
                fail("Failed to submit queue.")

            if (!success(vkDeviceWaitIdle(app.Device)))
                fail("Failed to wait idle on device.")

            vkFreeCommandBuffers(app.Device, app.TransferCommandPool, 1, &&commandBuffer)

            vmaDestroyBuffer(app.Allocator, stagingBuffer, stagingAllocation)
        | _ =>
            fail("should not happen")

UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, bufferData: T[||]): () where T: unmanaged =
    UpdateBuffer<T>(app, buffer, ReadOnlySpan(bufferData))

UpdateBuffer<T>(app: VulkanApplication, buffer: VulkanBuffer, bufferData: T[]): () where T: unmanaged =
    UpdateBuffer<T>(app, buffer, ReadOnlySpan<T>(UnsafeCast<T[||]>(bufferData)))

DestroyBuffer(app: VulkanApplication, buffer: VulkanBuffer): () =
    vmaDestroyBuffer(app.Allocator, buffer.Buffer, buffer.Allocation)

CreateDescriptorSetLayout(app: VulkanApplication, binding: uint32, descriptorType: VkDescriptorType, stageFlags: VkShaderStageFlags): VkDescriptorSetLayout =
    createDescriptSetLayout(app.Device, binding, descriptorType, stageFlags)

DestroyDescriptorSetLayout(app: VulkanApplication, descriptorSetLayout: VkDescriptorSetLayout): () =
    vkDestroyDescriptorSetLayout(app.Device, descriptorSetLayout, nullptr)

Draw(app: VulkanApplication, swapChain: VulkanSwapChain, acquireCommandBuffer: (imageIndex: int32, frame: int32) -> VulkanCommandBuffer): () =
    let currentFrame = app.currentFrame

    let mutable inFlightFence = app.InFlightFences[currentFrame]
    let imageAvailableSemaphore = app.ImageAvailableSemaphores[currentFrame]
    let renderFinishedSemaphore = app.RenderFinishedSemaphores[currentFrame]

    if (vkWaitForFences(app.Device, 1, &&inFlightFence, VkBool32.TRUE, uint64.MaxValue) != VkResult.VK_SUCCESS)
        fail("Failed to wait for fences.")

    if (vkResetFences(app.Device, 1, &&inFlightFence) != VkResult.VK_SUCCESS)
        fail("Failed to reset fences.")

    let mutable imageIndex = default
    let result = vkAcquireNextImageKHR(app.Device, swapChain.SwapChain, uint64.MaxValue, imageAvailableSemaphore, VkFence.NULL, &&imageIndex)

    if (result == VkResult.VK_ERROR_OUT_OF_DATE_KHR)
        throw VulkanSwapChainOutOfDateException()
    else if (result != VkResult.VK_SUCCESS)
        fail("Failed to acquire next image.")
    else
        let commandBuffer = acquireCommandBuffer(int32(imageIndex), currentFrame)

        let result = draw(swapChain.SwapChain, app.GraphicsQueue, app.PresentQueue, commandBuffer, imageIndex, imageAvailableSemaphore, renderFinishedSemaphore, inFlightFence)

        if (result == VkResult.VK_ERROR_OUT_OF_DATE_KHR || result == VkResult.VK_SUBOPTIMAL_KHR || app.framebufferResized)
            app.framebufferResized <- false
            throw VulkanSwapChainOutOfDateException()
        else if (result != VkResult.VK_SUCCESS)
            fail("Failed to present.")

        app.currentFrame <- (app.currentFrame + 1) % app.InFlightFences.Length

WaitForIdle(app: VulkanApplication): () =
    if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
        fail("Failed to wait for idle on device.")
        
ResetCurrentFrame(app: VulkanApplication): () =
    app.currentFrame <- 0

// ---------------------------------------------------------------------

private alias PFN_vkCreateDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerCreateInfoEXT*, VkAllocationCallbacks*, VkDebugUtilsMessengerEXT*) -> VkResult
private alias PFN_vkDestroyDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerEXT, VkAllocationCallbacks*) -> ()

private createDebugUtilsMessengerEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugMessenger: VkDebugUtilsMessengerEXT*
        ): VkResult =

    let pName = "vkCreateDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugUtilsMessengerEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugMessenger)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugUtilsMessengerEXT(instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugUtilsMessengerEXT>(func)
        func(instance, debugMessenger, pAllocator)

private getRequiredExtensions(enableValidationLayers: bool): string[] =
    if (enableValidationLayers)
        [
            Encoding.UTF8.GetString(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
            Encoding.UTF8.GetString(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]
    else
        [
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]

private getRequiredDeviceExtensions(): string[] =
    [
        "VK_KHR_swapchain"
    ]

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>()])]
private debugCallback(messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT*, pUserData: void*): VkBool32 =
    if ((messageSeverity & VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) == VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)
        let callback = *pCallbackData
        let str = String(UnsafeCast<int8*>(callback.pMessage))
        throw VulkanValidationException(str)

    print("validation layer: ")
    let callback = *pCallbackData
    let str = String(UnsafeCast<int8*>(callback.pMessage))
    printLine(str)
    VkBool32.FALSE

private populateDebugMessengerCreateInfo(createInfo: byref<VkDebugUtilsMessengerCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
    createInfo.messageSeverity <- VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
    createInfo.messageType <- VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
    createInfo.pfnUserCallback <- &&debugCallback

private setupDebugMessenger(enableValidationLayers: bool, instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&createInfo)

        if (createDebugUtilsMessengerEXT(instance, &&createInfo, nullptr, debugMessenger) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug messenger.")

private createInstance(enableValidationLayers: bool, validationLayers: string[]): VkInstance =
    if (enableValidationLayers && !checkValidationLayerSupport(validationLayers))
        fail("Validation layers were requested, but not available.")

    let appName = "Vulkan Application"
    let engineName = "Vulkan Engine"

    let mutable appNameHandle = fixed(appName)
    let mutable engineNameHandle = fixed(engineName)

    let mutable appInfo = default: VkApplicationInfo
    appInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO
    appInfo.pApplicationName <- UnsafeCast(appNameHandle.AddrOfPinnedObject())
    appInfo.applicationVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.pEngineName <- UnsafeCast(engineNameHandle.AddrOfPinnedObject())
    appInfo.engineVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.apiVersion <- VK_API_VERSION_1_3

    let mutable createInfo = default: VkInstanceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    createInfo.pApplicationInfo <- &&appInfo

    let extensions = getRequiredExtensions(enableValidationLayers)
    let extensionsHandle = fixedCopy(extensions)
    let validationLayersHandle = fixedCopy(validationLayers)

    createInfo.enabledExtensionCount <- uint32(extensions.Length)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(extensionsHandle.Pointer)

    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)

        let mutable debugCreateInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&debugCreateInfo)
        createInfo.pNext <- UnsafeCast(&&debugCreateInfo)
    else
        createInfo.enabledLayerCount <- 0
        createInfo.pNext <- nullptr

    let mutable instance = default

    if (vkCreateInstance(&&createInfo, nullptr, &&instance) != VkResult.VK_SUCCESS)
        fail("Failed to create instance.")

    // Cleanup
    appNameHandle.Free()
    engineNameHandle.Free()
    validationLayersHandle.Dispose()
    extensionsHandle.Dispose()

    instance

private createSurface(instance: VkInstance, hwnd: nint, hinstance: nint): VkSurfaceKHR =
    let mutable surface = default: VkSurfaceKHR

    let mutable createInfo = default: VkWin32SurfaceCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
    createInfo.hwnd <- hwnd
    createInfo.hinstance <- hinstance

    let mutable instanceImports = default: VkInstanceManualImports
    let pName = "vkCreateWin32SurfaceKHR"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func == nint(0))
        fail("Failed to query instance function.")
    instanceImports.vkCreateWin32SurfaceKHR <- UnsafeCast(func)
    if (instanceImports.vkCreateWin32SurfaceKHR(instance, &&createInfo, nullptr, &&surface) != VkResult.VK_SUCCESS)
        fail("Failed to create window surface.")
    surface

private createDevice(enableValidationLayers: bool, validationLayers: string[], physicalDevice: VkPhysicalDevice, graphicsFamilyIndex: int32, computeFamilyIndex: int32, transferFamilyIndex: int32, presentFamilyIndex: int32): VkDevice =
    // Graphics Queue
    let mutable graphicsQueuePriority = 1.0: float32
    let mutable graphicsQueueCreateInfo = default: VkDeviceQueueCreateInfo
    graphicsQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    graphicsQueueCreateInfo.queueFamilyIndex <- uint32(graphicsFamilyIndex)
    graphicsQueueCreateInfo.queueCount <- 1
    graphicsQueueCreateInfo.pQueuePriorities <- &&graphicsQueuePriority

    // Compute Queue
    let mutable computeQueuePriority = 1.0: float32
    let mutable computeQueueCreateInfo = default: VkDeviceQueueCreateInfo
    computeQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    computeQueueCreateInfo.queueFamilyIndex <- uint32(computeFamilyIndex)
    computeQueueCreateInfo.queueCount <- 1
    computeQueueCreateInfo.pQueuePriorities <- &&computeQueuePriority

    // Transfer Queue
    let mutable transferQueuePriority = 1.0: float32
    let mutable transferQueueCreateInfo = default: VkDeviceQueueCreateInfo
    transferQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    transferQueueCreateInfo.queueFamilyIndex <- uint32(transferFamilyIndex)
    transferQueueCreateInfo.queueCount <- 1
    transferQueueCreateInfo.pQueuePriorities <- &&transferQueuePriority

    // Present Queue
    let mutable presentQueuePriority = 1.0: float32
    let mutable presentQueueCreateInfo = default: VkDeviceQueueCreateInfo
    presentQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    presentQueueCreateInfo.queueFamilyIndex <- uint32(presentFamilyIndex)
    presentQueueCreateInfo.queueCount <- 1
    presentQueueCreateInfo.pQueuePriorities <- &&presentQueuePriority

    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    let mutable createInfo = default: VkDeviceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO

    // Queues
    let queueCreateInfos = [graphicsQueueCreateInfo;computeQueueCreateInfo;transferQueueCreateInfo;presentQueueCreateInfo]
    let queueCreateInfos = Array.DistinctBy(queueCreateInfos, x -> x.queueFamilyIndex)
    let mutable queueCreateInfosHandle = fixed(queueCreateInfos)
    createInfo.queueCreateInfoCount <- uint32(queueCreateInfos.Length)
    createInfo.pQueueCreateInfos <- UnsafeCast(queueCreateInfosHandle.AddrOfPinnedObject())
    createInfo.pEnabledFeatures <- &&deviceFeatures

    let validationLayersHandle = fixedCopy(validationLayers)
    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)
    else
        createInfo.enabledLayerCount <- 0

    let deviceExtensions = getRequiredDeviceExtensions()
    if (!checkExtensionsSupport(physicalDevice, deviceExtensions))
        fail("Failed to validate device extensions.")
    
    createInfo.enabledExtensionCount <- uint32(deviceExtensions.Length)
    let requiredDeviceExtensionsHandle = fixedCopy(deviceExtensions)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(requiredDeviceExtensionsHandle.Pointer)  

    let mutable device = default
    if (vkCreateDevice(physicalDevice, &&createInfo, nullptr, &&device) != VkResult.VK_SUCCESS)
        fail("Failed to create device.")

    // Cleanup
    queueCreateInfosHandle.Free()
    requiredDeviceExtensionsHandle.Dispose()

    device

private createSwapChainSupportDetails(device: VkPhysicalDevice, surface: VkSurfaceKHR): VulkanSwapChainSupportDetails =
    let mutable capabilities = default: VkSurfaceCapabilitiesKHR
    let throwAwayResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &&capabilities)

    let mutable formatCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, nullptr)

    let formats = Array.ZeroCreate<VkSurfaceFormatKHR>(int32(formatCount))
    let mutable formatsHandle = fixed(formats)
    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, UnsafeCast(formatsHandle.AddrOfPinnedObject()))
    formatsHandle.Free()

    let mutable presentModeCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, nullptr)

    let presentModes = Array.ZeroCreate<VkPresentModeKHR>(int32(presentModeCount))
    let mutable presentModesHandle = fixed(presentModes)
    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, UnsafeCast(presentModesHandle.AddrOfPinnedObject()))
    presentModesHandle.Free()

    VulkanSwapChainSupportDetails(capabilities, UnsafeCast(formats), UnsafeCast(presentModes))

private findSwapSurfaceFormat(formats: VkSurfaceFormatKHR[]): VkSurfaceFormatKHR =
    Array.Find(formats, (x: VkSurfaceFormatKHR) -> x.format == VkFormat.VK_FORMAT_B8G8R8A8_SRGB && x.colorSpace == VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)

private findSwapPresentMode(presentModes: VkPresentModeKHR[]): VkPresentModeKHR =
    Array.Find(presentModes,
        (x: VkPresentModeKHR) ->
            x == VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR
    )

private findSwapExtent(capabilities: inref<VkSurfaceCapabilitiesKHR>): VkExtent2D =
    if (capabilities.currentExtent.width != uint32.MaxValue)
        capabilities.currentExtent
    else
        fail("Invalid swap-extent.")
//     VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
//     if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
//         return capabilities.currentExtent;
//     } else {
//         int width, height;
//         glfwGetFramebufferSize(window, &width, &height);

//         VkExtent2D actualExtent = {
//             static_cast<uint32_t>(width),
//             static_cast<uint32_t>(height)
//         };

//         actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
//         actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

//         return actualExtent;
//     }
// }

private createSwapChain(physicalDevice: VkPhysicalDevice, device: VkDevice, surface: VkSurfaceKHR, graphicsFamilyIndex: uint32, presentFamilyIndex: uint32): VulkanSwapChain =
    let details = createSwapChainSupportDetails(physicalDevice, surface)

    let swapChainAdequate =
        details.Formats.Length > 0 && details.PresentModes.Length > 0

    if (!swapChainAdequate)
        fail("Swap chain is not adequate.")

    let surfaceFormat = findSwapSurfaceFormat(details.Formats)
    let presentMode = findSwapPresentMode(details.PresentModes)
    let extent = findSwapExtent(&details.Capabilities)

    // Request at least more than one image.
    let mutable imageCount = details.Capabilities.minImageCount + 1

    if (details.Capabilities.maxImageCount > 0 && imageCount > details.Capabilities.maxImageCount)
        imageCount <- details.Capabilities.maxImageCount   

    let mutable createInfo = default: VkSwapchainCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
    createInfo.surface <- surface
    createInfo.minImageCount <- imageCount
    createInfo.imageFormat <- surfaceFormat.format
    createInfo.imageColorSpace <- surfaceFormat.colorSpace
    createInfo.imageExtent <- extent
    createInfo.imageArrayLayers <- 1
    createInfo.imageUsage <- VkImageUsageFlags.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT

    let queueFamilyIndices = [graphicsFamilyIndex;presentFamilyIndex]
    let mutable queueFamilyIndicesHandle = fixed(queueFamilyIndices)
    if (graphicsFamilyIndex != presentFamilyIndex)
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_CONCURRENT
        createInfo.queueFamilyIndexCount <- 2
        createInfo.pQueueFamilyIndices <- UnsafeCast(queueFamilyIndicesHandle.AddrOfPinnedObject())
    else
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_EXCLUSIVE
        createInfo.queueFamilyIndexCount <- 0 // Optional
        createInfo.pQueueFamilyIndices <- nullptr // Optional

    createInfo.preTransform <- details.Capabilities.currentTransform
    createInfo.compositeAlpha <- VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR

    createInfo.presentMode <- presentMode
    createInfo.clipped <- VkBool32.TRUE
    createInfo.oldSwapchain <- VkSwapchainKHR.NULL

    if (createInfo.preTransform == (default: VkSurfaceTransformFlagsKHR))
        throw VulkanSwapChainCreationFailedException()

    let mutable swapChain = default
    if (vkCreateSwapchainKHR(device, &&createInfo, nullptr, &&swapChain) != VkResult.VK_SUCCESS)
        fail("Failed to create swap chain.")

    // Getting images
    let images = getSwapChainImages(device, swapChain)
    let imageViews = Array.Map(images, x -> createImageView(device, x, surfaceFormat.format))

    let mutable viewport = default: VkViewport
    viewport.x <- 0
    viewport.y <- 0
    viewport.width <- float32(extent.width)
    viewport.height <- float32(extent.height)
    viewport.minDepth <- 0
    viewport.maxDepth <- 1

    let mutable scissor = default: VkRect2D
    scissor.offset <- default
    scissor.extent <- extent

    VulkanSwapChain(device, swapChain, images, imageViews, extent, viewport, scissor, surfaceFormat.format)

private createImageView(device: VkDevice, image: VkImage, imageFormat: VkFormat): VkImageView =
    let mutable createInfo = default: VkImageViewCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    createInfo.image <- image
    createInfo.viewType <- VkImageViewType.VK_IMAGE_VIEW_TYPE_2D
    createInfo.format <- imageFormat
    createInfo.components.r <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.g <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.b <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.a <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY

    createInfo.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
    createInfo.subresourceRange.baseMipLevel <- 0
    createInfo.subresourceRange.levelCount <- 1
    createInfo.subresourceRange.baseArrayLayer <- 0
    createInfo.subresourceRange.layerCount <- 1

    let mutable imageView = default: VkImageView
    if (vkCreateImageView(device, &&createInfo, nullptr, &&imageView) != VkResult.VK_SUCCESS)
        fail("Failed to create image view.")
    
    imageView

private createShaderModule(device: VkDevice, mutable byteCode: ReadOnlySpan<byte>): VkShaderModule =
    let byteCodeRef = &byteCode.GetPinnableReference()

    let mutable createInfo = default: VkShaderModuleCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    createInfo.codeSize <- nuint(byteCode.Length)
    createInfo.pCode <- UnsafeCast(&&byteCodeRef)

    let mutable shaderModule = default: VkShaderModule
    if (vkCreateShaderModule(device, &&createInfo, nullptr, &&shaderModule) != VkResult.VK_SUCCESS)
        fail("Failed to create shader module.")
        
    shaderModule

private createShaderStageInfo(shaderModule: VkShaderModule, stage: VkShaderStageFlags): VkPipelineShaderStageCreateInfo =
    let mutable shaderStageInfo = default: VkPipelineShaderStageCreateInfo
    shaderStageInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
    shaderStageInfo.stage <- stage
    shaderStageInfo.`module` <- shaderModule
    shaderStageInfo

private createPipelineLayout(device: VkDevice): VkPipelineLayout =
    let mutable pipelineLayoutInfo = default: VkPipelineLayoutCreateInfo
    pipelineLayoutInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
    pipelineLayoutInfo.setLayoutCount <- 0 // Optional
    pipelineLayoutInfo.pSetLayouts <- nullptr // Optional
    pipelineLayoutInfo.pushConstantRangeCount <- 0 // Optional
    pipelineLayoutInfo.pPushConstantRanges <- nullptr // Optional

    let mutable pipelineLayout = default
    if (vkCreatePipelineLayout(device, &&pipelineLayoutInfo, nullptr, &&pipelineLayout) != VkResult.VK_SUCCESS)
        fail("Failed to create pipeline layout.")

    pipelineLayout

private createGraphicsPipeline(
        device: VkDevice, 
        pipelineLayout: VkPipelineLayout, 
        renderPass: VkRenderPass, 
        stages: VkPipelineShaderStageCreateInfo[||],
        vertexBindingDescriptions: VkVertexInputBindingDescription[],
        vertexAttributeDescriptions: VkVertexInputAttributeDescription[], 
        swapChainExtent: VkExtent2D): VkPipeline =
    let dynamicStates =
        [
            VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT;
            VkDynamicState.VK_DYNAMIC_STATE_SCISSOR
        ]

    let mutable dynamicStatesHandle = fixed(dynamicStates)

    let mutable dynamicState = default: VkPipelineDynamicStateCreateInfo
    dynamicState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
    dynamicState.dynamicStateCount <- uint32(dynamicStates.Length)
    dynamicState.pDynamicStates <- UnsafeCast(dynamicStatesHandle.AddrOfPinnedObject())

    let mutable vertexBindingDescriptionsHandle = fixed(vertexBindingDescriptions)
    let mutable vertexAttributeDescriptionsHandle = fixed(vertexAttributeDescriptions)

    let mutable vertexInputInfo = default: VkPipelineVertexInputStateCreateInfo
    vertexInputInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
    vertexInputInfo.vertexBindingDescriptionCount <- uint32(vertexBindingDescriptions.Length)
    vertexInputInfo.pVertexBindingDescriptions <- UnsafeCast(vertexBindingDescriptionsHandle.AddrOfPinnedObject())
    vertexInputInfo.vertexAttributeDescriptionCount <- uint32(vertexAttributeDescriptions.Length)
    vertexInputInfo.pVertexAttributeDescriptions <- UnsafeCast(vertexAttributeDescriptionsHandle.AddrOfPinnedObject())

    let mutable inputAssembly = default: VkPipelineInputAssemblyStateCreateInfo
    inputAssembly.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
    inputAssembly.topology <- VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
    inputAssembly.primitiveRestartEnable <- VkBool32.FALSE

    let mutable viewport = default: VkViewport
    viewport.x <- 0
    viewport.y <- 0
    viewport.width <- float32(swapChainExtent.width)
    viewport.height <- float32(swapChainExtent.height)
    viewport.minDepth <- 0
    viewport.maxDepth <- 1

    let mutable scissor = default: VkRect2D
    scissor.offset <- default
    scissor.extent <- swapChainExtent

    let mutable viewportState = default: VkPipelineViewportStateCreateInfo
    viewportState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
    viewportState.viewportCount <- 1
    viewportState.pViewports <- &&viewport
    viewportState.scissorCount <- 1
    viewportState.pScissors <- &&scissor

    let mutable rasterizer = default: VkPipelineRasterizationStateCreateInfo
    rasterizer.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
    rasterizer.depthClampEnable <- VkBool32.FALSE
    rasterizer.rasterizerDiscardEnable <- VkBool32.FALSE
    rasterizer.polygonMode <- VkPolygonMode.VK_POLYGON_MODE_FILL
    rasterizer.lineWidth <- 1
    rasterizer.cullMode <- VkCullModeFlags.VK_CULL_MODE_BACK_BIT
    rasterizer.frontFace <- VkFrontFace.VK_FRONT_FACE_CLOCKWISE // TODO: Make this counter clockwise at some point.

    // TODO: We will want to enable this at some point.
    rasterizer.depthBiasEnable <- VkBool32.FALSE
    rasterizer.depthBiasConstantFactor <- 0 // Optional
    rasterizer.depthBiasClamp <- 0 // Optional
    rasterizer.depthBiasSlopeFactor <- 0 // Optional

    let mutable multisampling = default: VkPipelineMultisampleStateCreateInfo
    multisampling.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
    multisampling.sampleShadingEnable <- VkBool32.FALSE
    multisampling.rasterizationSamples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    multisampling.minSampleShading <- 1 // Optional
    multisampling.pSampleMask <- nullptr // Optional
    multisampling.alphaToCoverageEnable <- VkBool32.FALSE // Optional
    multisampling.alphaToOneEnable <- VkBool32.FALSE // Optional

    let mutable colorBlendAttachment = default: VkPipelineColorBlendAttachmentState
    colorBlendAttachment.colorWriteMask <- VkColorComponentFlags.VK_COLOR_COMPONENT_R_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_G_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_B_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_A_BIT
    colorBlendAttachment.blendEnable <- VkBool32.FALSE
    colorBlendAttachment.srcColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
    colorBlendAttachment.dstColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
    colorBlendAttachment.colorBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional
    colorBlendAttachment.srcAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
    colorBlendAttachment.dstAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
    colorBlendAttachment.alphaBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional

    let mutable colorBlending = default: VkPipelineColorBlendStateCreateInfo
    colorBlending.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
    colorBlending.logicOpEnable <- VkBool32.FALSE
    colorBlending.logicOp <- VkLogicOp.VK_LOGIC_OP_COPY // Optional
    colorBlending.attachmentCount <- 1
    colorBlending.pAttachments <- &&colorBlendAttachment

    // TODO: What do we do about the fixed buffer here?
    colorBlending.blendConstants.FixedElementField <- 0 // Optional
// colorBlending.blendConstants[0] = 0.0f; // Optional
// colorBlending.blendConstants[1] = 0.0f; // Optional
// colorBlending.blendConstants[2] = 0.0f; // Optional
// colorBlending.blendConstants[3] = 0.0f; // Optional

    let pName = "main"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let stageCount = stages.Length
    let mutable i = 0
    while (i < stageCount)
        stages[i].pName <- UnsafeCast(pNameHandle.AddrOfPinnedObject())
        i <- i + 1
    let mutable stagesHandle = fixed(stages)

    let mutable pipelineInfo = default: VkGraphicsPipelineCreateInfo
    pipelineInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
    pipelineInfo.stageCount <- uint32(stageCount)
    pipelineInfo.pStages <- UnsafeCast(stagesHandle.AddrOfPinnedObject())
    pipelineInfo.pVertexInputState <- &&vertexInputInfo
    pipelineInfo.pInputAssemblyState <- &&inputAssembly
    pipelineInfo.pViewportState <- &&viewportState
    pipelineInfo.pRasterizationState <- &&rasterizer
    pipelineInfo.pMultisampleState <- &&multisampling
    pipelineInfo.pDepthStencilState <- nullptr // Optional
    pipelineInfo.pColorBlendState <- &&colorBlending
    pipelineInfo.pDynamicState <- &&dynamicState
    pipelineInfo.layout <- pipelineLayout
    pipelineInfo.renderPass <- renderPass
    pipelineInfo.subpass <- 0
    pipelineInfo.basePipelineHandle <- VkPipeline.NULL // Optional
    pipelineInfo.basePipelineIndex <- -1 // Optional

    let mutable graphicsPipeline = default
    if (vkCreateGraphicsPipelines(device, VkPipelineCache.NULL, 1, &&pipelineInfo, nullptr, &&graphicsPipeline) != VkResult.VK_SUCCESS)
        fail("Failed to create graphics pipeline.")

    // Cleanup
    stagesHandle.Free()
    pNameHandle.Free()
    dynamicStatesHandle.Free()
    
    graphicsPipeline

private createRenderPass(device: VkDevice, swapChainImageFormat: VkFormat): VkRenderPass =
    let mutable colorAttachment = default: VkAttachmentDescription
    colorAttachment.format <- swapChainImageFormat
    colorAttachment.samples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    colorAttachment.loadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR
    colorAttachment.storeOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_STORE
    colorAttachment.stencilLoadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE
    colorAttachment.stencilStoreOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE
    colorAttachment.initialLayout <- VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
    colorAttachment.finalLayout <- VkImageLayout.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR

    let mutable colorAttachmentRef = default: VkAttachmentReference
    colorAttachmentRef.attachment <- 0
    colorAttachmentRef.layout <- VkImageLayout.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL

    let mutable subpass = default: VkSubpassDescription
    subpass.pipelineBindPoint <- VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS
    subpass.colorAttachmentCount <- 1
    subpass.pColorAttachments <- &&colorAttachmentRef

    let mutable dependency = default: VkSubpassDependency
    dependency.srcSubpass <- VK_SUBPASS_EXTERNAL
    dependency.dstSubpass <- 0
    dependency.srcStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
    dependency.srcAccessMask <- default
    dependency.dstStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
    dependency.dstAccessMask <- VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT

    let mutable renderPassInfo = default: VkRenderPassCreateInfo
    renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
    renderPassInfo.attachmentCount <- 1
    renderPassInfo.pAttachments <- &&colorAttachment
    renderPassInfo.subpassCount <- 1
    renderPassInfo.pSubpasses <- &&subpass
    renderPassInfo.dependencyCount <- 1
    renderPassInfo.pDependencies <- &&dependency

    let mutable renderPass = default
    if (vkCreateRenderPass(device, &&renderPassInfo, nullptr, &&renderPass) != VkResult.VK_SUCCESS)
        fail("Failed to create render pass.")
    
    renderPass

private createFramebuffer(device: VkDevice, renderPass: VkRenderPass, imageView: VkImageView, width: uint32, height: uint32): VkFramebuffer =
    let mutable framebufferInfo = default: VkFramebufferCreateInfo
    framebufferInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    framebufferInfo.renderPass <- renderPass
    framebufferInfo.attachmentCount <- 1
    framebufferInfo.pAttachments <- &&imageView
    framebufferInfo.width <- width
    framebufferInfo.height <- height
    framebufferInfo.layers <- 1

    let mutable framebuffer = default
    if (vkCreateFramebuffer(device, &&framebufferInfo, nullptr, &&framebuffer) != VkResult.VK_SUCCESS)
        fail("Failed to create framebuffer.")
    
    framebuffer

private createCommandPool(device: VkDevice, queueFamilyIndex: uint32): VkCommandPool =
    let mutable poolInfo = default: VkCommandPoolCreateInfo
    poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
    poolInfo.flags <- VkCommandPoolCreateFlags.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
    poolInfo.queueFamilyIndex <- queueFamilyIndex

    let mutable commandPool = default
    if (vkCreateCommandPool(device, &&poolInfo, nullptr, &&commandPool) != VkResult.VK_SUCCESS)
        fail("Failed to create command pool.")

    commandPool

private createCommandBuffer(device: VkDevice, commandPool: VkCommandPool): VkCommandBuffer =
    let mutable allocInfo = default: VkCommandBufferAllocateInfo
    allocInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    allocInfo.commandPool <- commandPool
    allocInfo.level <- VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_PRIMARY
    allocInfo.commandBufferCount <- 1

    let mutable commandBuffer = default
    if (vkAllocateCommandBuffers(device, &&allocInfo, &&commandBuffer) != VkResult.VK_SUCCESS)
        fail("Failed to allocate command buffer.")

    commandBuffer

private sealed class VulkanBuffer =
    Buffer: VkBuffer
    Allocation: VmaAllocation
    Size: uint64

    new(buffer: VkBuffer, allocation: VmaAllocation, size: uint64) =
        {
            Buffer = buffer
            Allocation = allocation
            Size = size
        }

private createBuffer(allocator: VmaAllocator, size: uint64, usage: VkBufferUsageFlags, flags: VmaAllocationCreateFlags, pAllocationInfo: VmaAllocationInfo*): (VkBuffer, VmaAllocation) =
    let mutable bufferInfo = default: VkBufferCreateInfo
    bufferInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    bufferInfo.size <- size
    bufferInfo.usage <- usage

    let mutable allocInfo = default: VmaAllocationCreateInfo
    allocInfo.usage <- VmaMemoryUsage.VMA_MEMORY_USAGE_AUTO
    allocInfo.flags <- flags

    let mutable buffer = default: VkBuffer
    let mutable allocation = default: VmaAllocation
    if (!success(vmaCreateBuffer(allocator, &&bufferInfo, &&allocInfo, &&buffer, &&allocation, pAllocationInfo)))
        fail("Failed to create buffer.")

    (buffer, allocation)

private createVertexInputBindingDescription<T>(binding: uint32, isInstance: bool): VkVertexInputBindingDescription where T: unmanaged =
    let mutable bindingDescription = default: VkVertexInputBindingDescription
    bindingDescription.binding <- binding
    bindingDescription.stride <- uint32(sizeof<T>)
    bindingDescription.inputRate <- if (isInstance) VkVertexInputRate.VK_VERTEX_INPUT_RATE_INSTANCE else VkVertexInputRate.VK_VERTEX_INPUT_RATE_VERTEX
    bindingDescription

private createVertexInputAttributeDescriptions<T>(binding: uint32): VkVertexInputAttributeDescription[] where T: unmanaged =
    let ty = typeof<T>()
    let size = sizeof<T>
    let fields = UnsafeCast<System.Reflection.FieldInfo[]>(ty.GetFields())
    let fields = Array.Filter(fields, x -> !x.IsStatic)

    let create(location, offset, field: System.Reflection.FieldInfo) =
        let mutable attributeDescription = default: VkVertexInputAttributeDescription
        attributeDescription.binding <- binding
        attributeDescription.location <- location
        attributeDescription.offset <- offset

        if (field.FieldType === typeof<Vector2>())
            attributeDescription.format <- VkFormat.VK_FORMAT_R32G32_SFLOAT
            (attributeDescription, uint32(sizeof<Vector2>))
        else if (field.FieldType === typeof<Vector3>())
            attributeDescription.format <- VkFormat.VK_FORMAT_R32G32B32_SFLOAT
            (attributeDescription, uint32(sizeof<Vector3>))
        else
            throw NotSupportedException(field.FieldType.ToString())

    let attributeDescriptions = Array.ZeroCreate(fields.Length)
    let mutable i = 0
    let mutable currentOffset = 0: uint32
    while (i < fields.Length)
        match (create(uint32(i), currentOffset, fields[i]))
        | (attributeDescription, size) =>
            currentOffset <- currentOffset + size
            attributeDescriptions[i] <- attributeDescription
        | _ =>
            fail("should not happen")
        i <- i + 1
    UnsafeCast(attributeDescriptions)

createDescriptSetLayout(device: VkDevice, binding: uint32, descriptorType: VkDescriptorType, stageFlags: VkShaderStageFlags): VkDescriptorSetLayout =
    let mutable layoutBinding = default: VkDescriptorSetLayoutBinding
    layoutBinding.binding <- binding
    layoutBinding.descriptorType <- descriptorType
    layoutBinding.descriptorCount <- 1
    layoutBinding.stageFlags <- stageFlags
    layoutBinding.pImmutableSamplers <- nullptr

    let mutable layoutInfo = default: VkDescriptorSetLayoutCreateInfo
    layoutInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
    layoutInfo.bindingCount <- 1
    layoutInfo.pBindings <- &&layoutBinding

    let mutable descriptorSetLayout = default: VkDescriptorSetLayout
    if (!success(vkCreateDescriptorSetLayout(device, &&layoutInfo, nullptr, &&descriptorSetLayout)))
        fail("Failed to create descriptor set layout.")

    descriptorSetLayout

// -----------------------------------------------------------------------

private getInstanceLayerProperties(): VkLayerProperties[] =
    let mutable layerCount = 0: uint32

    if (vkEnumerateInstanceLayerProperties(&&layerCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")

    let availableLayers = Array.ZeroCreate<VkLayerProperties>(int32(layerCount))
    let mutable availableLayersHandle = fixed(availableLayers)
    if (vkEnumerateInstanceLayerProperties(&&layerCount, UnsafeCast(availableLayersHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")
    availableLayersHandle.Free()

    UnsafeCast<VkLayerProperties[]>(availableLayers)

private getPhysicalDevices(instance: VkInstance): VkPhysicalDevice[] =
    let mutable deviceCount = 0: uint32

    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")

    let availableDevices = Array.ZeroCreate<VkPhysicalDevice>(int32(deviceCount))
    let mutable availableDevicesHandle = fixed(availableDevices)
    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, UnsafeCast(availableDevicesHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")
    availableDevicesHandle.Free()

    UnsafeCast<VkPhysicalDevice[]>(availableDevices)

private getPhysicalDeviceQueueFamilyProperties(device: VkPhysicalDevice): VkQueueFamilyProperties[] =
    let mutable queueFamilyCount = 0: uint32

    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, nullptr)

    let queueFamilies = Array.ZeroCreate<VkQueueFamilyProperties>(int32(queueFamilyCount))
    let mutable queueFamiliesHandle = fixed(queueFamilies)
    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, UnsafeCast(queueFamiliesHandle.AddrOfPinnedObject()))
    queueFamiliesHandle.Free()

    UnsafeCast<VkQueueFamilyProperties[]>(queueFamilies)

private getDeviceExtensionProperties(device: VkPhysicalDevice): VkExtensionProperties[] =
    let mutable extensionCount = 0: uint32

    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, nullptr)

    let extensions = Array.ZeroCreate<VkExtensionProperties>(int32(extensionCount))
    let mutable extensionsHandle = fixed(extensions)
    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, UnsafeCast(extensionsHandle.AddrOfPinnedObject()))
    extensionsHandle.Free()

    UnsafeCast(extensions)

private getSwapChainImages(device: VkDevice, swapChain: VkSwapchainKHR): VkImage[] =
    let mutable imageCount = 0: uint32
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, nullptr)
    
    let images = Array.ZeroCreate<VkImage>(int32(imageCount))
    let mutable imagesHandle = fixed(images)
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, UnsafeCast(imagesHandle.AddrOfPinnedObject()))
    imagesHandle.Free()

    UnsafeCast(images)

// -----------------------------------------------------------------------

private findSuitableDevice(devices: VkPhysicalDevice[]): VkPhysicalDevice =
    Array.MaxByUInt32(devices, getDeviceSuitableScore)

private getDeviceSuitableScore(device: VkPhysicalDevice): uint32 =
    let mutable deviceProperties = default: VkPhysicalDeviceProperties
    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    vkGetPhysicalDeviceProperties(device, &&deviceProperties)
    vkGetPhysicalDeviceFeatures(device, &&deviceFeatures)

    let score =
        match (deviceProperties.deviceType)
        | VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU when (deviceFeatures.geometryShader == VkBool32.TRUE) =>
            1000 + deviceProperties.limits.maxImageDimension2D
        | _ =>
            0

    score

private checkValidationLayerSupport(validationLayers: string[]): bool =
    if (validationLayers.Length == 0)
        true
    else
        let availableLayers = getInstanceLayerProperties()

        let mutable found = true

        let mutable i = 0
        while (i < validationLayers.Length)
            let mutable foundLayer = false

            let mutable j = 0
            while (j < availableLayers.Length)
                let layerProperties = availableLayers[j]
                let layerName = String(UnsafeCast<int8*>(&&layerProperties.layerName))
                if (layerName == validationLayers[i])
                    foundLayer <- true
                j <- j + 1

            if (!foundLayer)
                found <- false

            i <- i + 1

        found

private checkExtensionsSupport(device: VkPhysicalDevice, deviceExtensions: string[]): bool =
    if (deviceExtensions.Length == 0)
        true
    else
        let availableExtensions = getDeviceExtensionProperties(device)

        let mutable found = true

        let mutable i = 0
        while (i < deviceExtensions.Length)
            let mutable foundExtension = false

            let mutable j = 0
            while (j < availableExtensions.Length)
                let extensionProperties = availableExtensions[j]
                let extensionName = String(UnsafeCast<int8*>(&&extensionProperties.extensionName))
                if (extensionName == deviceExtensions[i])
                    foundExtension <- true
                j <- j + 1

            if (!foundExtension)
                found <- false

            i <- i + 1

        found

// -----------------------------------------------------------------------

alias VkPipelineBindPoint = TerraFX.Interop.Vulkan.VkPipelineBindPoint

/// Runtime alias for 'VkCommandBuffer'.
newtype VulkanCommandBuffer =
    CommandBuffer: VkCommandBuffer

    Begin(): () =
        let mutable beginInfo = default: VkCommandBufferBeginInfo
        beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
        beginInfo.flags <- default // Optional
        beginInfo.pInheritanceInfo <- nullptr // Optional

        if (vkBeginCommandBuffer(this.CommandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
            fail("Failed to begin recording command buffer.")

    BeginRenderPass(renderPass: VkRenderPass, framebuffer: VkFramebuffer, extent: VkExtent2D): () =
        let mutable renderPassInfo = default: VkRenderPassBeginInfo
        renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
        renderPassInfo.renderPass <- renderPass
        renderPassInfo.framebuffer <- framebuffer
        renderPassInfo.renderArea.offset.x <- 0
        renderPassInfo.renderArea.offset.y <- 0
        renderPassInfo.renderArea.extent <- extent

        let mutable clearValue = default: VkClearValue
        let mutable clearColorValue = default: VkClearColorValue
        let mutable clearDepthStencilValue = default: VkClearDepthStencilValue

        let clearColorValue0 = &clearColorValue.float32.FixedElementField
        let clearColorValue1 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(4))
        let clearColorValue2 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(8))
        let clearColorValue3 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(12))

        clearColorValue0 <- 0
        clearColorValue1 <- 0
        clearColorValue2 <- 0
        clearColorValue3 <- 1

        clearValue.color <- clearColorValue
        clearValue.depthStencil <- clearDepthStencilValue
        renderPassInfo.clearValueCount <- 1
        renderPassInfo.pClearValues <- &&clearValue

        vkCmdBeginRenderPass(this.CommandBuffer, &&renderPassInfo, VkSubpassContents.VK_SUBPASS_CONTENTS_INLINE)

    BindPipeline(pipeline: VkPipeline, pipelineBindPoint: VkPipelineBindPoint): () =
        vkCmdBindPipeline(this.CommandBuffer, pipelineBindPoint, pipeline)

    SetViewport(mutable viewport: VkViewport): () =
        vkCmdSetViewport(this.CommandBuffer, 0, 1, &&viewport)

    SetScissor(mutable scissor: VkRect2D): () =
        vkCmdSetScissor(this.CommandBuffer, 0, 1, &&scissor)

    Draw(vertexCount: uint32, instanceCount: uint32): () =
        vkCmdDraw(this.CommandBuffer, vertexCount, instanceCount, 0, 0)

    BindVertexBuffers(mutable rosVertexBuffers: ReadOnlySpan<VulkanBuffer>): () =
        let vertexBuffers = Array.ZeroCreate<VkBuffer>(rosVertexBuffers.Length)
        let mutable i = 0
        while (i < vertexBuffers.Length)
            vertexBuffers[i] <- rosVertexBuffers[i].Buffer
            i <- i + 1
        let mutable vertexBuffersHandle = fixed(vertexBuffers)

        let offsets = Array.ZeroCreate<uint64>(rosVertexBuffers.Length)
        let mutable i = 0
        while (i < offsets.Length)
            offsets[i] <- 0
            i <- i + 1
        let mutable offsetsHandle = fixed(offsets)

        vkCmdBindVertexBuffers(this.CommandBuffer, 0, 1, UnsafeCast(vertexBuffersHandle.AddrOfPinnedObject()), UnsafeCast(offsetsHandle.AddrOfPinnedObject()))

        // Cleanup
        offsetsHandle.Free()
        vertexBuffersHandle.Free()

    BindVertexBuffers(vertexBuffers: VulkanBuffer[||]): () =
        this.BindVertexBuffers(ReadOnlySpan(vertexBuffers))

    BindVertexBuffers(vertexBuffers: VulkanBuffer[]): () =
        this.BindVertexBuffers(ReadOnlySpan(UnsafeCast<VulkanBuffer[||]>(vertexBuffers)))

    BindVertexBuffer(vertexBuffer: VulkanBuffer): () =
        this.BindVertexBuffers([vertexBuffer])

    EndRenderPass(): () =
        vkCmdEndRenderPass(this.CommandBuffer)

    End(): () =
        if (vkEndCommandBuffer(this.CommandBuffer) != VkResult.VK_SUCCESS)
            fail("Failed to record command buffer.")

private draw(mutable swapChain: VkSwapchainKHR, graphicsQueue: VkQueue, presentQueue: VkQueue, commandBuffer: VkCommandBuffer, mutable imageIndex: uint32, imageAvailableSemaphore: VkSemaphore, renderFinishedSemaphore: VkSemaphore, inFlightFence: VkFence): VkResult =
    let mutable submitInfo = default: VkSubmitInfo
    submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO

    let mutable waitSemaphore = imageAvailableSemaphore
    let mutable waitStage = VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT

    submitInfo.waitSemaphoreCount <- 1
    submitInfo.pWaitSemaphores <- &&waitSemaphore
    submitInfo.pWaitDstStageMask <- &&waitStage
    submitInfo.commandBufferCount <- 1
    submitInfo.pCommandBuffers <- &&commandBuffer

    let mutable signalSemaphore = renderFinishedSemaphore
    
    submitInfo.signalSemaphoreCount <- 1
    submitInfo.pSignalSemaphores <- &&signalSemaphore

    if (vkQueueSubmit(graphicsQueue, 1, &&submitInfo, inFlightFence) != VkResult.VK_SUCCESS)
        fail("Failed to submit draw command buffer.")

    let mutable presentInfo = default: VkPresentInfoKHR
    presentInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR

    presentInfo.waitSemaphoreCount <- 1
    presentInfo.pWaitSemaphores <- &&signalSemaphore

    presentInfo.swapchainCount <- 1
    presentInfo.pSwapchains <- &&swapChain

    presentInfo.pImageIndices <- &&imageIndex
    presentInfo.pResults <- nullptr // Optional

    vkQueuePresentKHR(presentQueue, &&presentInfo)