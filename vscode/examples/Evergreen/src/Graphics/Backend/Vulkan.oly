module Evergreen.Graphics.Backend.Vulkan

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan

#[open]
extension VkResultExtensions =
    inherits VkResult

    static op_Equality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) == fromEnum(result2)

    static op_Inequality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) != fromEnum(result2)

#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageSeverityFlagsEXT): VkDebugUtilsMessageSeverityFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT): VkDebugUtilsMessageTypeFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkDebugReportFlagsEXT, VkDebugReportFlagsEXT): VkDebugReportFlagsEXT

#[intrinsic("bitwise_and")]
(&)(VkQueueFlags, VkQueueFlags): VkQueueFlags

#[intrinsic("equal")]
(==)(VkQueueFlags, VkQueueFlags): bool

#[intrinsic("equal")]
(==)(VkFormat, VkFormat): bool

#[intrinsic("equal")]
(==)(VkColorSpaceKHR, VkColorSpaceKHR): bool

#[intrinsic("equal")]
(==)(VkPresentModeKHR, VkPresentModeKHR): bool

sealed class VulkanApplication =
    ValidationLayersEnabled: bool
    Instance: VkInstance
    Surface: VkSurfaceKHR
    PhysicalDevice: VkPhysicalDevice
    Device: VkDevice
    GraphicsQueue: VkQueue
    ComputeQueue: VkQueue
    TransferQueue: VkQueue
    PresentQueue: VkQueue
    DebugMessenger: VkDebugUtilsMessengerEXT
    DebugReportCallback: VkDebugReportCallbackEXT
    SwapChain: VulkanSwapChain

    new(validationLayersEnabled: bool, instance: VkInstance, surface: VkSurfaceKHR, physicalDevice: VkPhysicalDevice, device: VkDevice, graphicsQueue: VkQueue, computeQueue: VkQueue, transferQueue: VkQueue, presentQueue: VkQueue, debugMessenger: VkDebugUtilsMessengerEXT, debugReportCallback: VkDebugReportCallbackEXT, swapChain: VulkanSwapChain) =
        {
            ValidationLayersEnabled = validationLayersEnabled
            Instance = instance
            Surface = surface
            PhysicalDevice = physicalDevice
            Device = device
            GraphicsQueue = graphicsQueue
            ComputeQueue = computeQueue
            TransferQueue = transferQueue
            PresentQueue = presentQueue
            DebugMessenger = debugMessenger
            DebugReportCallback = debugReportCallback
            SwapChain = swapChain
        }

sealed class VulkanSwapChainSupportDetails =
    Capabilities: VkSurfaceCapabilitiesKHR
    Formats: VkSurfaceFormatKHR[]
    PresentModes: VkPresentModeKHR[]

    new(capabilities: VkSurfaceCapabilitiesKHR, formats: VkSurfaceFormatKHR[], presentModes: VkPresentModeKHR[]) =
        {
            Capabilities = capabilities
            Formats = formats
            PresentModes = presentModes
        }

sealed class VulkanSwapChain =
    Device: VkDevice
    SwapChain: VkSwapchainKHR
    Images: VkImage[]
    ImageViews: VkImageView[]

    new(device: VkDevice, swapChain: VkSwapchainKHR, images: VkImage[], imageViews: VkImageView[]) =
        {
            Device = device
            SwapChain = swapChain
            Images = images
            ImageViews = imageViews
        }

private sealed class PtrPtrHandle =
    implements IDisposable

    private mutable handles: GCHandle[||]
    private mutable ptrPtr: GCHandle

    new(handles: GCHandle[||], ptrPtr: GCHandle) =
        {
            handles = handles
            ptrPtr = ptrPtr
        }

    Pointer: void* get() = UnsafeCast(this.ptrPtr.AddrOfPinnedObject())

    Dispose(): () =
        let mutable i = 0
        while (i < this.handles.Length)
            let mutable handle = this.handles[i]
            handle.Free()
            i <- i + 1
        this.ptrPtr.Free()

private fixed(o: object): GCHandle =
    GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(UTF8Encoding.UTF8.GetBytes(str))

private fixedCopy(strs: string[]): PtrPtrHandle =
    let bytePtrs = Array.ZeroCreate<byte*>(strs.Length)
    let handles = Array.ZeroCreate(strs.Length)

    let mutable i = 0
    while (i < handles.Length)
        let mutable gcHandle = fixedCopyUTF8(strs[i])
        handles[i] <- gcHandle
        bytePtrs[i] <- UnsafeCast(gcHandle.AddrOfPinnedObject())
        i <- i + 1

    let gcHandle = GCHandle.Alloc(bytePtrs, GCHandleType.Pinned)
    PtrPtrHandle(handles, gcHandle)

// ---------------------------------------------------------------------

Initialize(hwnd: nint, hinstance: nint): VulkanApplication =
    let enableValidationLayers = true
    let validationLayers = ["VK_LAYER_KHRONOS_validation"]
    let instance = createInstance(enableValidationLayers, validationLayers)

    let mutable debugMessenger = default
    setupDebugMessenger(enableValidationLayers, instance, &&debugMessenger)

    let mutable debugReportCallback = default
    setupDebugReportCallback(enableValidationLayers, instance, &&debugReportCallback)

    let surface = createSurface(instance, hwnd, hinstance)

    let physicalDevices = getPhysicalDevices(instance)
    let physicalDevice = findSuitableDevice(physicalDevices)

    let queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(physicalDevice)
    let graphicsFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_GRAPHICS_BIT) == VkQueueFlags.VK_QUEUE_GRAPHICS_BIT)
    let computeFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_COMPUTE_BIT) == VkQueueFlags.VK_QUEUE_COMPUTE_BIT)
    let transferFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_TRANSFER_BIT) == VkQueueFlags.VK_QUEUE_TRANSFER_BIT)
    let presentFamilyIndex = 
        Array.FindIndex(queueFamilyProperties, 
            (i: int32, x: VkQueueFamilyProperties) ->
                let mutable isPresentSupported = VkBool32.FALSE
                let throwAwayResult = vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, uint32(i), surface, &&isPresentSupported)
                isPresentSupported == VkBool32.TRUE
        )

    let device = createDevice(enableValidationLayers, validationLayers, physicalDevice, graphicsFamilyIndex, computeFamilyIndex, transferFamilyIndex, presentFamilyIndex)

    let mutable graphicsQueue = default
    vkGetDeviceQueue(device, uint32(graphicsFamilyIndex), uint32(graphicsFamilyIndex), &&graphicsQueue)

    let mutable computeQueue = default
    vkGetDeviceQueue(device, uint32(computeFamilyIndex), uint32(computeFamilyIndex), &&computeQueue)

    let mutable transferQueue = default
    vkGetDeviceQueue(device, uint32(transferFamilyIndex), uint32(transferFamilyIndex), &&transferQueue)

    let mutable presentQueue = default
    vkGetDeviceQueue(device, uint32(transferFamilyIndex), uint32(transferFamilyIndex), &&presentQueue)

    let swapChain = createSwapChain(physicalDevice, device, surface, uint32(graphicsFamilyIndex), uint32(presentFamilyIndex))

    VulkanApplication(enableValidationLayers, instance, surface, physicalDevice, device, graphicsQueue, computeQueue, transferQueue, presentQueue, debugMessenger, debugReportCallback, swapChain)

Destroy(app: VulkanApplication): () =
    let mutable i = 0
    while (i < app.SwapChain.ImageViews.Length)
        vkDestroyImageView(app.Device, app.SwapChain.ImageViews[i], nullptr)
        i <- i + 1
    vkDestroySwapchainKHR(app.Device, app.SwapChain.SwapChain, nullptr)
    
    vkDestroyDevice(app.Device, nullptr)

    vkDestroySurfaceKHR(app.Instance, app.Surface, nullptr)

    if (app.ValidationLayersEnabled)
        destroyDebugReportCallbackEXT(app.Instance, app.DebugReportCallback, nullptr)
        destroyDebugUtilsMessengerEXT(app.Instance, app.DebugMessenger, nullptr)

    vkDestroyInstance(app.Instance, nullptr)

// ---------------------------------------------------------------------

private alias PFN_vkCreateDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerCreateInfoEXT*, VkAllocationCallbacks*, VkDebugUtilsMessengerEXT*) -> VkResult
private alias PFN_vkDestroyDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerEXT, VkAllocationCallbacks*) -> ()

private createDebugUtilsMessengerEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugMessenger: VkDebugUtilsMessengerEXT*
        ): VkResult =

    let pName = "vkCreateDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugUtilsMessengerEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugMessenger)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugUtilsMessengerEXT(instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugUtilsMessengerEXT>(func)
        func(instance, debugMessenger, pAllocator)

private alias PFN_vkCreateDebugReportCallbackEXT = static blittable (VkInstance, VkDebugReportCallbackCreateInfoEXT*, VkAllocationCallbacks*, VkDebugReportCallbackEXT*) -> VkResult
private alias PFN_vkDestroyDebugReportCallbackEXT = static blittable (VkInstance, VkDebugReportCallbackEXT, VkAllocationCallbacks*) -> ()

private createDebugReportCallbackEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugReportCallbackCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugReportCallback: VkDebugReportCallbackEXT*
        ): VkResult =

    let pName = "vkCreateDebugReportCallbackEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugReportCallbackEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugReportCallback)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugReportCallbackEXT(instance: VkInstance, debugReportCallback: VkDebugReportCallbackEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugReportCallbackEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugReportCallbackEXT>(func)
        func(instance, debugReportCallback, pAllocator)

private getRequiredExtensions(enableValidationLayers: bool): string[] =
    if (enableValidationLayers)
        [
            Encoding.UTF8.GetString(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
            Encoding.UTF8.GetString(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]
    else
        [
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]

private getRequiredDeviceExtensions(): string[] =
    [
        "VK_KHR_swapchain"
    ]

#[blittable]
private debugCallback(messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT*, pUserData: void*): VkBool32 =
    print("validation layer: ")
    let callback = *pCallbackData
    let str = String(UnsafeCast<int8*>(callback.pMessage))
    printLine(str)
    VkBool32.FALSE

#[blittable]
private debugReportCallback(flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, a: uint64, b: nuint, c: int32, d: int8*, pMessage: int8*, f: void*): VkBool32 =
    print("validation layer: ")
    let str = String(UnsafeCast<int8*>(pMessage))
    printLine(str)
    VkBool32.FALSE

private populateDebugMessengerCreateInfo(createInfo: byref<VkDebugUtilsMessengerCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
    createInfo.messageSeverity <- VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
    createInfo.messageType <- VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
    createInfo.pfnUserCallback <- __oly_load_function_ptr(debugCallback)

private setupDebugMessenger(enableValidationLayers: bool, instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&createInfo)

        if (createDebugUtilsMessengerEXT(instance, &&createInfo, nullptr, debugMessenger) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug messenger.")

private populateDebugReportCallbackCreateInfo(createInfo: byref<VkDebugReportCallbackCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
    createInfo.flags <- VkDebugReportFlagsEXT.VK_DEBUG_REPORT_WARNING_BIT_EXT | VkDebugReportFlagsEXT.VK_DEBUG_REPORT_ERROR_BIT_EXT
    createInfo.pfnCallback <- __oly_load_function_ptr(debugReportCallback)

private setupDebugReportCallback(enableValidationLayers: bool, instance: VkInstance, debugReportCallback: VkDebugReportCallbackEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugReportCallbackCreateInfoEXT
        populateDebugReportCallbackCreateInfo(&createInfo)

        if (createDebugReportCallbackEXT(instance, &&createInfo, nullptr, debugReportCallback) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug report callback.")

private createInstance(enableValidationLayers: bool, validationLayers: string[]): VkInstance =
    if (enableValidationLayers && !checkValidationLayerSupport(validationLayers))
        fail("Validation layers were requested, but not available.")

    let appName = "Vulkan Application"
    let engineName = "Vulkan Engine"

    let mutable appNameHandle = fixed(appName)
    let mutable engineNameHandle = fixed(engineName)

    let mutable appInfo = default: VkApplicationInfo
    appInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO
    appInfo.pApplicationName <- UnsafeCast(appNameHandle.AddrOfPinnedObject())
    appInfo.applicationVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.pEngineName <- UnsafeCast(engineNameHandle.AddrOfPinnedObject())
    appInfo.engineVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.apiVersion <- VK_API_VERSION_1_3

    let mutable createInfo = default: VkInstanceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    createInfo.pApplicationInfo <- &&appInfo

    let extensions = getRequiredExtensions(enableValidationLayers)
    let extensionsHandle = fixedCopy(extensions)
    let validationLayersHandle = fixedCopy(validationLayers)

    createInfo.enabledExtensionCount <- uint32(extensions.Length)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(extensionsHandle.Pointer)

    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)

        let mutable debugCreateInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&debugCreateInfo)
        createInfo.pNext <- UnsafeCast(&&debugCreateInfo)
    else
        createInfo.enabledLayerCount <- 0
        createInfo.pNext <- nullptr

    let mutable instance = default

    if (vkCreateInstance(&&createInfo, nullptr, &&instance) != VkResult.VK_SUCCESS)
        fail("Failed to create instance.")

    // Cleanup
    appNameHandle.Free()
    engineNameHandle.Free()
    validationLayersHandle.Dispose()
    extensionsHandle.Dispose()

    instance

private createSurface(instance: VkInstance, hwnd: nint, hinstance: nint): VkSurfaceKHR =
    let mutable surface = default: VkSurfaceKHR

    let mutable createInfo = default: VkWin32SurfaceCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
    createInfo.hwnd <- hwnd
    createInfo.hinstance <- hinstance

    let mutable instanceImports = default: VkInstanceManualImports
    let pName = "vkCreateWin32SurfaceKHR"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func == nint(0))
        fail("Failed to query instance function.")
    instanceImports.vkCreateWin32SurfaceKHR <- UnsafeCast(func)
    if (instanceImports.vkCreateWin32SurfaceKHR(instance, &&createInfo, nullptr, &&surface) != VkResult.VK_SUCCESS)
        fail("Failed to create window surface.")
    surface

private createDevice(enableValidationLayers: bool, validationLayers: string[], physicalDevice: VkPhysicalDevice, graphicsFamilyIndex: int32, computeFamilyIndex: int32, transferFamilyIndex: int32, presentFamilyIndex: int32): VkDevice =
    // Graphics Queue
    let mutable graphicsQueuePriority = 1.0: float32
    let mutable graphicsQueueCreateInfo = default: VkDeviceQueueCreateInfo
    graphicsQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    graphicsQueueCreateInfo.queueFamilyIndex <- uint32(graphicsFamilyIndex)
    graphicsQueueCreateInfo.queueCount <- 1
    graphicsQueueCreateInfo.pQueuePriorities <- &&graphicsQueuePriority

    // Compute Queue
    let mutable computeQueuePriority = 1.0: float32
    let mutable computeQueueCreateInfo = default: VkDeviceQueueCreateInfo
    computeQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    computeQueueCreateInfo.queueFamilyIndex <- uint32(computeFamilyIndex)
    computeQueueCreateInfo.queueCount <- 1
    computeQueueCreateInfo.pQueuePriorities <- &&computeQueuePriority

    // Transfer Queue
    let mutable transferQueuePriority = 1.0: float32
    let mutable transferQueueCreateInfo = default: VkDeviceQueueCreateInfo
    transferQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    transferQueueCreateInfo.queueFamilyIndex <- uint32(transferFamilyIndex)
    transferQueueCreateInfo.queueCount <- 1
    transferQueueCreateInfo.pQueuePriorities <- &&transferQueuePriority

    // Present Queue
    let mutable presentQueuePriority = 1.0: float32
    let mutable presentQueueCreateInfo = default: VkDeviceQueueCreateInfo
    presentQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    presentQueueCreateInfo.queueFamilyIndex <- uint32(presentFamilyIndex)
    presentQueueCreateInfo.queueCount <- 1
    presentQueueCreateInfo.pQueuePriorities <- &&presentQueuePriority

    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    let mutable createInfo = default: VkDeviceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO

    // Queues
    let queueCreateInfos = [graphicsQueueCreateInfo;computeQueueCreateInfo;transferQueueCreateInfo;presentQueueCreateInfo]
    let queueCreateInfos = Array.DistinctBy(queueCreateInfos, x -> x.queueFamilyIndex)
    let mutable queueCreateInfosHandle = fixed(queueCreateInfos)
    createInfo.queueCreateInfoCount <- uint32(queueCreateInfos.Length)
    createInfo.pQueueCreateInfos <- UnsafeCast(queueCreateInfosHandle.AddrOfPinnedObject())
    createInfo.pEnabledFeatures <- &&deviceFeatures

    let validationLayersHandle = fixedCopy(validationLayers)
    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)
    else
        createInfo.enabledLayerCount <- 0

    let deviceExtensions = getRequiredDeviceExtensions()
    if (!checkExtensionsSupport(physicalDevice, deviceExtensions))
        fail("Failed to validate device extensions.")
    
    createInfo.enabledExtensionCount <- uint32(deviceExtensions.Length)
    let requiredDeviceExtensionsHandle = fixedCopy(deviceExtensions)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(requiredDeviceExtensionsHandle.Pointer)  

    let mutable device = default
    if (vkCreateDevice(physicalDevice, &&createInfo, nullptr, &&device) != VkResult.VK_SUCCESS)
        fail("Failed to create device.")

    // Cleanup
    queueCreateInfosHandle.Free()
    requiredDeviceExtensionsHandle.Dispose()

    device

private createSwapChainSupportDetails(device: VkPhysicalDevice, surface: VkSurfaceKHR): VulkanSwapChainSupportDetails =
    let mutable capabilities = default: VkSurfaceCapabilitiesKHR
    let throwAwayResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &&capabilities)

    let mutable formatCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, nullptr)

    let formats = Array.ZeroCreate<VkSurfaceFormatKHR>(int32(formatCount))
    let mutable formatsHandle = fixed(formats)
    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, UnsafeCast(formatsHandle.AddrOfPinnedObject()))
    formatsHandle.Free()

    let mutable presentModeCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, nullptr)

    let presentModes = Array.ZeroCreate<VkPresentModeKHR>(int32(presentModeCount))
    let mutable presentModesHandle = fixed(presentModes)
    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, UnsafeCast(presentModesHandle.AddrOfPinnedObject()))
    presentModesHandle.Free()

    VulkanSwapChainSupportDetails(capabilities, UnsafeCast(formats), UnsafeCast(presentModes))

private findSwapSurfaceFormat(formats: VkSurfaceFormatKHR[]): VkSurfaceFormatKHR =
    Array.Find(formats, (x: VkSurfaceFormatKHR) -> x.format == VkFormat.VK_FORMAT_B8G8R8A8_SRGB && x.colorSpace == VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)

private findSwapPresentMode(presentModes: VkPresentModeKHR[]): VkPresentModeKHR =
    Array.Find(presentModes,
        (x: VkPresentModeKHR) ->
            x == VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR
    )

private findSwapExtent(capabilities: inref<VkSurfaceCapabilitiesKHR>): VkExtent2D =
    if (capabilities.currentExtent.width != uint32.MaxValue)
        capabilities.currentExtent
    else
        fail("Invalid swap-extent.")
//     VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
//     if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
//         return capabilities.currentExtent;
//     } else {
//         int width, height;
//         glfwGetFramebufferSize(window, &width, &height);

//         VkExtent2D actualExtent = {
//             static_cast<uint32_t>(width),
//             static_cast<uint32_t>(height)
//         };

//         actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
//         actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

//         return actualExtent;
//     }
// }

private createSwapChain(physicalDevice: VkPhysicalDevice, device: VkDevice, surface: VkSurfaceKHR, graphicsFamilyIndex: uint32, presentFamilyIndex: uint32): VulkanSwapChain =
    let details = createSwapChainSupportDetails(physicalDevice, surface)

    let swapChainAdequate =
        details.Formats.Length > 0 && details.PresentModes.Length > 0

    if (!swapChainAdequate)
        fail("Swap chain is not adequate.")

    let surfaceFormat = findSwapSurfaceFormat(details.Formats)
    let presentMode = findSwapPresentMode(details.PresentModes)
    let extent = findSwapExtent(&details.Capabilities)

    // Request at least more than one image.
    let mutable imageCount = details.Capabilities.minImageCount + 1

    if (details.Capabilities.maxImageCount > 0 && imageCount > details.Capabilities.maxImageCount)
        imageCount <- details.Capabilities.maxImageCount   

    let mutable createInfo = default: VkSwapchainCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
    createInfo.surface <- surface
    createInfo.minImageCount <- imageCount
    createInfo.imageFormat <- surfaceFormat.format
    createInfo.imageColorSpace <- surfaceFormat.colorSpace
    createInfo.imageExtent <- extent
    createInfo.imageArrayLayers <- 1
    createInfo.imageUsage <- VkImageUsageFlags.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT

    let queueFamilyIndices = [graphicsFamilyIndex;presentFamilyIndex]
    let mutable queueFamilyIndicesHandle = fixed(queueFamilyIndices)
    if (graphicsFamilyIndex != presentFamilyIndex)
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_CONCURRENT
        createInfo.queueFamilyIndexCount <- 2
        createInfo.pQueueFamilyIndices <- UnsafeCast(queueFamilyIndicesHandle.AddrOfPinnedObject())
    else
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_EXCLUSIVE
        createInfo.queueFamilyIndexCount <- 0 // Optional
        createInfo.pQueueFamilyIndices <- nullptr // Optional

    createInfo.preTransform <- details.Capabilities.currentTransform
    createInfo.compositeAlpha <- VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR

    createInfo.presentMode <- presentMode
    createInfo.clipped <- VkBool32.TRUE
    createInfo.oldSwapchain <- VkSwapchainKHR.NULL

    let mutable swapChain = default
    if (vkCreateSwapchainKHR(device, &&createInfo, nullptr, &&swapChain) != VkResult.VK_SUCCESS)
        fail("Failed to create swap chain.")

    // Getting images
    let images = getSwapChainImages(device, swapChain)
    let imageViews = Array.Map(images, x -> createImageView(device, x, surfaceFormat.format))

    VulkanSwapChain(device, swapChain, images, imageViews)

private createImageView(device: VkDevice, image: VkImage, imageFormat: VkFormat): VkImageView =
    let mutable createInfo = default: VkImageViewCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    createInfo.image <- image
    createInfo.viewType <- VkImageViewType.VK_IMAGE_VIEW_TYPE_2D
    createInfo.format <- imageFormat
    createInfo.components.r <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.g <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.b <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.a <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY

    createInfo.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
    createInfo.subresourceRange.baseMipLevel <- 0
    createInfo.subresourceRange.levelCount <- 1
    createInfo.subresourceRange.baseArrayLayer <- 0
    createInfo.subresourceRange.layerCount <- 1

    let mutable imageView = default: VkImageView
    if (vkCreateImageView(device, &&createInfo, nullptr, &&imageView) != VkResult.VK_SUCCESS)
        fail("Failed to create image view.")
    
    imageView

// -----------------------------------------------------------------------

private getInstanceLayerProperties(): VkLayerProperties[] =
    let mutable layerCount = 0: uint32

    if (vkEnumerateInstanceLayerProperties(&&layerCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")

    let availableLayers = Array.ZeroCreate<VkLayerProperties>(int32(layerCount))
    let mutable availableLayersHandle = fixed(availableLayers)
    if (vkEnumerateInstanceLayerProperties(&&layerCount, UnsafeCast(availableLayersHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")
    availableLayersHandle.Free()

    UnsafeCast<VkLayerProperties[]>(availableLayers)

private getPhysicalDevices(instance: VkInstance): VkPhysicalDevice[] =
    let mutable deviceCount = 0: uint32

    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")

    let availableDevices = Array.ZeroCreate<VkPhysicalDevice>(int32(deviceCount))
    let mutable availableDevicesHandle = fixed(availableDevices)
    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, UnsafeCast(availableDevicesHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")
    availableDevicesHandle.Free()

    UnsafeCast<VkPhysicalDevice[]>(availableDevices)

private getPhysicalDeviceQueueFamilyProperties(device: VkPhysicalDevice): VkQueueFamilyProperties[] =
    let mutable queueFamilyCount = 0: uint32

    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, nullptr)

    let queueFamilies = Array.ZeroCreate<VkQueueFamilyProperties>(int32(queueFamilyCount))
    let mutable queueFamiliesHandle = fixed(queueFamilies)
    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, UnsafeCast(queueFamiliesHandle.AddrOfPinnedObject()))
    queueFamiliesHandle.Free()

    UnsafeCast<VkQueueFamilyProperties[]>(queueFamilies)

private getDeviceExtensionProperties(device: VkPhysicalDevice): VkExtensionProperties[] =
    let mutable extensionCount = 0: uint32

    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, nullptr)

    let extensions = Array.ZeroCreate<VkExtensionProperties>(int32(extensionCount))
    let mutable extensionsHandle = fixed(extensions)
    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, UnsafeCast(extensionsHandle.AddrOfPinnedObject()))
    extensionsHandle.Free()

    UnsafeCast(extensions)

private getSwapChainImages(device: VkDevice, swapChain: VkSwapchainKHR): VkImage[] =
    let mutable imageCount = 0: uint32
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, nullptr)
    
    let images = Array.ZeroCreate<VkExtensionProperties>(int32(imageCount))
    let mutable imagesHandle = fixed(images)
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, UnsafeCast(imagesHandle.AddrOfPinnedObject()))
    imagesHandle.Free()

    UnsafeCast(images)

// -----------------------------------------------------------------------

private findSuitableDevice(devices: VkPhysicalDevice[]): VkPhysicalDevice =
    Array.MaxByUInt32(devices, getDeviceSuitableScore)

private getDeviceSuitableScore(device: VkPhysicalDevice): uint32 =
    let mutable deviceProperties = default: VkPhysicalDeviceProperties
    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    vkGetPhysicalDeviceProperties(device, &&deviceProperties)
    vkGetPhysicalDeviceFeatures(device, &&deviceFeatures)

    let score =
        match (deviceProperties.deviceType)
        | VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU when (deviceFeatures.geometryShader == VkBool32.TRUE) =>
            1000 + deviceProperties.limits.maxImageDimension2D
        | _ =>
            0

    // let deviceName = String(UnsafeCast<int8*>(&&deviceProperties.deviceName))
    // print("Device Name and Score: ")
    // print(deviceName)
    // print(" - Score ")
    // print(score)
    // print("\n")

    score

private checkValidationLayerSupport(validationLayers: string[]): bool =
    if (validationLayers.Length == 0)
        true
    else
        let availableLayers = getInstanceLayerProperties()

        let mutable found = true

        let mutable i = 0
        while (i < validationLayers.Length)
            let mutable foundLayer = false

            let mutable j = 0
            while (j < availableLayers.Length)
                let layerProperties = availableLayers[j]
                let layerName = String(UnsafeCast<int8*>(&&layerProperties.layerName))
                if (layerName == validationLayers[i])
                    foundLayer <- true
                j <- j + 1

            if (!foundLayer)
                found <- false

            i <- i + 1

        found

private checkExtensionsSupport(device: VkPhysicalDevice, deviceExtensions: string[]): bool =
    if (deviceExtensions.Length == 0)
        true
    else
        let availableExtensions = getDeviceExtensionProperties(device)

        let mutable found = true

        let mutable i = 0
        while (i < deviceExtensions.Length)
            let mutable foundExtension = false

            let mutable j = 0
            while (j < availableExtensions.Length)
                let extensionProperties = availableExtensions[j]
                let extensionName = String(UnsafeCast<int8*>(&&extensionProperties.extensionName))
                if (extensionName == deviceExtensions[i])
                    foundExtension <- true
                j <- j + 1

            if (!foundExtension)
                found <- false

            i <- i + 1

        found