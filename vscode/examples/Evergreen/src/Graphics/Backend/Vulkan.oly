module Evergreen.Graphics.Backend.Vulkan

open System
open System.Text
open System.Collections.Generic
open System.Collections.Concurrent
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Vulkan
open static TerraFX.Interop.Vulkan.Vulkan

#[open]
extension VkResultExtensions =
    inherits VkResult

    static op_Equality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) == fromEnum(result2)

    static op_Inequality(result1: VkResult, result2: VkResult): bool =
        fromEnum(result1) != fromEnum(result2)

#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageSeverityFlagsEXT): VkDebugUtilsMessageSeverityFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT): VkDebugUtilsMessageTypeFlagsEXT
#[intrinsic("bitwise_or")]
(|)(VkColorComponentFlags, VkColorComponentFlags): VkColorComponentFlags

#[intrinsic("bitwise_and")]
(&)(VkQueueFlags, VkQueueFlags): VkQueueFlags

#[intrinsic("equal")]
(==)(VkQueueFlags, VkQueueFlags): bool

#[intrinsic("equal")]
(==)(VkFormat, VkFormat): bool

#[intrinsic("equal")]
(==)(VkColorSpaceKHR, VkColorSpaceKHR): bool

#[intrinsic("equal")]
(==)(VkPresentModeKHR, VkPresentModeKHR): bool

sealed class VulkanApplication =
    ValidationLayersEnabled: bool
    Instance: VkInstance
    Surface: VkSurfaceKHR
    PhysicalDevice: VkPhysicalDevice
    Device: VkDevice
    GraphicsQueue: VkQueue
    GraphicsQueueFamilyIndex: uint32
    ComputeQueue: VkQueue
    ComputeQueueFamilyIndex: uint32
    TransferQueue: VkQueue
    TransferQueueFamilyIndex: uint32
    PresentQueue: VkQueue
    PresentQueueFamilyIndex: uint32
    DebugMessenger: VkDebugUtilsMessengerEXT
    ImageAvailableSemaphores: VkSemaphore[]
    RenderFinishedSemaphores: VkSemaphore[]
    InFlightFences: VkFence[]
    SwapChain: VulkanSwapChain

    internal mutable currentFrame: int32
    MaxFramesInFlight: int32

    new(validationLayersEnabled: bool, instance: VkInstance, surface: VkSurfaceKHR, physicalDevice: VkPhysicalDevice, device: VkDevice, graphicsQueue: VkQueue, graphicsQueueFamilyIndex: uint32, computeQueue: VkQueue, computeQueueFamilyIndex: uint32, transferQueue: VkQueue, transferQueueFamilyIndex: uint32, presentQueue: VkQueue, presentQueueFamilyIndex: uint32, debugMessenger: VkDebugUtilsMessengerEXT, imageAvailableSemaphores: VkSemaphore[], renderFinishedSemaphores: VkSemaphore[], inFlightFences: VkFence[], swapChain: VulkanSwapChain, maxFramesInFlight: int32) =
        {
            ValidationLayersEnabled = validationLayersEnabled
            Instance = instance
            Surface = surface
            PhysicalDevice = physicalDevice
            Device = device
            GraphicsQueue = graphicsQueue
            GraphicsQueueFamilyIndex = graphicsQueueFamilyIndex
            ComputeQueue = computeQueue
            ComputeQueueFamilyIndex = computeQueueFamilyIndex
            TransferQueue = transferQueue
            TransferQueueFamilyIndex = transferQueueFamilyIndex
            PresentQueue = presentQueue
            PresentQueueFamilyIndex = presentQueueFamilyIndex
            DebugMessenger = debugMessenger
            ImageAvailableSemaphores = imageAvailableSemaphores
            RenderFinishedSemaphores = renderFinishedSemaphores
            InFlightFences = inFlightFences
            SwapChain = swapChain
            currentFrame = 0
            MaxFramesInFlight = maxFramesInFlight
        }

sealed class VulkanSwapChainSupportDetails =
    Capabilities: VkSurfaceCapabilitiesKHR
    Formats: VkSurfaceFormatKHR[]
    PresentModes: VkPresentModeKHR[]

    new(capabilities: VkSurfaceCapabilitiesKHR, formats: VkSurfaceFormatKHR[], presentModes: VkPresentModeKHR[]) =
        {
            Capabilities = capabilities
            Formats = formats
            PresentModes = presentModes
        }

sealed class VulkanSwapChain =
    Device: VkDevice
    SwapChain: VkSwapchainKHR
    Images: VkImage[]
    ImageViews: VkImageView[]
    Extent: VkExtent2D
    Viewport: VkViewport
    Scissor: VkRect2D
    ImageFormat: VkFormat

    new(device: VkDevice, swapChain: VkSwapchainKHR, images: VkImage[], imageViews: VkImageView[], extent: VkExtent2D, viewport: VkViewport, scissor: VkRect2D, imageFormat: VkFormat) =
        {
            Device = device
            SwapChain = swapChain
            Images = images
            ImageViews = imageViews
            Extent = extent
            Viewport = viewport
            Scissor = scissor
            ImageFormat = imageFormat
        }

private sealed class PtrPtrHandle =
    implements IDisposable

    private mutable handles: GCHandle[||]
    private mutable ptrPtr: GCHandle

    new(handles: GCHandle[||], ptrPtr: GCHandle) =
        {
            handles = handles
            ptrPtr = ptrPtr
        }

    Pointer: void* get() = UnsafeCast(this.ptrPtr.AddrOfPinnedObject())

    Dispose(): () =
        let mutable i = 0
        while (i < this.handles.Length)
            let mutable handle = this.handles[i]
            handle.Free()
            i <- i + 1
        this.ptrPtr.Free()

private fixed(o: object): GCHandle =
    GCHandle.Alloc(o, GCHandleType.Pinned)

private fixedCopyUTF8(str: string): GCHandle =
    fixed(UTF8Encoding.UTF8.GetBytes(str))

private fixedCopy(strs: string[]): PtrPtrHandle =
    let bytePtrs = Array.ZeroCreate<byte*>(strs.Length)
    let handles = Array.ZeroCreate(strs.Length)

    let mutable i = 0
    while (i < handles.Length)
        let mutable gcHandle = fixedCopyUTF8(strs[i])
        handles[i] <- gcHandle
        bytePtrs[i] <- UnsafeCast(gcHandle.AddrOfPinnedObject())
        i <- i + 1

    let gcHandle = GCHandle.Alloc(bytePtrs, GCHandleType.Pinned)
    PtrPtrHandle(handles, gcHandle)

// ---------------------------------------------------------------------

sealed class VulkanApplicationOptions =
    mutable PreferredMaxFramesInFlight: int32 = 1

Initialize(hwnd: nint, hinstance: nint, options: VulkanApplicationOptions): VulkanApplication =
    if (options.PreferredMaxFramesInFlight <= 0)
        fail("Invalid 'PreferredMaxFramesInFlight'.")

    let enableValidationLayers = true
    let validationLayers = ["VK_LAYER_KHRONOS_validation"]
    let instance = createInstance(enableValidationLayers, validationLayers)

    let mutable debugMessenger = default
    setupDebugMessenger(enableValidationLayers, instance, &&debugMessenger)

    let surface = createSurface(instance, hwnd, hinstance)

    let physicalDevices = getPhysicalDevices(instance)
    let physicalDevice = findSuitableDevice(physicalDevices)

    let queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(physicalDevice)
    let graphicsFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_GRAPHICS_BIT) == VkQueueFlags.VK_QUEUE_GRAPHICS_BIT)
    let computeFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_COMPUTE_BIT) == VkQueueFlags.VK_QUEUE_COMPUTE_BIT)
    let transferFamilyIndex = Array.FindIndex(queueFamilyProperties, (x: VkQueueFamilyProperties) -> (x.queueFlags & VkQueueFlags.VK_QUEUE_TRANSFER_BIT) == VkQueueFlags.VK_QUEUE_TRANSFER_BIT)
    let presentFamilyIndex = 
        Array.FindIndex(queueFamilyProperties, 
            (i: int32, x: VkQueueFamilyProperties) ->
                let mutable isPresentSupported = VkBool32.FALSE
                if (vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, uint32(i), surface, &&isPresentSupported) != VkResult.VK_SUCCESS)
                    fail("Failed to get physical device surface support.")
                isPresentSupported == VkBool32.TRUE
        )

    let device = createDevice(enableValidationLayers, validationLayers, physicalDevice, graphicsFamilyIndex, computeFamilyIndex, transferFamilyIndex, presentFamilyIndex)

    let mutable graphicsQueue = default
    vkGetDeviceQueue(device, uint32(graphicsFamilyIndex), uint32(graphicsFamilyIndex), &&graphicsQueue)

    let mutable computeQueue = default
    vkGetDeviceQueue(device, uint32(computeFamilyIndex), uint32(computeFamilyIndex), &&computeQueue)

    let mutable transferQueue = default
    vkGetDeviceQueue(device, uint32(transferFamilyIndex), uint32(transferFamilyIndex), &&transferQueue)

    let mutable presentQueue = default
    vkGetDeviceQueue(device, uint32(presentFamilyIndex), uint32(presentFamilyIndex), &&presentQueue)

    let swapChain = createSwapChain(physicalDevice, device, surface, uint32(graphicsFamilyIndex), uint32(presentFamilyIndex))

    let maxFramesInFlight = Math.Min(swapChain.Images.Length, options.PreferredMaxFramesInFlight)

    // Sync objects
    let mutable semaphoreInfo = default: VkSemaphoreCreateInfo
    semaphoreInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO

    let mutable fenceInfo = default: VkFenceCreateInfo
    fenceInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
    fenceInfo.flags <- VkFenceCreateFlags.VK_FENCE_CREATE_SIGNALED_BIT

    let inFlightFences = Array.ZeroCreate(maxFramesInFlight)
    let imageAvailableSemaphores = Array.ZeroCreate(inFlightFences.Length)
    let renderFinishedSemaphores = Array.ZeroCreate(inFlightFences.Length)

    let mutable i = 0
    while (i < inFlightFences.Length)
        let imageAvailableSemaphore = &imageAvailableSemaphores[i]
        let renderFinishedSemaphore = &renderFinishedSemaphores[i]
        let inFlightFence = &inFlightFences[i]

        if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&imageAvailableSemaphore) != VkResult.VK_SUCCESS)
            fail("Failed to create semaphore.")

        if (vkCreateSemaphore(device, &&semaphoreInfo, nullptr, &&renderFinishedSemaphore) != VkResult.VK_SUCCESS)
            fail("Failed to create semaphore.")

        if (vkCreateFence(device, &&fenceInfo, nullptr, &&inFlightFence) != VkResult.VK_SUCCESS)
            fail("Failed to create fence.")

        i <- i + 1

    VulkanApplication(enableValidationLayers, instance, surface, physicalDevice, device, graphicsQueue, uint32(graphicsFamilyIndex), computeQueue, uint32(computeFamilyIndex), transferQueue, uint32(transferFamilyIndex), presentQueue, uint32(presentFamilyIndex), debugMessenger, UnsafeCast(imageAvailableSemaphores), UnsafeCast(renderFinishedSemaphores), UnsafeCast(inFlightFences), swapChain, maxFramesInFlight)

Destroy(app: VulkanApplication): () =

    let mutable i = 0
    while (i < app.InFlightFences.Length)
        vkDestroyFence(app.Device, app.InFlightFences[i], nullptr)
        vkDestroySemaphore(app.Device, app.ImageAvailableSemaphores[i], nullptr)
        vkDestroySemaphore(app.Device, app.RenderFinishedSemaphores[i], nullptr)
        i <- i + 1

    let mutable i = 0
    while (i < app.SwapChain.ImageViews.Length)
        vkDestroyImageView(app.Device, app.SwapChain.ImageViews[i], nullptr)
        i <- i + 1
    vkDestroySwapchainKHR(app.Device, app.SwapChain.SwapChain, nullptr)
    
    vkDestroyDevice(app.Device, nullptr)

    vkDestroySurfaceKHR(app.Instance, app.Surface, nullptr)

    if (app.ValidationLayersEnabled)
        destroyDebugUtilsMessengerEXT(app.Instance, app.DebugMessenger, nullptr)

    vkDestroyInstance(app.Instance, nullptr)

CreateShaderModule(app: VulkanApplication, byteCode: ReadOnlySpan<byte>): VkShaderModule =
    createShaderModule(app.Device, byteCode)

DestroyShaderModule(app: VulkanApplication, shaderModule: VkShaderModule): () =
    vkDestroyShaderModule(app.Device, shaderModule, nullptr)

CreatePipelineLayout(app: VulkanApplication): VkPipelineLayout =
    createPipelineLayout(app.Device)

DestroyPipelineLayout(app: VulkanApplication, pipelineLayout: VkPipelineLayout): () =
    vkDestroyPipelineLayout(app.Device, pipelineLayout, nullptr)

CreateRenderPass(app: VulkanApplication): VkRenderPass =
    createRenderPass(app.Device, app.SwapChain.ImageFormat)

DestroyRenderPass(app: VulkanApplication, renderPass: VkRenderPass): () =
    vkDestroyRenderPass(app.Device, renderPass, nullptr)

CreateGraphicsPipeline(app: VulkanApplication, pipelineLayout: VkPipelineLayout, renderPass: VkRenderPass, vertexShaderModule: VkShaderModule, fragmentShaderModule: VkShaderModule): VkPipeline =
    let stages =
        [|
            createShaderStageInfo(vertexShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT);
            createShaderStageInfo(fragmentShaderModule, VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT)
        |]
    createGraphicsPipeline(app.Device, pipelineLayout, renderPass, stages, app.SwapChain.Extent)

DestroyPipeline(app: VulkanApplication, pipeline: VkPipeline): () =
    vkDestroyPipeline(app.Device, pipeline, nullptr)

CreateSwapChainFramebuffers(app: VulkanApplication, renderPass: VkRenderPass): VkFramebuffer[||] =
    Array.MapAsMutable(app.SwapChain.ImageViews, x -> createFramebuffer(app.Device, renderPass, x, app.SwapChain.Extent.width, app.SwapChain.Extent.height))

DestroyFramebuffer(app: VulkanApplication, framebuffer: VkFramebuffer): () =
    vkDestroyFramebuffer(app.Device, framebuffer, nullptr)

DestroyFramebuffers(app: VulkanApplication, mutable framebuffers: ReadOnlySpan<VkFramebuffer>): () =
    let mutable i = 0
    while (i < framebuffers.Length)
        DestroyFramebuffer(app, framebuffers[i])
        i <- i + 1

CreateGraphicsCommandPool(app: VulkanApplication): VkCommandPool =
    createCommandPool(app.Device, app.GraphicsQueueFamilyIndex)

DestroyCommandPool(app: VulkanApplication, commandPool: VkCommandPool): () =
    vkDestroyCommandPool(app.Device, commandPool, nullptr)

CreateCommandBuffer(app: VulkanApplication, commandPool: VkCommandPool): VulkanCommandBuffer =
    VulkanCommandBuffer(createCommandBuffer(app.Device, commandPool))

ResetCommandBuffer(app: VulkanApplication, commandBuffer: VulkanCommandBuffer): () =
    if (vkResetCommandBuffer(commandBuffer.CommandBuffer, default) != VkResult.VK_SUCCESS)
        fail("Failed to reset command buffer.!")

Draw(app: VulkanApplication, acquireCommandBufferByFrame: int32 -> VulkanCommandBuffer): () =
    let currentFrame = app.currentFrame

    let mutable inFlightFence = app.InFlightFences[currentFrame]
    let imageAvailableSemaphore = app.ImageAvailableSemaphores[currentFrame]
    let renderFinishedSemaphore = app.RenderFinishedSemaphores[currentFrame]

    if (vkWaitForFences(app.Device, 1, &&inFlightFence, VkBool32.TRUE, uint64.MaxValue) != VkResult.VK_SUCCESS)
        fail("Failed to wait for fences.")

    if (vkResetFences(app.Device, 1, &&inFlightFence) != VkResult.VK_SUCCESS)
        fail("Failed to reset fences.")

    let mutable imageIndex = default
    if (vkAcquireNextImageKHR(app.Device, app.SwapChain.SwapChain, uint64.MaxValue, imageAvailableSemaphore, VkFence.NULL, &&imageIndex) != VkResult.VK_SUCCESS)
        fail("Failed to acquire next image.")

    let commandBuffer = acquireCommandBufferByFrame(currentFrame)

    draw(app.SwapChain.SwapChain, app.GraphicsQueue, app.PresentQueue, commandBuffer, imageIndex, imageAvailableSemaphore, renderFinishedSemaphore, inFlightFence)

    app.currentFrame <- (app.currentFrame + 1) % app.InFlightFences.Length

WaitForIdle(app: VulkanApplication): () =
    if (vkDeviceWaitIdle(app.Device) != VkResult.VK_SUCCESS)
        fail("Failed to wait for idle on device.")

// ---------------------------------------------------------------------

private alias PFN_vkCreateDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerCreateInfoEXT*, VkAllocationCallbacks*, VkDebugUtilsMessengerEXT*) -> VkResult
private alias PFN_vkDestroyDebugUtilsMessengerEXT = static blittable (VkInstance, VkDebugUtilsMessengerEXT, VkAllocationCallbacks*) -> ()

private createDebugUtilsMessengerEXT(
        instance: VkInstance, 
        pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT*,
        pAllocator: VkAllocationCallbacks*,
        pDebugMessenger: VkDebugUtilsMessengerEXT*
        ): VkResult =

    let pName = "vkCreateDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkCreateDebugUtilsMessengerEXT>(func)
        func(instance, pCreateInfo, pAllocator, pDebugMessenger)
    else
        VkResult.VK_ERROR_EXTENSION_NOT_PRESENT

private destroyDebugUtilsMessengerEXT(instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT, pAllocator: VkAllocationCallbacks*): () =
    let pName = "vkDestroyDebugUtilsMessengerEXT"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func != nint(0))
        let func = UnsafeCast<PFN_vkDestroyDebugUtilsMessengerEXT>(func)
        func(instance, debugMessenger, pAllocator)

private getRequiredExtensions(enableValidationLayers: bool): string[] =
    if (enableValidationLayers)
        [
            Encoding.UTF8.GetString(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
            Encoding.UTF8.GetString(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]
    else
        [
            "VK_KHR_surface";
            "VK_KHR_win32_surface"
        ]

private getRequiredDeviceExtensions(): string[] =
    [
        "VK_KHR_swapchain"
    ]

#[blittable]
private debugCallback(messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT*, pUserData: void*): VkBool32 =
    print("validation layer: ")
    let callback = *pCallbackData
    let str = String(UnsafeCast<int8*>(callback.pMessage))
    printLine(str)
    VkBool32.FALSE

#[blittable]
private debugReportCallback(flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, a: uint64, b: nuint, c: int32, d: int8*, pMessage: int8*, f: void*): VkBool32 =
    print("validation layer: ")
    let str = String(UnsafeCast<int8*>(pMessage))
    printLine(str)
    VkBool32.FALSE

private populateDebugMessengerCreateInfo(createInfo: byref<VkDebugUtilsMessengerCreateInfoEXT>): () =
    createInfo <- default
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
    createInfo.messageSeverity <- VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VkDebugUtilsMessageSeverityFlagsEXT.VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT
    createInfo.messageType <- VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VkDebugUtilsMessageTypeFlagsEXT.VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT
    createInfo.pfnUserCallback <- __oly_load_function_ptr(debugCallback)

private setupDebugMessenger(enableValidationLayers: bool, instance: VkInstance, debugMessenger: VkDebugUtilsMessengerEXT*): () =
    if (enableValidationLayers)
        let mutable createInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&createInfo)

        if (createDebugUtilsMessengerEXT(instance, &&createInfo, nullptr, debugMessenger) != VkResult.VK_SUCCESS)
            fail("Failed to set up debug messenger.")

private createInstance(enableValidationLayers: bool, validationLayers: string[]): VkInstance =
    if (enableValidationLayers && !checkValidationLayerSupport(validationLayers))
        fail("Validation layers were requested, but not available.")

    let appName = "Vulkan Application"
    let engineName = "Vulkan Engine"

    let mutable appNameHandle = fixed(appName)
    let mutable engineNameHandle = fixed(engineName)

    let mutable appInfo = default: VkApplicationInfo
    appInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO
    appInfo.pApplicationName <- UnsafeCast(appNameHandle.AddrOfPinnedObject())
    appInfo.applicationVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.pEngineName <- UnsafeCast(engineNameHandle.AddrOfPinnedObject())
    appInfo.engineVersion <- VK_MAKE_VERSION(1, 0, 0)
    appInfo.apiVersion <- VK_API_VERSION_1_3

    let mutable createInfo = default: VkInstanceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    createInfo.pApplicationInfo <- &&appInfo

    let extensions = getRequiredExtensions(enableValidationLayers)
    let extensionsHandle = fixedCopy(extensions)
    let validationLayersHandle = fixedCopy(validationLayers)

    createInfo.enabledExtensionCount <- uint32(extensions.Length)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(extensionsHandle.Pointer)

    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)

        let mutable debugCreateInfo = default: VkDebugUtilsMessengerCreateInfoEXT
        populateDebugMessengerCreateInfo(&debugCreateInfo)
        createInfo.pNext <- UnsafeCast(&&debugCreateInfo)
    else
        createInfo.enabledLayerCount <- 0
        createInfo.pNext <- nullptr

    let mutable instance = default

    if (vkCreateInstance(&&createInfo, nullptr, &&instance) != VkResult.VK_SUCCESS)
        fail("Failed to create instance.")

    // Cleanup
    appNameHandle.Free()
    engineNameHandle.Free()
    validationLayersHandle.Dispose()
    extensionsHandle.Dispose()

    instance

private createSurface(instance: VkInstance, hwnd: nint, hinstance: nint): VkSurfaceKHR =
    let mutable surface = default: VkSurfaceKHR

    let mutable createInfo = default: VkWin32SurfaceCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
    createInfo.hwnd <- hwnd
    createInfo.hinstance <- hinstance

    let mutable instanceImports = default: VkInstanceManualImports
    let pName = "vkCreateWin32SurfaceKHR"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let func: nint = UnsafeCast(vkGetInstanceProcAddr(instance, UnsafeCast(pNameHandle.AddrOfPinnedObject())))
    pNameHandle.Free()
    if (func == nint(0))
        fail("Failed to query instance function.")
    instanceImports.vkCreateWin32SurfaceKHR <- UnsafeCast(func)
    if (instanceImports.vkCreateWin32SurfaceKHR(instance, &&createInfo, nullptr, &&surface) != VkResult.VK_SUCCESS)
        fail("Failed to create window surface.")
    surface

private createDevice(enableValidationLayers: bool, validationLayers: string[], physicalDevice: VkPhysicalDevice, graphicsFamilyIndex: int32, computeFamilyIndex: int32, transferFamilyIndex: int32, presentFamilyIndex: int32): VkDevice =
    // Graphics Queue
    let mutable graphicsQueuePriority = 1.0: float32
    let mutable graphicsQueueCreateInfo = default: VkDeviceQueueCreateInfo
    graphicsQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    graphicsQueueCreateInfo.queueFamilyIndex <- uint32(graphicsFamilyIndex)
    graphicsQueueCreateInfo.queueCount <- 1
    graphicsQueueCreateInfo.pQueuePriorities <- &&graphicsQueuePriority

    // Compute Queue
    let mutable computeQueuePriority = 1.0: float32
    let mutable computeQueueCreateInfo = default: VkDeviceQueueCreateInfo
    computeQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    computeQueueCreateInfo.queueFamilyIndex <- uint32(computeFamilyIndex)
    computeQueueCreateInfo.queueCount <- 1
    computeQueueCreateInfo.pQueuePriorities <- &&computeQueuePriority

    // Transfer Queue
    let mutable transferQueuePriority = 1.0: float32
    let mutable transferQueueCreateInfo = default: VkDeviceQueueCreateInfo
    transferQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    transferQueueCreateInfo.queueFamilyIndex <- uint32(transferFamilyIndex)
    transferQueueCreateInfo.queueCount <- 1
    transferQueueCreateInfo.pQueuePriorities <- &&transferQueuePriority

    // Present Queue
    let mutable presentQueuePriority = 1.0: float32
    let mutable presentQueueCreateInfo = default: VkDeviceQueueCreateInfo
    presentQueueCreateInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    presentQueueCreateInfo.queueFamilyIndex <- uint32(presentFamilyIndex)
    presentQueueCreateInfo.queueCount <- 1
    presentQueueCreateInfo.pQueuePriorities <- &&presentQueuePriority

    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    let mutable createInfo = default: VkDeviceCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO

    // Queues
    let queueCreateInfos = [graphicsQueueCreateInfo;computeQueueCreateInfo;transferQueueCreateInfo;presentQueueCreateInfo]
    let queueCreateInfos = Array.DistinctBy(queueCreateInfos, x -> x.queueFamilyIndex)
    let mutable queueCreateInfosHandle = fixed(queueCreateInfos)
    createInfo.queueCreateInfoCount <- uint32(queueCreateInfos.Length)
    createInfo.pQueueCreateInfos <- UnsafeCast(queueCreateInfosHandle.AddrOfPinnedObject())
    createInfo.pEnabledFeatures <- &&deviceFeatures

    let validationLayersHandle = fixedCopy(validationLayers)
    if (enableValidationLayers)
        createInfo.enabledLayerCount <- uint32(validationLayers.Length)
        createInfo.ppEnabledLayerNames <- UnsafeCast(validationLayersHandle.Pointer)
    else
        createInfo.enabledLayerCount <- 0

    let deviceExtensions = getRequiredDeviceExtensions()
    if (!checkExtensionsSupport(physicalDevice, deviceExtensions))
        fail("Failed to validate device extensions.")
    
    createInfo.enabledExtensionCount <- uint32(deviceExtensions.Length)
    let requiredDeviceExtensionsHandle = fixedCopy(deviceExtensions)
    createInfo.ppEnabledExtensionNames <- UnsafeCast(requiredDeviceExtensionsHandle.Pointer)  

    let mutable device = default
    if (vkCreateDevice(physicalDevice, &&createInfo, nullptr, &&device) != VkResult.VK_SUCCESS)
        fail("Failed to create device.")

    // Cleanup
    queueCreateInfosHandle.Free()
    requiredDeviceExtensionsHandle.Dispose()

    device

private createSwapChainSupportDetails(device: VkPhysicalDevice, surface: VkSurfaceKHR): VulkanSwapChainSupportDetails =
    let mutable capabilities = default: VkSurfaceCapabilitiesKHR
    let throwAwayResult = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &&capabilities)

    let mutable formatCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, nullptr)

    let formats = Array.ZeroCreate<VkSurfaceFormatKHR>(int32(formatCount))
    let mutable formatsHandle = fixed(formats)
    let throwAwayResult = vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &&formatCount, UnsafeCast(formatsHandle.AddrOfPinnedObject()))
    formatsHandle.Free()

    let mutable presentModeCount = 0: uint32

    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, nullptr)

    let presentModes = Array.ZeroCreate<VkPresentModeKHR>(int32(presentModeCount))
    let mutable presentModesHandle = fixed(presentModes)
    let throwAwayResult = vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &&presentModeCount, UnsafeCast(presentModesHandle.AddrOfPinnedObject()))
    presentModesHandle.Free()

    VulkanSwapChainSupportDetails(capabilities, UnsafeCast(formats), UnsafeCast(presentModes))

private findSwapSurfaceFormat(formats: VkSurfaceFormatKHR[]): VkSurfaceFormatKHR =
    Array.Find(formats, (x: VkSurfaceFormatKHR) -> x.format == VkFormat.VK_FORMAT_B8G8R8A8_SRGB && x.colorSpace == VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)

private findSwapPresentMode(presentModes: VkPresentModeKHR[]): VkPresentModeKHR =
    Array.Find(presentModes,
        (x: VkPresentModeKHR) ->
            x == VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR
    )

private findSwapExtent(capabilities: inref<VkSurfaceCapabilitiesKHR>): VkExtent2D =
    if (capabilities.currentExtent.width != uint32.MaxValue)
        capabilities.currentExtent
    else
        fail("Invalid swap-extent.")
//     VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
//     if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
//         return capabilities.currentExtent;
//     } else {
//         int width, height;
//         glfwGetFramebufferSize(window, &width, &height);

//         VkExtent2D actualExtent = {
//             static_cast<uint32_t>(width),
//             static_cast<uint32_t>(height)
//         };

//         actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
//         actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

//         return actualExtent;
//     }
// }

private createSwapChain(physicalDevice: VkPhysicalDevice, device: VkDevice, surface: VkSurfaceKHR, graphicsFamilyIndex: uint32, presentFamilyIndex: uint32): VulkanSwapChain =
    let details = createSwapChainSupportDetails(physicalDevice, surface)

    let swapChainAdequate =
        details.Formats.Length > 0 && details.PresentModes.Length > 0

    if (!swapChainAdequate)
        fail("Swap chain is not adequate.")

    let surfaceFormat = findSwapSurfaceFormat(details.Formats)
    let presentMode = findSwapPresentMode(details.PresentModes)
    let extent = findSwapExtent(&details.Capabilities)

    // Request at least more than one image.
    let mutable imageCount = details.Capabilities.minImageCount + 1

    if (details.Capabilities.maxImageCount > 0 && imageCount > details.Capabilities.maxImageCount)
        imageCount <- details.Capabilities.maxImageCount   

    let mutable createInfo = default: VkSwapchainCreateInfoKHR
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
    createInfo.surface <- surface
    createInfo.minImageCount <- imageCount
    createInfo.imageFormat <- surfaceFormat.format
    createInfo.imageColorSpace <- surfaceFormat.colorSpace
    createInfo.imageExtent <- extent
    createInfo.imageArrayLayers <- 1
    createInfo.imageUsage <- VkImageUsageFlags.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT

    let queueFamilyIndices = [graphicsFamilyIndex;presentFamilyIndex]
    let mutable queueFamilyIndicesHandle = fixed(queueFamilyIndices)
    if (graphicsFamilyIndex != presentFamilyIndex)
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_CONCURRENT
        createInfo.queueFamilyIndexCount <- 2
        createInfo.pQueueFamilyIndices <- UnsafeCast(queueFamilyIndicesHandle.AddrOfPinnedObject())
    else
        createInfo.imageSharingMode <- VkSharingMode.VK_SHARING_MODE_EXCLUSIVE
        createInfo.queueFamilyIndexCount <- 0 // Optional
        createInfo.pQueueFamilyIndices <- nullptr // Optional

    createInfo.preTransform <- details.Capabilities.currentTransform
    createInfo.compositeAlpha <- VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR

    createInfo.presentMode <- presentMode
    createInfo.clipped <- VkBool32.TRUE
    createInfo.oldSwapchain <- VkSwapchainKHR.NULL

    let mutable swapChain = default
    if (vkCreateSwapchainKHR(device, &&createInfo, nullptr, &&swapChain) != VkResult.VK_SUCCESS)
        fail("Failed to create swap chain.")

    // Getting images
    let images = getSwapChainImages(device, swapChain)
    let imageViews = Array.Map(images, x -> createImageView(device, x, surfaceFormat.format))

    let mutable viewport = default: VkViewport
    viewport.x <- 0
    viewport.y <- 0
    viewport.width <- float32(extent.width)
    viewport.height <- float32(extent.height)
    viewport.minDepth <- 0
    viewport.maxDepth <- 1

    let mutable scissor = default: VkRect2D
    scissor.offset <- default
    scissor.extent <- extent

    VulkanSwapChain(device, swapChain, images, imageViews, extent, viewport, scissor, surfaceFormat.format)

private createImageView(device: VkDevice, image: VkImage, imageFormat: VkFormat): VkImageView =
    let mutable createInfo = default: VkImageViewCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    createInfo.image <- image
    createInfo.viewType <- VkImageViewType.VK_IMAGE_VIEW_TYPE_2D
    createInfo.format <- imageFormat
    createInfo.components.r <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.g <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.b <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY
    createInfo.components.a <- VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY

    createInfo.subresourceRange.aspectMask <- VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT
    createInfo.subresourceRange.baseMipLevel <- 0
    createInfo.subresourceRange.levelCount <- 1
    createInfo.subresourceRange.baseArrayLayer <- 0
    createInfo.subresourceRange.layerCount <- 1

    let mutable imageView = default: VkImageView
    if (vkCreateImageView(device, &&createInfo, nullptr, &&imageView) != VkResult.VK_SUCCESS)
        fail("Failed to create image view.")
    
    imageView

private createShaderModule(device: VkDevice, mutable byteCode: ReadOnlySpan<byte>): VkShaderModule =
    let byteCodeRef = &byteCode.GetPinnableReference()

    let mutable createInfo = default: VkShaderModuleCreateInfo
    createInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    createInfo.codeSize <- nuint(byteCode.Length)
    createInfo.pCode <- UnsafeCast(&&byteCodeRef)

    let mutable shaderModule = default: VkShaderModule
    if (vkCreateShaderModule(device, &&createInfo, nullptr, &&shaderModule) != VkResult.VK_SUCCESS)
        fail("Failed to create shader module.")
        
    shaderModule

private createShaderStageInfo(shaderModule: VkShaderModule, stage: VkShaderStageFlags): VkPipelineShaderStageCreateInfo =
    let mutable shaderStageInfo = default: VkPipelineShaderStageCreateInfo
    shaderStageInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
    shaderStageInfo.stage <- stage
    shaderStageInfo.`module` <- shaderModule
    shaderStageInfo

private createPipelineLayout(device: VkDevice): VkPipelineLayout =
    let mutable pipelineLayoutInfo = default: VkPipelineLayoutCreateInfo
    pipelineLayoutInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
    pipelineLayoutInfo.setLayoutCount <- 0 // Optional
    pipelineLayoutInfo.pSetLayouts <- nullptr // Optional
    pipelineLayoutInfo.pushConstantRangeCount <- 0 // Optional
    pipelineLayoutInfo.pPushConstantRanges <- nullptr // Optional

    let mutable pipelineLayout = default
    if (vkCreatePipelineLayout(device, &&pipelineLayoutInfo, nullptr, &&pipelineLayout) != VkResult.VK_SUCCESS)
        fail("Failed to create pipeline layout.")

    pipelineLayout

private createGraphicsPipeline(device: VkDevice, pipelineLayout: VkPipelineLayout, renderPass: VkRenderPass, stages: VkPipelineShaderStageCreateInfo[||], swapChainExtent: VkExtent2D): VkPipeline =
    let dynamicStates =
        [
            VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT;
            VkDynamicState.VK_DYNAMIC_STATE_SCISSOR
        ]

    let mutable dynamicStatesHandle = fixed(dynamicStates)

    let mutable dynamicState = default: VkPipelineDynamicStateCreateInfo
    dynamicState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
    dynamicState.dynamicStateCount <- uint32(dynamicStates.Length)
    dynamicState.pDynamicStates <- UnsafeCast(dynamicStatesHandle.AddrOfPinnedObject())

    let mutable vertexInputInfo = default: VkPipelineVertexInputStateCreateInfo
    vertexInputInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
    vertexInputInfo.vertexBindingDescriptionCount <- 0
    vertexInputInfo.pVertexBindingDescriptions <- nullptr // Optional
    vertexInputInfo.vertexAttributeDescriptionCount <- 0
    vertexInputInfo.pVertexAttributeDescriptions <- nullptr // Optional

    let mutable inputAssembly = default: VkPipelineInputAssemblyStateCreateInfo
    inputAssembly.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
    inputAssembly.topology <- VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
    inputAssembly.primitiveRestartEnable <- VkBool32.FALSE

    let mutable viewport = default: VkViewport
    viewport.x <- 0
    viewport.y <- 0
    viewport.width <- float32(swapChainExtent.width)
    viewport.height <- float32(swapChainExtent.height)
    viewport.minDepth <- 0
    viewport.maxDepth <- 1

    let mutable scissor = default: VkRect2D
    scissor.offset <- default
    scissor.extent <- swapChainExtent

    let mutable viewportState = default: VkPipelineViewportStateCreateInfo
    viewportState.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
    viewportState.viewportCount <- 1
    viewportState.pViewports <- &&viewport
    viewportState.scissorCount <- 1
    viewportState.pScissors <- &&scissor

    let mutable rasterizer = default: VkPipelineRasterizationStateCreateInfo
    rasterizer.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
    rasterizer.depthClampEnable <- VkBool32.FALSE
    rasterizer.rasterizerDiscardEnable <- VkBool32.FALSE
    rasterizer.polygonMode <- VkPolygonMode.VK_POLYGON_MODE_FILL
    rasterizer.lineWidth <- 1
    rasterizer.cullMode <- VkCullModeFlags.VK_CULL_MODE_BACK_BIT
    rasterizer.frontFace <- VkFrontFace.VK_FRONT_FACE_CLOCKWISE // TODO: Make this counter clockwise at some point.

    // TODO: We will want to enable this at some point.
    rasterizer.depthBiasEnable <- VkBool32.FALSE
    rasterizer.depthBiasConstantFactor <- 0 // Optional
    rasterizer.depthBiasClamp <- 0 // Optional
    rasterizer.depthBiasSlopeFactor <- 0 // Optional

    let mutable multisampling = default: VkPipelineMultisampleStateCreateInfo
    multisampling.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
    multisampling.sampleShadingEnable <- VkBool32.FALSE
    multisampling.rasterizationSamples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    multisampling.minSampleShading <- 1 // Optional
    multisampling.pSampleMask <- nullptr // Optional
    multisampling.alphaToCoverageEnable <- VkBool32.FALSE // Optional
    multisampling.alphaToOneEnable <- VkBool32.FALSE // Optional

    let mutable colorBlendAttachment = default: VkPipelineColorBlendAttachmentState
    colorBlendAttachment.colorWriteMask <- VkColorComponentFlags.VK_COLOR_COMPONENT_R_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_G_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_B_BIT | VkColorComponentFlags.VK_COLOR_COMPONENT_A_BIT
    colorBlendAttachment.blendEnable <- VkBool32.FALSE
    colorBlendAttachment.srcColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
    colorBlendAttachment.dstColorBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
    colorBlendAttachment.colorBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional
    colorBlendAttachment.srcAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ONE // Optional
    colorBlendAttachment.dstAlphaBlendFactor <- VkBlendFactor.VK_BLEND_FACTOR_ZERO // Optional
    colorBlendAttachment.alphaBlendOp <- VkBlendOp.VK_BLEND_OP_ADD // Optional

    let mutable colorBlending = default: VkPipelineColorBlendStateCreateInfo
    colorBlending.sType <- VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
    colorBlending.logicOpEnable <- VkBool32.FALSE
    colorBlending.logicOp <- VkLogicOp.VK_LOGIC_OP_COPY // Optional
    colorBlending.attachmentCount <- 1
    colorBlending.pAttachments <- &&colorBlendAttachment

    // TODO: What do we do about the fixed buffer here?
    colorBlending.blendConstants.FixedElementField <- 0 // Optional
// colorBlending.blendConstants[0] = 0.0f; // Optional
// colorBlending.blendConstants[1] = 0.0f; // Optional
// colorBlending.blendConstants[2] = 0.0f; // Optional
// colorBlending.blendConstants[3] = 0.0f; // Optional

    let pName = "main"
    let mutable pNameHandle = fixedCopyUTF8(pName)
    let stageCount = stages.Length
    let mutable i = 0
    while (i < stageCount)
        stages[i].pName <- UnsafeCast(pNameHandle.AddrOfPinnedObject())
        i <- i + 1
    let mutable stagesHandle = fixed(stages)

    let mutable pipelineInfo = default: VkGraphicsPipelineCreateInfo
    pipelineInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
    pipelineInfo.stageCount <- uint32(stageCount)
    pipelineInfo.pStages <- UnsafeCast(stagesHandle.AddrOfPinnedObject())
    pipelineInfo.pVertexInputState <- &&vertexInputInfo
    pipelineInfo.pInputAssemblyState <- &&inputAssembly
    pipelineInfo.pViewportState <- &&viewportState
    pipelineInfo.pRasterizationState <- &&rasterizer
    pipelineInfo.pMultisampleState <- &&multisampling
    pipelineInfo.pDepthStencilState <- nullptr // Optional
    pipelineInfo.pColorBlendState <- &&colorBlending
    pipelineInfo.pDynamicState <- &&dynamicState
    pipelineInfo.layout <- pipelineLayout
    pipelineInfo.renderPass <- renderPass
    pipelineInfo.subpass <- 0
    pipelineInfo.basePipelineHandle <- VkPipeline.NULL // Optional
    pipelineInfo.basePipelineIndex <- -1 // Optional

    let mutable graphicsPipeline = default
    if (vkCreateGraphicsPipelines(device, VkPipelineCache.NULL, 1, &&pipelineInfo, nullptr, &&graphicsPipeline) != VkResult.VK_SUCCESS)
        fail("Failed to create graphics pipeline.")

    // Cleanup
    stagesHandle.Free()
    pNameHandle.Free()
    dynamicStatesHandle.Free()
    
    graphicsPipeline

private createRenderPass(device: VkDevice, swapChainImageFormat: VkFormat): VkRenderPass =
    let mutable colorAttachment = default: VkAttachmentDescription
    colorAttachment.format <- swapChainImageFormat
    colorAttachment.samples <- VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT
    colorAttachment.loadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR
    colorAttachment.storeOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_STORE
    colorAttachment.stencilLoadOp <- VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE
    colorAttachment.stencilStoreOp <- VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE
    colorAttachment.initialLayout <- VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED
    colorAttachment.finalLayout <- VkImageLayout.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR

    let mutable colorAttachmentRef = default: VkAttachmentReference
    colorAttachmentRef.attachment <- 0
    colorAttachmentRef.layout <- VkImageLayout.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL

    let mutable subpass = default: VkSubpassDescription
    subpass.pipelineBindPoint <- VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS
    subpass.colorAttachmentCount <- 1
    subpass.pColorAttachments <- &&colorAttachmentRef

    let mutable dependency = default: VkSubpassDependency
    dependency.srcSubpass <- VK_SUBPASS_EXTERNAL
    dependency.dstSubpass <- 0
    dependency.srcStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
    dependency.srcAccessMask <- default
    dependency.dstStageMask <- VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
    dependency.dstAccessMask <- VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT

    let mutable renderPassInfo = default: VkRenderPassCreateInfo
    renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
    renderPassInfo.attachmentCount <- 1
    renderPassInfo.pAttachments <- &&colorAttachment
    renderPassInfo.subpassCount <- 1
    renderPassInfo.pSubpasses <- &&subpass
    renderPassInfo.dependencyCount <- 1
    renderPassInfo.pDependencies <- &&dependency

    let mutable renderPass = default
    if (vkCreateRenderPass(device, &&renderPassInfo, nullptr, &&renderPass) != VkResult.VK_SUCCESS)
        fail("Failed to create render pass.")
    
    renderPass

private createFramebuffer(device: VkDevice, renderPass: VkRenderPass, imageView: VkImageView, width: uint32, height: uint32): VkFramebuffer =
    let mutable framebufferInfo = default: VkFramebufferCreateInfo
    framebufferInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    framebufferInfo.renderPass <- renderPass
    framebufferInfo.attachmentCount <- 1
    framebufferInfo.pAttachments <- &&imageView
    framebufferInfo.width <- width
    framebufferInfo.height <- height
    framebufferInfo.layers <- 1

    let mutable framebuffer = default
    if (vkCreateFramebuffer(device, &&framebufferInfo, nullptr, &&framebuffer) != VkResult.VK_SUCCESS)
        fail("Failed to create framebuffer.")
    
    framebuffer

private createCommandPool(device: VkDevice, queueFamilyIndex: uint32): VkCommandPool =
    let mutable poolInfo = default: VkCommandPoolCreateInfo
    poolInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
    poolInfo.flags <- VkCommandPoolCreateFlags.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
    poolInfo.queueFamilyIndex <- queueFamilyIndex

    let mutable commandPool = default
    if (vkCreateCommandPool(device, &&poolInfo, nullptr, &&commandPool) != VkResult.VK_SUCCESS)
        fail("Failed to create command pool.")

    commandPool

private createCommandBuffer(device: VkDevice, commandPool: VkCommandPool): VkCommandBuffer =
    let mutable allocInfo = default: VkCommandBufferAllocateInfo
    allocInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    allocInfo.commandPool <- commandPool
    allocInfo.level <- VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_PRIMARY
    allocInfo.commandBufferCount <- 1

    let mutable commandBuffer = default
    if (vkAllocateCommandBuffers(device, &&allocInfo, &&commandBuffer) != VkResult.VK_SUCCESS)
        fail("Failed to allocate command buffer.")

    commandBuffer

// -----------------------------------------------------------------------

private getInstanceLayerProperties(): VkLayerProperties[] =
    let mutable layerCount = 0: uint32

    if (vkEnumerateInstanceLayerProperties(&&layerCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")

    let availableLayers = Array.ZeroCreate<VkLayerProperties>(int32(layerCount))
    let mutable availableLayersHandle = fixed(availableLayers)
    if (vkEnumerateInstanceLayerProperties(&&layerCount, UnsafeCast(availableLayersHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate instance layer properties.")
    availableLayersHandle.Free()

    UnsafeCast<VkLayerProperties[]>(availableLayers)

private getPhysicalDevices(instance: VkInstance): VkPhysicalDevice[] =
    let mutable deviceCount = 0: uint32

    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, nullptr) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")

    let availableDevices = Array.ZeroCreate<VkPhysicalDevice>(int32(deviceCount))
    let mutable availableDevicesHandle = fixed(availableDevices)
    if (vkEnumeratePhysicalDevices(instance, &&deviceCount, UnsafeCast(availableDevicesHandle.AddrOfPinnedObject())) != VkResult.VK_SUCCESS)
        fail("Failed to enumerate physical devices.")
    availableDevicesHandle.Free()

    UnsafeCast<VkPhysicalDevice[]>(availableDevices)

private getPhysicalDeviceQueueFamilyProperties(device: VkPhysicalDevice): VkQueueFamilyProperties[] =
    let mutable queueFamilyCount = 0: uint32

    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, nullptr)

    let queueFamilies = Array.ZeroCreate<VkQueueFamilyProperties>(int32(queueFamilyCount))
    let mutable queueFamiliesHandle = fixed(queueFamilies)
    vkGetPhysicalDeviceQueueFamilyProperties(device, &&queueFamilyCount, UnsafeCast(queueFamiliesHandle.AddrOfPinnedObject()))
    queueFamiliesHandle.Free()

    UnsafeCast<VkQueueFamilyProperties[]>(queueFamilies)

private getDeviceExtensionProperties(device: VkPhysicalDevice): VkExtensionProperties[] =
    let mutable extensionCount = 0: uint32

    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, nullptr)

    let extensions = Array.ZeroCreate<VkExtensionProperties>(int32(extensionCount))
    let mutable extensionsHandle = fixed(extensions)
    let throwAwayResult = vkEnumerateDeviceExtensionProperties(device, nullptr, &&extensionCount, UnsafeCast(extensionsHandle.AddrOfPinnedObject()))
    extensionsHandle.Free()

    UnsafeCast(extensions)

private getSwapChainImages(device: VkDevice, swapChain: VkSwapchainKHR): VkImage[] =
    let mutable imageCount = 0: uint32
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, nullptr)
    
    let images = Array.ZeroCreate<VkImage>(int32(imageCount))
    let mutable imagesHandle = fixed(images)
    let throwAwayResult = vkGetSwapchainImagesKHR(device, swapChain, &&imageCount, UnsafeCast(imagesHandle.AddrOfPinnedObject()))
    imagesHandle.Free()

    UnsafeCast(images)

// -----------------------------------------------------------------------

private findSuitableDevice(devices: VkPhysicalDevice[]): VkPhysicalDevice =
    Array.MaxByUInt32(devices, getDeviceSuitableScore)

private getDeviceSuitableScore(device: VkPhysicalDevice): uint32 =
    let mutable deviceProperties = default: VkPhysicalDeviceProperties
    let mutable deviceFeatures = default: VkPhysicalDeviceFeatures

    vkGetPhysicalDeviceProperties(device, &&deviceProperties)
    vkGetPhysicalDeviceFeatures(device, &&deviceFeatures)

    let score =
        match (deviceProperties.deviceType)
        | VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU when (deviceFeatures.geometryShader == VkBool32.TRUE) =>
            1000 + deviceProperties.limits.maxImageDimension2D
        | _ =>
            0

    // let deviceName = String(UnsafeCast<int8*>(&&deviceProperties.deviceName))
    // print("Device Name and Score: ")
    // print(deviceName)
    // print(" - Score ")
    // print(score)
    // print("\n")

    score

private checkValidationLayerSupport(validationLayers: string[]): bool =
    if (validationLayers.Length == 0)
        true
    else
        let availableLayers = getInstanceLayerProperties()

        let mutable found = true

        let mutable i = 0
        while (i < validationLayers.Length)
            let mutable foundLayer = false

            let mutable j = 0
            while (j < availableLayers.Length)
                let layerProperties = availableLayers[j]
                let layerName = String(UnsafeCast<int8*>(&&layerProperties.layerName))
                if (layerName == validationLayers[i])
                    foundLayer <- true
                j <- j + 1

            if (!foundLayer)
                found <- false

            i <- i + 1

        found

private checkExtensionsSupport(device: VkPhysicalDevice, deviceExtensions: string[]): bool =
    if (deviceExtensions.Length == 0)
        true
    else
        let availableExtensions = getDeviceExtensionProperties(device)

        let mutable found = true

        let mutable i = 0
        while (i < deviceExtensions.Length)
            let mutable foundExtension = false

            let mutable j = 0
            while (j < availableExtensions.Length)
                let extensionProperties = availableExtensions[j]
                let extensionName = String(UnsafeCast<int8*>(&&extensionProperties.extensionName))
                if (extensionName == deviceExtensions[i])
                    foundExtension <- true
                j <- j + 1

            if (!foundExtension)
                found <- false

            i <- i + 1

        found

// -----------------------------------------------------------------------

alias VkPipelineBindPoint = TerraFX.Interop.Vulkan.VkPipelineBindPoint

/// Runtime alias for 'VkCommandBuffer'.
newtype VulkanCommandBuffer =
    CommandBuffer: VkCommandBuffer

    Begin(): () =
        let mutable beginInfo = default: VkCommandBufferBeginInfo
        beginInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
        beginInfo.flags <- default // Optional
        beginInfo.pInheritanceInfo <- nullptr // Optional

        if (vkBeginCommandBuffer(this.CommandBuffer, &&beginInfo) != VkResult.VK_SUCCESS)
            fail("Failed to begin recording command buffer.")

    BeginRenderPass(renderPass: VkRenderPass, framebuffer: VkFramebuffer, extent: VkExtent2D): () =
        let mutable renderPassInfo = default: VkRenderPassBeginInfo
        renderPassInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
        renderPassInfo.renderPass <- renderPass
        renderPassInfo.framebuffer <- framebuffer
        renderPassInfo.renderArea.offset.x <- 0
        renderPassInfo.renderArea.offset.y <- 0
        renderPassInfo.renderArea.extent <- extent

        let mutable clearValue = default: VkClearValue
        let mutable clearColorValue = default: VkClearColorValue
        let mutable clearDepthStencilValue = default: VkClearDepthStencilValue

        let clearColorValue0 = &clearColorValue.float32.FixedElementField
        let clearColorValue1 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(4))
        let clearColorValue2 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(8))
        let clearColorValue3 = &Unsafe.AddByteOffset(&clearColorValue0, nuint(12))

        clearColorValue0 <- 0
        clearColorValue1 <- 0
        clearColorValue2 <- 0
        clearColorValue3 <- 1

        clearValue.color <- clearColorValue
        clearValue.depthStencil <- clearDepthStencilValue
        renderPassInfo.clearValueCount <- 1
        renderPassInfo.pClearValues <- &&clearValue

        vkCmdBeginRenderPass(this.CommandBuffer, &&renderPassInfo, VkSubpassContents.VK_SUBPASS_CONTENTS_INLINE)

    BindPipeline(pipeline: VkPipeline, pipelineBindPoint: VkPipelineBindPoint): () =
        vkCmdBindPipeline(this.CommandBuffer, pipelineBindPoint, pipeline)

    SetViewport(mutable viewport: VkViewport): () =
        vkCmdSetViewport(this.CommandBuffer, 0, 1, &&viewport)

    SetScissor(mutable scissor: VkRect2D): () =
        vkCmdSetScissor(this.CommandBuffer, 0, 1, &&scissor)

    Draw(vertexCount: uint32, instanceCount: uint32): () =
        vkCmdDraw(this.CommandBuffer, vertexCount, instanceCount, 0, 0)

    EndRenderPass(): () =
        vkCmdEndRenderPass(this.CommandBuffer)

    End(): () =
        if (vkEndCommandBuffer(this.CommandBuffer) != VkResult.VK_SUCCESS)
            fail("Failed to record command buffer.")

private draw(mutable swapChain: VkSwapchainKHR, graphicsQueue: VkQueue, presentQueue: VkQueue, commandBuffer: VkCommandBuffer, mutable imageIndex: uint32, imageAvailableSemaphore: VkSemaphore, renderFinishedSemaphore: VkSemaphore, inFlightFence: VkFence): () =
    let mutable submitInfo = default: VkSubmitInfo
    submitInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO

    let mutable waitSemaphore = imageAvailableSemaphore
    let mutable waitStage = VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT

    submitInfo.waitSemaphoreCount <- 1
    submitInfo.pWaitSemaphores <- &&waitSemaphore
    submitInfo.pWaitDstStageMask <- &&waitStage
    submitInfo.commandBufferCount <- 1
    submitInfo.pCommandBuffers <- &&commandBuffer

    let mutable signalSemaphore = renderFinishedSemaphore
    
    submitInfo.signalSemaphoreCount <- 1
    submitInfo.pSignalSemaphores <- &&signalSemaphore

    if (vkQueueSubmit(graphicsQueue, 1, &&submitInfo, inFlightFence) != VkResult.VK_SUCCESS)
        fail("Failed to submit draw command buffer.")

    let mutable presentInfo = default: VkPresentInfoKHR
    presentInfo.sType <- VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR

    presentInfo.waitSemaphoreCount <- 1
    presentInfo.pWaitSemaphores <- &&signalSemaphore

    presentInfo.swapchainCount <- 1
    presentInfo.pSwapchains <- &&swapChain

    presentInfo.pImageIndices <- &&imageIndex
    presentInfo.pResults <- nullptr // Optional

    if (vkQueuePresentKHR(presentQueue, &&presentInfo) != VkResult.VK_SUCCESS)
        fail("Failed to present.")