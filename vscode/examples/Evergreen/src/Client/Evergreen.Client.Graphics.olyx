#target "dotnet: net7"
#library

#reference "../../../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"

namespace Evergreen.Client.Graphics

open System
open System.Text
open System.Numerics
open System.Threading
open System.Collections.Concurrent
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV

private alias VeldridShaderDescription = Veldrid.ShaderDescription
private alias VeldridShader = Veldrid.Shader

sealed class MeshDescription =
    mutable Vertices: Vector3[||]
    mutable Indices:  uint16[||]

    private new(vertices: Vector3[||], indices: uint16[||]) =
        {
            Vertices = vertices;
            Indices = indices
        }

    static Create(vertices: Vector3[||], indices: uint16[||]): MeshDescription =
        MeshDescription(vertices, indices)

    static CreateQuad(): MeshDescription =
        let scale = 1: float32

        let vertices =
            [|
                Vector3(-scale,  scale, 0);
                Vector3( scale,  scale, 0);
                Vector3(-scale, -scale, 0);
                Vector3( scale, -scale, 0)
            |]
    
        let indices = [| 0; 1; 2; 3: uint16 |]

        MeshDescription(vertices, indices)

    static CreateHexagon(): MeshDescription =
        let scale = 1: float32
        let vertices =
            [|
                Vector3(     0,              0, 0); // center
                Vector3(  -0.5 * scale,  scale, 0); // left top
                Vector3(   0.5 * scale,  scale, 0); // right top
                Vector3(         scale,      0, 0); // right
                Vector3(   0.5 * scale, -scale, 0); // right bottom
                Vector3(  -0.5 * scale, -scale, 0); // left bottom
                Vector3(        -scale,      0, 0)  // left
            |]

        let indices =
            [|
                0; 1; 2;
                0; 2; 3;               
                0; 3; 4;
                0; 4; 5;
                0; 5; 6;
                0; 6; 1;
                0: uint16
            |]

        MeshDescription(vertices, indices)

sealed class ShaderDescription =
    internal mutable VertexLayouts:  VertexLayoutDescription[||]
    internal mutable VertexShader:   VeldridShaderDescription
    internal mutable FragmentShader: VeldridShaderDescription

    private new(vertexLayouts: VertexLayoutDescription[||], vertexShader: VeldridShaderDescription, fragmentShader: VeldridShaderDescription) =
        {
            VertexLayouts = vertexLayouts;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static CreateMeshShader(vertexShaderBytes: byte[||], fragmentShaderBytes: byte[||]): ShaderDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3)
                |]
            )

        let mutable instanceLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Transform_Column0", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column1", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column2", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column3", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4)
                |]
            )
        instanceLayout.InstanceStepRate <- 1
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                vertexShaderBytes,
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                fragmentShaderBytes,
                "main"
            )

        ShaderDescription([|vertexLayout;instanceLayout|], vertexShader, fragmentShader)

sealed class ComputeShaderDescription =
    internal mutable ComputeShader: VeldridShaderDescription

    private new(computeShader: VeldridShaderDescription) =
        {
            ComputeShader = computeShader
        }

    static CreateMeshLayout(computeShaderBytes: byte[||]): ComputeShaderDescription =
        let computeShader =
            ShaderDescription(
                ShaderStages.Compute,
                computeShaderBytes,
                "main"
            )

        ComputeShaderDescription(computeShader)

sealed class Mesh =
    implements IDisposable

    internal VertexBuffer: DeviceBuffer
    internal IndexBuffer:  DeviceBuffer
    internal IndexCount:   uint32

    internal new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer, indexCount: uint32) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer;
            IndexCount = indexCount
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

sealed class Instances =
    implements IDisposable

    internal mutable Count: int32
    internal mutable TransformBuffer: DeviceBuffer

    internal new(transformBuffer: DeviceBuffer) =
        {
            Count = 0
            TransformBuffer = transformBuffer
        }

    Dispose(): () =
        this.TransformBuffer.Dispose()

private sealed class ShaderState =
    internal VertexShader:   VeldridShader
    internal FragmentShader: VeldridShader
    internal ResourceSets:    ResourceSet[||]
    internal Pipeline:       Pipeline

    internal new(vertexShader: VeldridShader, fragmentShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

private sealed class ComputeShaderState =
    internal ComputeShader: VeldridShader
    internal ResourceSets:   ResourceSet[||]
    internal Pipeline:      Pipeline

    internal new(computeShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            ComputeShader = computeShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

sealed class Shader =
    implements IDisposable

    internal mutable State: ShaderState

    internal new(state: ShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.VertexShader.Dispose()
        this.State.FragmentShader.Dispose()

sealed class ComputeShader =
    implements IDisposable

    internal mutable State: ComputeShaderState

    internal new(state: ComputeShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.ComputeShader.Dispose()

enum DrawCommandKind =
    | DrawMesh
    | RunComputeShader

class DrawCommand =
    Kind: DrawCommandKind

    new(kind: DrawCommandKind) =
        {
            Kind = kind
        }

    private sealed class DrawMesh =
        inherits DrawCommand

        Mesh:      Mesh
        Shader:    Shader
        Instances: Instances

        new(mesh: Mesh, shader: Shader, instances: Instances) =
            base(DrawCommandKind.DrawMesh) with
                {
                    Mesh = mesh;
                    Shader = shader;
                    Instances = instances
                }

    static CreateDrawMesh(mesh: Mesh, shader: Shader, instances: Instances): DrawCommand =
        DrawCommand.DrawMesh(mesh, shader, instances)

    pattern DrawMesh(cmd: DrawCommand): (mesh: Mesh, shader: Shader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawMesh)) =>
        let impl = UnsafeCast<DrawCommand.DrawMesh>(cmd)
        (impl.Mesh, impl.Shader, impl.Instances)

    private sealed class RunComputeShader =
        inherits DrawCommand

        ComputeShader: ComputeShader
        Count: uint32

        new(computeShader: ComputeShader, count: uint32) =
            base(DrawCommandKind.RunComputeShader) with
                {
                    ComputeShader = computeShader
                    Count = count
                }

    static CreateRunComputeShader(computeShader: ComputeShader, count: uint32): DrawCommand =
        DrawCommand.RunComputeShader(computeShader, count)

    pattern RunComputeShader(cmd: DrawCommand): (computeShader: ComputeShader, count: uint32) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.RunComputeShader)) =>
        let impl = UnsafeCast<DrawCommand.RunComputeShader>(cmd)
        (impl.ComputeShader, impl.Count)

enum KeyEventKind =
    | Pressed
    | Released

alias KeyEvent = Veldrid.KeyEvent
alias Key = Veldrid.Key

alias MouseEvent = Veldrid.MouseEvent

sealed class InputState =
    KeyEvents: KeyEvent[||]
    MouseEvents: MouseEvent[||]
    mutable MousePosition: Vector2
    mutable MouseDelta: Vector2

    internal new(keyEvents: KeyEvent[||], mouseEvents: MouseEvent[||]) =
        {
            KeyEvents = keyEvents
            MouseEvents = mouseEvents
            MousePosition = Vector2.Zero
            MouseDelta = Vector2.Zero
        }

sealed class Window =
    internal window: Sdl2Window

    internal new(x: int32, y: int32, width: int32, height: int32, title: string) =
        let windowCreateInfo = WindowCreateInfo(x, y, width, height, WindowState.Normal, title)
        let window = VeldridStartup.CreateWindow(windowCreateInfo)
        {
            window = window
        }

    GetInputState(): InputState =
        let snapshot = this.window.PumpEvents()
        let keyEvents = System.Linq.Enumerable.ToArray<KeyEvent>(snapshot.KeyEvents)
        let mouseEvents = System.Linq.Enumerable.ToArray<MouseEvent>(snapshot.MouseEvents)
        let state = InputState(keyEvents, mouseEvents)
        state.MousePosition <- snapshot.MousePosition
        state.MouseDelta <- this.window.MouseDelta
        state

    SetFullscreen(value: bool): () =
        if (value)
            this.window.WindowState <- WindowState.FullScreen
        else
            this.window.WindowState <- WindowState.Normal

    IsFullscreen: bool 
        get() = 
            fromEnum<WindowState>(this.window.WindowState) == fromEnum<WindowState>(WindowState.FullScreen)

    HideCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(true)
        this.window.CursorVisible <- false

    ShowCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(false)
        this.window.CursorVisible <- true

    Close(): () =
        this.window.Close()

    Exists: bool
        get() = this.window.Exists

module Graphics =

    private mutable window: Window = unchecked default
    private mutable graphicsDevice: GraphicsDevice = null
    private mutable factory: ResourceFactory = null
    private mutable commandList: CommandList = null

    private mutable globalUniformBuffer: DeviceBuffer = null

    DeviceName: string get() = graphicsDevice.DeviceName

    CreateWindow(x: int32, y: int32, width: int32, height: int32, title: string): Window =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window !== unchecked default)
            fail("Window already created.")

        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

        window <- Window(x, y, width, height, title)

        let mutable options = default: GraphicsDeviceOptions
        options.PreferStandardClipSpaceYDirection <- true
        options.PreferDepthRangeZeroToOne <- true  
       // options.SyncToVerticalBlank <- true      

        graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window.window, options, GraphicsBackend.Vulkan)
        factory <- graphicsDevice.ResourceFactory
        commandList <- factory.CreateCommandList()

        // Default resource set
        //
        globalUniformBuffer <- createGlobalUniformBuffer(Matrix4x4.Identity, 0, 0)
        //
        //

        window

    CreateMesh(meshDesc: MeshDescription): Mesh =
        let vertices = meshDesc.Vertices
        let indices  = meshDesc.Indices
    
        let vertexCount = uint32(vertices.Length)
        let indexCount  = uint32(indices.Length)
    
        let vertexBuffer = factory.CreateBuffer(BufferDescription(vertexCount * ((4: uint32) * 3), BufferUsage.VertexBuffer))
        let indexBuffer = factory.CreateBuffer(BufferDescription(indexCount * 2 /* sizeof<uint16> */, BufferUsage.IndexBuffer))
    
        graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertices)
        graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)
    
        Mesh(vertexBuffer, indexBuffer, indexCount)

    private struct ResourceSetGroup =
        ResourceLayouts: ResourceLayout[||]
        ResourceSets: ResourceSet[||]

        new(resourceLayouts: ResourceLayout[||], resourceSets: ResourceSet[||]) =
            {
                ResourceLayouts = resourceLayouts;
                ResourceSets = resourceSets
            }

    private CreateResourceSets(instances: Instances, shaderStages: ShaderStages, transformResourceKind: ResourceKind): ResourceSetGroup =
        // ------------------------------------------------------------
        let resourceLayoutDesc =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Global", ResourceKind.UniformBuffer, shaderStages)
                |]
            )
        let resourceLayout = factory.CreateResourceLayout(resourceLayoutDesc)
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    (globalUniformBuffer: BindableResource)
                |]
            )
        let resourceSet = factory.CreateResourceSet(resourceSetDesc)

        let resourceLayoutDesc2 =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Transforms", transformResourceKind, shaderStages)
                |]
            )
        let resourceLayout2 = factory.CreateResourceLayout(resourceLayoutDesc2)
        let resourceSetDesc2 = 
            ResourceSetDescription(
                resourceLayout2,
                [|
                    (instances.TransformBuffer: BindableResource)
                |]
            )
        let resourceSet2 = factory.CreateResourceSet(resourceSetDesc2)

        ResourceSetGroup([|resourceLayout;resourceLayout2|], [|resourceSet;resourceSet2|])
        // ----------------------------------------------------------------
    
    private CreateShaderState(shaderDesc: ShaderDescription, instances: Instances): ShaderState =
        let vertexLayouts      = shaderDesc.VertexLayouts
        let vertexShaderDesc   = shaderDesc.VertexShader
        let fragmentShaderDesc = shaderDesc.FragmentShader
    
        let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)
    
        let mutable pipelineDesc = default: GraphicsPipelineDescription
        pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend
    
        pipelineDesc.DepthStencilState <-
            let mutable desc = default: DepthStencilStateDescription
            desc.DepthTestEnabled <- true
            desc.DepthWriteEnabled <- true
            desc.DepthComparison <- ComparisonKind.LessEqual
            desc
    
        pipelineDesc.RasterizerState <-
            let mutable desc = default: RasterizerStateDescription
            desc.CullMode <- FaceCullMode.Back
            desc.FillMode <- PolygonFillMode.Solid
            desc.FrontFace <- FrontFace.Clockwise
            desc.DepthClipEnabled <- true
            desc.ScissorTestEnabled <- false
            desc
    
        pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleStrip

        pipelineDesc.ShaderSet <-
            let mutable desc = default: ShaderSetDescription
            desc.VertexLayouts <- vertexLayouts
            desc.Shaders <- shaders
            desc

        let resourceSetGroup = CreateResourceSets(instances, ShaderStages.Vertex, ResourceKind.StructuredBufferReadOnly)
    
        pipelineDesc.ResourceLayouts <- resourceSetGroup.ResourceLayouts
        pipelineDesc.Outputs <- graphicsDevice.SwapchainFramebuffer.OutputDescription
        let pipeline = factory.CreateGraphicsPipeline(pipelineDesc)
    
        ShaderState(shaders[0], shaders[1], resourceSetGroup.ResourceSets, pipeline)

    private CreateComputeShaderState(shaderDesc: ComputeShaderDescription, instances: Instances): ComputeShaderState =
        let computeShaderDesc = shaderDesc.ComputeShader
    
        let shader = ResourceFactoryExtensions.CreateFromSpirv(factory, computeShaderDesc)

        let resourceSetGroup = CreateResourceSets(instances, ShaderStages.Compute, ResourceKind.StructuredBufferReadWrite)
    
        let pipelineDesc = 
            ComputePipelineDescription(
                shader, 
                resourceSetGroup.ResourceLayouts, 
                1, 
                1, 
                1
            )

        let pipeline = factory.CreateComputePipeline(pipelineDesc)
    
        ComputeShaderState(shader, resourceSetGroup.ResourceSets, pipeline)

    CreateShader(shaderDesc: ShaderDescription, instances: Instances): Shader =
        Shader(CreateShaderState(shaderDesc, instances))

    CreateComputeShader(computeShaderDesc: ComputeShaderDescription, instances: Instances): ComputeShader =
        ComputeShader(CreateComputeShaderState(computeShaderDesc, instances))

    // UpdateShader(shader: Shader, shaderDesc: ShaderDescription): () =
    //     let newState = CreateShaderState(shaderDesc)
    //     let oldState = Interlocked.Exchange(&shader.State, newState)
    //     oldState.Pipeline.Dispose()
    //     oldState.FragmentShader.Dispose()
    //     oldState.VertexShader.Dispose()

    private createGlobalUniformBuffer(viewProj: Matrix4x4, deltaTime: float32, slot: uint32): DeviceBuffer =
        let buffer = factory.CreateBuffer(BufferDescription((64: uint32) + 16, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))
        graphicsDevice.UpdateBuffer(buffer, 0, viewProj)
        graphicsDevice.UpdateBuffer(buffer, 64, deltaTime)
        buffer

    SetDeltaTime(value: float32): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 64, value)

    SetModelViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 0, value)

    CreateInstances(transforms: Matrix4x4[||]): Instances =
        let usage: BufferUsage = BufferUsage.StructuredBufferReadWrite
        let transformBuffer = factory.CreateBuffer(BufferDescription(uint32(transforms.Length) * 64, usage, uint32(transforms.Length) * 64))  
        graphicsDevice.UpdateBuffer(transformBuffer, 0, transforms)

        let instances = Instances(transformBuffer)
        instances.Count <- transforms.Length
        instances

    private delayed: ConcurrentQueue<() -> ()> = ConcurrentQueue()

    Draw(drawCmds: DrawCommand[]): () =
        // Begin() must be called before commands can be issued
        commandList.Begin()

        let mutable f = unchecked default
        while (delayed.TryDequeue(&f))
            f()
    
        // We want to render directly to the output window.
        commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
        commandList.ClearColorTarget(0, RgbaFloat.Black)

        let mutable currentPipeline = unchecked default

        // Set all relevant state to draw our quad
        let mutable i = 0
        let length = getLength(drawCmds)
        while (i < length)
            match (drawCmds[i])
            | DrawCommand.DrawMesh(mesh, shader, instances) =>
                let instanceCount = uint32(instances.Count)

                if (instanceCount > 0)   
                    let pipeline = shader.State.Pipeline
                    if (pipeline !== currentPipeline)
                        let resourceSets = shader.State.ResourceSets
                        commandList.SetPipeline(pipeline)
                        let mutable i = 0
                        while (i < resourceSets.Length)
                            commandList.SetGraphicsResourceSet(uint32(i), resourceSets[i])
                            i <- i + 1
                        currentPipeline <- pipeline

                    let transformBuffer = instances.TransformBuffer
                    let vertexBuffer    = mesh.VertexBuffer
                    let indexBuffer     = mesh.IndexBuffer
                    let indexCount      = mesh.IndexCount

                    commandList.SetVertexBuffer(0, vertexBuffer)
                    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt16)
            
                    commandList.DrawIndexed(
                        indexCount,     /* indexCount */
                        instanceCount,  /* instanceCount */
                        0,              /* indexStart */
                        0,              /* vertexOffset */
                        0               /* instanceStart */
                    )

            | DrawCommand.RunComputeShader(computeShader, count) =>
                let pipeline = computeShader.State.Pipeline
                if (pipeline !== currentPipeline)
                    let resourceSets = computeShader.State.ResourceSets
                    commandList.SetPipeline(pipeline)
                    let mutable i = 0
                    while (i < resourceSets.Length)
                        commandList.SetComputeResourceSet(uint32(i), resourceSets[i])
                        i <- i + 1
                    currentPipeline <- pipeline

                commandList.Dispatch(count, 1, 1)

            | _ =>
                ()
    
            i <- i + 1
    
        // End() must be called before commands can be submitted for execution.
        commandList.End()
        graphicsDevice.SubmitCommands(commandList)
    
        // Once commands have been submitted, the rendered image can be presented to the application window.
        graphicsDevice.SwapBuffers()

    DestroyWindow(): () =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window === unchecked default)
            fail("Window not created. Unable to destroy window.")

        window.Close()
        window <- unchecked default
        commandList.Dispose()
        graphicsDevice.Dispose()

    SetVSync(enabled: bool): () =
        graphicsDevice.SyncToVerticalBlank <- enabled
