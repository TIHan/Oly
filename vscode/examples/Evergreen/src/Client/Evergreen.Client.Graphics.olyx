#target "dotnet: net7"
#library

#load "*.oly"

#reference "../../../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"
#package "Veldrid.ImGui,5.89.2-ga121087cad"
#package "Veldrid.ImageSharp,4.9.0"

namespace Evergreen.Client.Graphics

open System
open System.Text
open System.Numerics
open System.Threading
open System.Collections.Concurrent
open System.Runtime.InteropServices
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV
open ImGuiNET
open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

private alias VeldridShaderDescription = Veldrid.ShaderDescription
private alias VeldridShader = Veldrid.Shader

sealed class MeshDescription =
    mutable Vertices:   Vector3[||]
    mutable Indices:    uint32[||]
    mutable Normals:    Vector3[||]
    mutable TexCoords:  Vector2[||]

    new(vertices: Vector3[||], indices: uint32[||], normals: Vector3[||], texCoords: Vector2[||]) =
        {
            Vertices = vertices;
            Indices = indices;
            Normals = normals;
            TexCoords = texCoords
        }

    static CreateCube(): MeshDescription =
        let vertices =
            [|
                // front
                Vector3(-0.5, -0.5,  0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                // top
                Vector3(-0.5,  0.5,  0.5);
                Vector3(0.5,  0.5,  0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                // back
                Vector3(0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5,  0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                // bottom
                Vector3(-0.5, -0.5, -0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5, -0.5,  0.5);
                Vector3(-0.5, -0.5,  0.5);
                // left
                Vector3(-0.5, -0.5, -0.5);
                Vector3(-0.5, -0.5,  0.5);
                Vector3(-0.5,  0.5,  0.5);
                Vector3(-0.5,  0.5, -0.5);
                // right
                Vector3(0.5, -0.5,  0.5);
                Vector3(0.5, -0.5, -0.5);
                Vector3(0.5,  0.5, -0.5);
                Vector3(0.5,  0.5,  0.5)
            |]

        let normals =
            [|
                // front
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                Vector3(0, 0, 1);
                // top
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                Vector3(0, 1, 0);
                // back
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                Vector3(0, 0, -1);
                // bottom
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                Vector3(0, -1, 0);
                // left
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                Vector3(-1, 0, 0);
                // right
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0);
                Vector3(1, 0, 0)
            |]

        let texCoords =
            [|
                // front
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // top
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // back
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // bottom
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // left
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0);
                // right
                Vector2(0.0, 0.0);
                Vector2(1.0, 0.0);
                Vector2(1.0, 1.0);
                Vector2(0.0, 1.0)
            |]

        let indices =
            [|
                // front
                0;  1;  2;
                2;  3;  0: uint32;
                // top
                4;  5;  6;
                6;  7;  4: uint32;
                // back
                8;  9; 10;
                10; 11;  8;
                // bottom
                12; 13; 14;
                14; 15; 12;
                // left
                16; 17; 18;
                18; 19; 16: uint32;
                // right
                20; 21; 22;
                22; 23; 20: uint32
            |]

        //     Begin Function CalculateSurfaceNormal (Input Triangle) Returns Vector

        //     Set Vector U to (Triangle.p2 minus Triangle.p1)
        //     Set Vector V to (Triangle.p3 minus Triangle.p1)
        
        //     Set Normal.x to (multiply U.y by V.z) minus (multiply U.z by V.y)
        //     Set Normal.y to (multiply U.z by V.x) minus (multiply U.x by V.z)
        //     Set Normal.z to (multiply U.x by V.y) minus (multiply U.y by V.x)
        
        //     Returning Normal
        
        // End Function

        let calculateNormal(v1: Vector3, v2: Vector3, v3: Vector3): Vector3 =
            let mutable u: Vector3 = v2 - v1
            let mutable v: Vector3 = v3 - v1

            Vector3(
                (u.Y * v.Z) - (u.Z * v.Y),
                (u.Z * v.X) - (u.X * v.Z),
                (u.X * v.Y) - (u.Y * v.X)
            )

        // let normals = OlyArray.ZeroCreate<Vector3>(vertices.Length)
        // let mutable i = 0
        // while (i < indices.Length)
        //     let v1Index = indices[i]
        //     let v2Index = indices[i + 1]
        //     let v3Index = indices[i + 2]
        //     let v1 = vertices[int32(v1Index)]
        //     let v2 = vertices[int32(v2Index)]
        //     let v3 = vertices[int32(v3Index)]
        //     let normal = calculateNormal(v1, v2, v3)
        //     normals[i / 3] <- normal
        //     i <- i + 3
        
        MeshDescription(
            vertices, 
            indices,
            normals,
            texCoords
        )

sealed class ShaderDescription =
    internal mutable VertexLayouts:  VertexLayoutDescription[||]
    internal mutable VertexShader:   VeldridShaderDescription
    internal mutable FragmentShader: VeldridShaderDescription

    private new(vertexLayouts: VertexLayoutDescription[||], vertexShader: VeldridShaderDescription, fragmentShader: VeldridShaderDescription) =
        {
            VertexLayouts = vertexLayouts;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static CreateMeshShader(vertexShaderBytes: byte[||], fragmentShaderBytes: byte[||]): ShaderDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3);
                    VertexElementDescription("TexCoord", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float2);
                    VertexElementDescription("Normal", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3)
                |]
            )
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                vertexShaderBytes,
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                fragmentShaderBytes,
                "main"
            )

        ShaderDescription([|vertexLayout|], vertexShader, fragmentShader)

sealed class ComputeShaderDescription =
    internal mutable ComputeShader: VeldridShaderDescription

    private new(computeShader: VeldridShaderDescription) =
        {
            ComputeShader = computeShader
        }

    static CreateMeshLayout(computeShaderBytes: byte[||]): ComputeShaderDescription =
        let computeShader =
            ShaderDescription(
                ShaderStages.Compute,
                computeShaderBytes,
                "main"
            )

        ComputeShaderDescription(computeShader)

sealed class Mesh =
    implements IDisposable

    internal VertexBuffer:   DeviceBuffer
    internal IndexBuffer:    DeviceBuffer
    internal IndexCount:     uint32

    internal new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer, indexCount: uint32) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer;
            IndexCount = indexCount
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

sealed class Tex =
    implements IDisposable

    internal Texture: Texture

    internal new(texture: Texture) =
        {
            Texture = texture
        }

    Dispose(): () =
        this.Texture.Dispose()

sealed class Instances =
    implements IDisposable

    internal mutable Count: int32
    internal mutable InstanceBuffer: DeviceBuffer

    internal new(instanceBuffer: DeviceBuffer) =
        {
            Count = 0
            InstanceBuffer = instanceBuffer
        }

    Dispose(): () =
        this.InstanceBuffer.Dispose()

private sealed class ShaderState =
    internal VertexShader:   VeldridShader
    internal FragmentShader: VeldridShader
    internal ResourceSets:    ResourceSet[||]
    internal Pipeline:       Pipeline

    internal new(vertexShader: VeldridShader, fragmentShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

private sealed class ComputeShaderState =
    internal ComputeShader: VeldridShader
    internal ResourceSets:   ResourceSet[||]
    internal Pipeline:      Pipeline

    internal new(computeShader: VeldridShader, resourceSets: ResourceSet[||], pipeline: Pipeline) =
        {
            ComputeShader = computeShader;
            ResourceSets = resourceSets;
            Pipeline = pipeline
        }

sealed class Shader =
    implements IDisposable

    internal mutable State: ShaderState

    internal new(state: ShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.VertexShader.Dispose()
        this.State.FragmentShader.Dispose()

sealed class ComputeShader =
    implements IDisposable

    internal mutable State: ComputeShaderState

    internal new(state: ComputeShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.ComputeShader.Dispose()

enum DrawCommandKind =
    | DrawMesh
    | RunComputeShader
    | SetTexture0

class DrawCommand =
    Kind: DrawCommandKind

    new(kind: DrawCommandKind) =
        {
            Kind = kind
        }

    private sealed class DrawMesh =
        inherits DrawCommand

        Mesh:      Mesh
        Shader:    Shader
        Instances: Instances

        new(mesh: Mesh, shader: Shader, instances: Instances) =
            base(DrawCommandKind.DrawMesh) with
                {
                    Mesh = mesh;
                    Shader = shader;
                    Instances = instances
                }

    static CreateDrawMesh(mesh: Mesh, shader: Shader, instances: Instances): DrawCommand =
        DrawCommand.DrawMesh(mesh, shader, instances)

    pattern DrawMesh(cmd: DrawCommand): (mesh: Mesh, shader: Shader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawMesh)) =>
        let impl = UnsafeCast<DrawCommand.DrawMesh>(cmd)
        (impl.Mesh, impl.Shader, impl.Instances)

    private sealed class RunComputeShader =
        inherits DrawCommand

        ComputeShader: ComputeShader
        Count: uint32

        new(computeShader: ComputeShader, count: uint32) =
            base(DrawCommandKind.RunComputeShader) with
                {
                    ComputeShader = computeShader
                    Count = count
                }

    static CreateRunComputeShader(computeShader: ComputeShader, count: uint32): DrawCommand =
        DrawCommand.RunComputeShader(computeShader, count)

    pattern RunComputeShader(cmd: DrawCommand): (computeShader: ComputeShader, count: uint32) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.RunComputeShader)) =>
        let impl = UnsafeCast<DrawCommand.RunComputeShader>(cmd)
        (impl.ComputeShader, impl.Count)

enum KeyEventKind =
    | Pressed
    | Released

alias KeyEvent = Veldrid.KeyEvent
alias Key = Veldrid.Key

alias MouseEvent = Veldrid.MouseEvent

sealed class InputState =
    KeyEvents: KeyEvent[||]
    MouseEvents: MouseEvent[||]
    mutable MousePosition: Vector2
    mutable MouseDelta: Vector2
    internal snapshot: InputSnapshot

    internal new(keyEvents: KeyEvent[||], mouseEvents: MouseEvent[||], snapshot: InputSnapshot) =
        {
            KeyEvents = keyEvents
            MouseEvents = mouseEvents
            MousePosition = Vector2.Zero
            MouseDelta = Vector2.Zero
            snapshot = snapshot
        }

sealed class Window =
    internal window: Sdl2Window

    internal new(x: int32, y: int32, width: int32, height: int32, title: string) =
        let windowCreateInfo = WindowCreateInfo(x, y, width, height, WindowState.Normal, title)
        let window = VeldridStartup.CreateWindow(windowCreateInfo)
        {
            window = window
        }

    GetInputState(): InputState =
        let snapshot = this.window.PumpEvents()
        let keyEvents = System.Linq.Enumerable.ToArray<KeyEvent>(snapshot.KeyEvents)
        let mouseEvents = System.Linq.Enumerable.ToArray<MouseEvent>(snapshot.MouseEvents)
        let state = InputState(keyEvents, mouseEvents, snapshot)
        state.MousePosition <- snapshot.MousePosition
        state.MouseDelta <- this.window.MouseDelta
        state

    SetFullscreen(value: bool): () =
        if (value)
            this.window.WindowState <- WindowState.FullScreen
        else
            this.window.WindowState <- WindowState.Normal

    IsFullscreen: bool 
        get() = 
            fromEnum<WindowState>(this.window.WindowState) == fromEnum<WindowState>(WindowState.FullScreen)

    HideCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(true)
        this.window.CursorVisible <- false

    ShowCursor(): () =
        let result = Veldrid.Sdl2.Sdl2Native.SDL_SetRelativeMouseMode(false)
        this.window.CursorVisible <- true

    IsCursorVisible: bool get() = this.window.CursorVisible

    Close(): () =
        this.window.Close()

    Exists: bool
        get() = this.window.Exists

module Graphics =

    private mutable window: Window = unchecked default
    private mutable graphicsDevice: GraphicsDevice = null
    internal mutable imGuiRenderer: ImGuiRenderer = null
    private mutable factory: ResourceFactory = null
    private mutable commandList: CommandList = null

    private mutable globalUniformBuffer: DeviceBuffer = null

    DeviceName: string get() = graphicsDevice.DeviceName

    private CreateFramebufferTexture(width: uint32, height: uint32): Framebuffer =
        let desc =
            let targetTexture = 
                factory.CreateTexture(
                    TextureDescription.Texture2D(width, height, 1, 1, PixelFormat.R32_G32_B32_A32_Float, TextureUsage.RenderTarget)
                )
            let desc = FramebufferDescription(null, [|targetTexture|])
            desc
        factory.CreateFramebuffer(desc)

    CreateWindow(x: int32, y: int32, width: int32, height: int32, title: string): Window =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window !== unchecked default)
            fail("Window already created.")

        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

        window <- Window(x, y, width, height, title)

        let mutable options = default: GraphicsDeviceOptions
        options.PreferStandardClipSpaceYDirection <- true
        options.PreferDepthRangeZeroToOne <- true  
        options.SwapchainDepthFormat <- Nullable(PixelFormat.R16_UNorm)
#if DEBUG
        options.Debug <- true
#end
       // options.SyncToVerticalBlank <- true      

        graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window.window, options, GraphicsBackend.Vulkan)
        factory <- graphicsDevice.ResourceFactory
        commandList <- factory.CreateCommandList()

        // -- ImGui Settings --
        let imGuiOutputDesc = graphicsDevice.SwapchainFramebuffer.OutputDescription
        imGuiRenderer <- ImGuiRenderer(graphicsDevice, imGuiOutputDesc, width, height, ColorSpaceHandling.Linear)
        //ImGuiNET.ImGui.StyleColorsClassic()
        // --

        globalUniformBuffer <- createGlobalUniformBuffer(0)

        window

    #[StructLayout(LayoutKind.Sequential)]
    private struct VertexDatum =
        mutable Vertex: Vector3 = default
        mutable TexCoord: Vector2 = default
        mutable Normal: Vector3 = default

    CreateMesh(meshDesc: MeshDescription): Mesh =
        let vertices  = meshDesc.Vertices
        let indices   = meshDesc.Indices
        let normals   = meshDesc.Normals
        let texCoords = meshDesc.TexCoords
    
        let vertexCount = uint32(vertices.Length)
        let indexCount  = uint32(indices.Length)

        let vertexData =
            let vertexData = OlyArray.ZeroCreate<VertexDatum>(int32(vertexCount))
            let mutable i = 0
            while (i < int32(vertexCount))
                vertexData[i] <- 
                    let mutable d = default: VertexDatum
                    d.Vertex <- vertices[i]
                    d.TexCoord <- texCoords[i]
                    d.Normal <- normals[i]
                    d
                i <- i + 1
            vertexData
    
        let vertexBuffer = factory.CreateBuffer(BufferDescription(vertexCount * uint32(sizeof<VertexDatum>), BufferUsage.VertexBuffer))
        let indexBuffer = factory.CreateBuffer(BufferDescription(indexCount * uint32(sizeof<uint32>), BufferUsage.IndexBuffer))
    
        graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertexData)
        graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)
    
        Mesh(vertexBuffer, indexBuffer, indexCount)

    private struct ResourceSetGroup =
        ResourceLayouts: ResourceLayout[||]
        ResourceSets: ResourceSet[||]

        new(resourceLayouts: ResourceLayout[||], resourceSets: ResourceSet[||]) =
            {
                ResourceLayouts = resourceLayouts;
                ResourceSets = resourceSets
            }
            
    private CreateResourceSets(tex: Tex, instances: Instances, shaderStages: ShaderStages, instanceResourceKind: ResourceKind): ResourceSetGroup =
        // ------------------------------------------------------------
        let resourceLayoutDesc =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("Global", ResourceKind.UniformBuffer, shaderStages)
                |]
            )
        let resourceLayout = factory.CreateResourceLayout(resourceLayoutDesc)
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    (globalUniformBuffer: BindableResource)
                |]
            )
        let resourceSet = factory.CreateResourceSet(resourceSetDesc)

        let resourceLayoutDesc2 =
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("InstanceData", instanceResourceKind, shaderStages)
                |]
            )
        let resourceLayout2 = factory.CreateResourceLayout(resourceLayoutDesc2)
        let resourceSetDesc2 = 
            ResourceSetDescription(
                resourceLayout2,
                [|
                    (instances.InstanceBuffer: BindableResource)
                |]
            )
        let resourceSet2 = factory.CreateResourceSet(resourceSetDesc2)

        let mutable samplerDesc = 
            SamplerDescription(
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerAddressMode.Wrap,
                SamplerFilter.MinPoint_MagPoint_MipPoint,
                Nullable(ComparisonKind.LessEqual),
                1,
                0,
                10,
                0,
                SamplerBorderColor.TransparentBlack
            )
        let sampler = factory.CreateSampler(samplerDesc)

        match (shaderStages)
        | ShaderStages.Vertex =>
            let resourceLayoutDesc3 =
                ResourceLayoutDescription(
                    [|
                        ResourceLayoutElementDescription("Texture", ResourceKind.TextureReadOnly, ShaderStages.Fragment);
                        ResourceLayoutElementDescription("Sampler", ResourceKind.Sampler, ShaderStages.Fragment)
                    |]
                )
            let resourceLayout3 = factory.CreateResourceLayout(resourceLayoutDesc3)
            let resourceSetDesc3 = 
                ResourceSetDescription(
                    resourceLayout3,
                    [|
                        (tex.Texture: BindableResource);
                        sampler
                    |]
                )
            let resourceSet3 = factory.CreateResourceSet(resourceSetDesc3)
            ResourceSetGroup([|resourceLayout;resourceLayout2;resourceLayout3|], [|resourceSet;resourceSet2;resourceSet3|])
        | _ =>
            ResourceSetGroup([|resourceLayout;resourceLayout2|], [|resourceSet;resourceSet2|])
        // ----------------------------------------------------------------
    
    private CreateShaderState(shaderDesc: ShaderDescription, tex: Tex, instances: Instances): ShaderState =
        let vertexLayouts      = shaderDesc.VertexLayouts
        let vertexShaderDesc   = shaderDesc.VertexShader
        let fragmentShaderDesc = shaderDesc.FragmentShader
    
        let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)
    
        let mutable pipelineDesc = default: GraphicsPipelineDescription
        pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend
    
        pipelineDesc.DepthStencilState <-
            let mutable desc = default: DepthStencilStateDescription
            desc.DepthTestEnabled <- true
            desc.DepthWriteEnabled <- true
            desc.DepthComparison <- ComparisonKind.LessEqual
            desc
    
        pipelineDesc.RasterizerState <-
            let mutable desc = default: RasterizerStateDescription
            desc.CullMode <- FaceCullMode.Back
            desc.FillMode <- PolygonFillMode.Solid
            desc.FrontFace <- FrontFace.CounterClockwise
            desc.DepthClipEnabled <- true
            desc.ScissorTestEnabled <- false
            desc
    
        pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleList

        pipelineDesc.ShaderSet <-
            let mutable desc = default: ShaderSetDescription
            desc.VertexLayouts <- vertexLayouts
            desc.Shaders <- shaders
            desc

        let resourceSetGroup = CreateResourceSets(tex, instances, ShaderStages.Vertex, ResourceKind.StructuredBufferReadOnly)
    
        pipelineDesc.ResourceLayouts <- resourceSetGroup.ResourceLayouts
        pipelineDesc.Outputs <- graphicsDevice.SwapchainFramebuffer.OutputDescription
        let pipeline = factory.CreateGraphicsPipeline(pipelineDesc)
    
        ShaderState(shaders[0], shaders[1], resourceSetGroup.ResourceSets, pipeline)

    private CreateComputeShaderState(shaderDesc: ComputeShaderDescription, instances: Instances): ComputeShaderState =
        let computeShaderDesc = shaderDesc.ComputeShader
    
        let shader = ResourceFactoryExtensions.CreateFromSpirv(factory, computeShaderDesc)

        let resourceSetGroup = CreateResourceSets(unchecked default, instances, ShaderStages.Compute, ResourceKind.StructuredBufferReadWrite)
    
        let pipelineDesc = 
            ComputePipelineDescription(
                shader, 
                resourceSetGroup.ResourceLayouts, 
                1, 
                1, 
                1
            )

        let pipeline = factory.CreateComputePipeline(pipelineDesc)
    
        ComputeShaderState(shader, resourceSetGroup.ResourceSets, pipeline)

    CreateShader(shaderDesc: ShaderDescription, tex: Tex, instances: Instances): Shader =
        Shader(CreateShaderState(shaderDesc, tex, instances))

    CreateComputeShader(computeShaderDesc: ComputeShaderDescription, instances: Instances): ComputeShader =
        ComputeShader(CreateComputeShaderState(computeShaderDesc, instances))

    UpdateShader(shader: Shader, tex: Tex, shaderDesc: ShaderDescription, instances: Instances): () =
        let newState = CreateShaderState(shaderDesc, tex, instances)
        let oldState = Interlocked.Exchange(&shader.State, newState)
        oldState.Pipeline.Dispose()
        oldState.FragmentShader.Dispose()
        oldState.VertexShader.Dispose()

    CreateTex2D(filePath: string): Tex =
        let image = Veldrid.ImageSharp.ImageSharpTexture(filePath)
        let texture = image.CreateDeviceTexture(graphicsDevice, factory)
        Tex(texture)
        // let image = Image.Load<Rgba32>(System.IO.File.ReadAllBytes(filePath))
        // let width = uint32(image.Width)
        // let height = uint32(image.Height)

        // let mutable pixels = unchecked default: Memory<Rgba32>
        // let mutable result = AdvancedImageExtensions.GetPixelRowMemory(image, 0)
        // let sizeInBytes = width * height * 4

        // let mutable desc = default: TextureDescription
        // desc.Width <- width
        // desc.Height <- height
        // desc.Depth <- 1
        // desc.SampleCount <- TextureSampleCount.Count1
        // desc.Format <- PixelFormat.R8_G8_B8_A8_UNorm
        // desc.Type <- TextureType.Texture2D
        // desc.Usage <- TextureUsage.Sampled
        // desc.MipLevels <- 1
        // desc.ArrayLayers <- 1

        // let texture = factory.CreateTexture(desc)

        // let mutable sourceHandle = result.Pin()
        // let source = nint(sourceHandle.Pointer)

        // graphicsDevice.UpdateTexture(texture, source, sizeInBytes, 0, 0, 0, width, height, 1, 0, 0)
        // sourceHandle.Dispose()

        // Tex(texture)

    private createGlobalUniformBuffer(slot: uint32): DeviceBuffer =
        factory.CreateBuffer(BufferDescription((256: uint32) + 16, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))

    SetModel(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 0, value)

    SetView(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 64, value)

    SetProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 128, value)

    SetNormalMatrix(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 192, value)

    SetDeltaTime(value: float32): () =
        graphicsDevice.UpdateBuffer(globalUniformBuffer, 256, value)

    CreateInstances<T>(instanceData: T[||]): Instances where T: struct =
        let usage: BufferUsage = BufferUsage.StructuredBufferReadWrite
        let instanceBuffer = factory.CreateBuffer(BufferDescription(uint32(instanceData.Length * sizeof<T>), usage, uint32(instanceData.Length * sizeof<T>)))  
        graphicsDevice.UpdateBuffer(instanceBuffer, 0, instanceData)

        let instances = Instances(instanceBuffer)
        instances.Count <- instanceData.Length
        instances

    UpdateInstances<T>(instances: Instances, instanceData: T[||]): () where T: struct =
        graphicsDevice.UpdateBuffer(instances.InstanceBuffer, 0, instanceData)

    Draw(drawCmds: DrawCommand[]): () =
        // Begin() must be called before commands can be issued
        commandList.Begin()
    
        // We want to render directly to the output window.
        commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
        commandList.ClearColorTarget(0, RgbaFloat.Black)
        commandList.ClearDepthStencil(1)

        let mutable currentPipeline = unchecked default

        let mutable i = 0
        let length = getLength(drawCmds)
        while (i < length)
            match (drawCmds[i])
            | DrawCommand.DrawMesh(mesh, shader, instances) =>
                let instanceCount = uint32(instances.Count)

                if (instanceCount > 0)   
                    let pipeline = shader.State.Pipeline
                    if (pipeline !== currentPipeline)
                        let resourceSets = shader.State.ResourceSets
                        commandList.SetPipeline(pipeline)
                        let mutable i = 0
                        while (i < resourceSets.Length)
                            commandList.SetGraphicsResourceSet(uint32(i), resourceSets[i])
                            i <- i + 1
                        currentPipeline <- pipeline

                    let vertexBuffer   = mesh.VertexBuffer
                    let indexBuffer    = mesh.IndexBuffer
                    let indexCount     = mesh.IndexCount

                    commandList.SetVertexBuffer(0, vertexBuffer)
                    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt32)
            
                    commandList.DrawIndexed(
                        indexCount,     /* indexCount */
                        instanceCount,  /* instanceCount */
                        0,              /* indexStart */
                        0,              /* vertexOffset */
                        0               /* instanceStart */
                    )

            | DrawCommand.RunComputeShader(computeShader, count) =>
                let pipeline = computeShader.State.Pipeline
                if (pipeline !== currentPipeline)
                    let resourceSets = computeShader.State.ResourceSets
                    commandList.SetPipeline(pipeline)
                    let mutable i = 0
                    while (i < resourceSets.Length)
                        commandList.SetComputeResourceSet(uint32(i), resourceSets[i])
                        i <- i + 1
                    currentPipeline <- pipeline

                commandList.Dispatch(count, 1, 1)

            | _ =>
                ()
    
            i <- i + 1
    
        imGuiRenderer.Render(graphicsDevice, commandList)

        // End() must be called before commands can be submitted for execution.
        commandList.End()
        graphicsDevice.SubmitCommands(commandList)

        // Once commands have been submitted, the rendered image can be presented to the application window.
        graphicsDevice.SwapBuffers()

    DestroyWindow(): () =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window === unchecked default)
            fail("Window not created. Unable to destroy window.")

        window.Close()
        window <- unchecked default
        commandList.Dispose()
        graphicsDevice.Dispose()

    SetVSync(enabled: bool): () =
        graphicsDevice.SyncToVerticalBlank <- enabled
