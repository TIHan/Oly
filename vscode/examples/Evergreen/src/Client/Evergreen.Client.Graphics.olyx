#target "dotnet: net7"
#library

#reference "../../../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"

namespace Evergreen.Client.Graphics

open System
open System.Text
open System.Numerics
open System.Threading
open System.Collections.Concurrent
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV

private alias VeldridShaderDescription = Veldrid.ShaderDescription
private alias VeldridShader = Veldrid.Shader

sealed class MeshDescription =
    mutable Vertices: Vector3[||]
    mutable Indices:  uint16[||]

    private new(vertices: Vector3[||], indices: uint16[||]) =
        {
            Vertices = vertices;
            Indices = indices
        }

    static Create(vertices: Vector3[||], indices: uint16[||]): MeshDescription =
        MeshDescription(vertices, indices)

    static CreateQuad(): MeshDescription =
        let scale = 1: float32

        let vertices =
            [|
                Vector3(-scale,  scale, 0);
                Vector3( scale,  scale, 0);
                Vector3(-scale, -scale, 0);
                Vector3( scale, -scale, 0)
            |]
    
        let indices = [| 0; 1; 2; 3: uint16 |]

        MeshDescription(vertices, indices)

    static CreateHexagon(): MeshDescription =
        let scale = 1: float32
        let vertices =
            [|
                Vector3(     0,              0, 0); // center
                Vector3(  -0.5 * scale,  scale, 0); // left top
                Vector3(   0.5 * scale,  scale, 0); // right top
                Vector3(         scale,      0, 0); // right
                Vector3(   0.5 * scale, -scale, 0); // right bottom
                Vector3(  -0.5 * scale, -scale, 0); // left bottom
                Vector3(        -scale,      0, 0)  // left
            |]

        let indices =
            [|
                0; 1; 2;
                0; 2; 3;               
                0; 3; 4;
                0; 4; 5;
                0; 5; 6;
                0; 6; 1;
                0: uint16
            |]

        MeshDescription(vertices, indices)

sealed class ShaderDescription =
    internal mutable VertexLayouts:  VertexLayoutDescription[||]
    internal mutable VertexShader:   VeldridShaderDescription
    internal mutable FragmentShader: VeldridShaderDescription

    private new(vertexLayouts: VertexLayoutDescription[||], vertexShader: VeldridShaderDescription, fragmentShader: VeldridShaderDescription) =
        {
            VertexLayouts = vertexLayouts;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static CreateMeshShader(vertexShaderBytes: byte[||], fragmentShaderBytes: byte[||]): ShaderDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3)
                |]
            )

        let mutable instanceLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Transform_Column0", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column1", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column2", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4);
                    VertexElementDescription("Transform_Column3", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4)
                |]
            )
        instanceLayout.InstanceStepRate <- 1
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                vertexShaderBytes,
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                fragmentShaderBytes,
                "main"
            )

        ShaderDescription([|vertexLayout;instanceLayout|], vertexShader, fragmentShader)

sealed class Mesh =
    implements IDisposable

    internal VertexBuffer: DeviceBuffer
    internal IndexBuffer:  DeviceBuffer
    internal IndexCount:   uint32

    internal new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer, indexCount: uint32) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer;
            IndexCount = indexCount
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

sealed class Instances =
    implements IDisposable

    internal mutable Count: int32
    internal mutable TransformBuffer: DeviceBuffer

    internal new(transformBuffer: DeviceBuffer) =
        {
            Count = 0
            TransformBuffer = transformBuffer
        }

    Dispose(): () =
        this.TransformBuffer.Dispose()

private sealed class ShaderState =
    internal VertexShader:   VeldridShader
    internal FragmentShader: VeldridShader
    internal Pipeline:       Pipeline

    internal new(vertexShader: VeldridShader, fragmentShader: VeldridShader, pipeline: Pipeline) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader;
            Pipeline = pipeline
        }

sealed class Shader =
    implements IDisposable

    internal mutable State: ShaderState

    internal new(state: ShaderState) =
        {
            State = state
        }

    Dispose(): () =
        this.State.VertexShader.Dispose()
        this.State.FragmentShader.Dispose()

enum DrawCommandKind =
    | DrawMesh

class DrawCommand =
    Kind: DrawCommandKind

    new(kind: DrawCommandKind) =
        {
            Kind = kind
        }

    private sealed class DrawMesh =
        inherits DrawCommand

        Mesh:      Mesh
        Shader:    Shader
        Instances: Instances

        new(mesh: Mesh, shader: Shader, instances: Instances) =
            base(DrawCommandKind.DrawMesh) with
                {
                    Mesh = mesh;
                    Shader = shader;
                    Instances = instances
                }

    static CreateDrawMesh(mesh: Mesh, shader: Shader, instances: Instances): DrawCommand =
        DrawCommand.DrawMesh(mesh, shader, instances)

    pattern DrawMesh(cmd: DrawCommand): (mesh: Mesh, shader: Shader, instances: Instances) when (fromEnum(cmd.Kind) == fromEnum(DrawCommandKind.DrawMesh)) =>
        let impl = UnsafeCast<DrawCommand.DrawMesh>(cmd)
        (impl.Mesh, impl.Shader, impl.Instances)

enum KeyEventKind =
    | Pressed
    | Released

alias KeyEvent = Veldrid.KeyEvent
alias Key = Veldrid.Key

sealed class InputState =
    private snapshot: InputSnapshot

    internal new(snapshot: InputSnapshot) =
        {
            snapshot = snapshot
        }

    GetKeyEvents(): KeyEvent[||] =
        System.Linq.Enumerable.ToArray<Veldrid.KeyEvent>(this.snapshot.KeyEvents)

sealed class Window =
    internal window: Sdl2Window

    internal new(x: int32, y: int32, width: int32, height: int32, title: string) =
        let windowCreateInfo = WindowCreateInfo(x, y, width, height, WindowState.Normal, title)
        let window = VeldridStartup.CreateWindow(windowCreateInfo)
        {
            window = window
        }

    GetInputState(): InputState =
        InputState(this.window.PumpEvents())

    Close(): () =
        this.window.Close()

    Exists: bool
        get() = this.window.Exists

module Graphics =

    private mutable window: Window = unchecked default
    private mutable graphicsDevice: GraphicsDevice = null
    private mutable factory: ResourceFactory = null
    private mutable commandList: CommandList = null


    private mutable modelViewProjectionUniformBuffer: DeviceBuffer = null
    internal mutable DefaultResourceLayoutDescription: ResourceLayoutDescription = default
    private mutable defaultResourceSet: ResourceSet = null

    DeviceName: string get() = graphicsDevice.DeviceName

    CreateWindow(x: int32, y: int32, width: int32, height: int32, title: string): Window =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window !== unchecked default)
            fail("Window already created.")

        // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
        Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

        window <- Window(x, y, width, height, title)

        let mutable options = default: GraphicsDeviceOptions
        options.PreferStandardClipSpaceYDirection <- true
        options.PreferDepthRangeZeroToOne <- true

        graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window.window, options, GraphicsBackend.Vulkan)
        factory <- graphicsDevice.ResourceFactory
        commandList <- factory.CreateCommandList()

        // Default resource set
        //
        modelViewProjectionUniformBuffer <- createDynamicUniformBuffer(Matrix4x4.Identity, 0)
        DefaultResourceLayoutDescription <-
            ResourceLayoutDescription(
                [|
                    ResourceLayoutElementDescription("ModelViewProjection", ResourceKind.UniformBuffer, ShaderStages.Vertex)
                |]
            )
        let resourceLayout = factory.CreateResourceLayout(DefaultResourceLayoutDescription)
        let resourceSetDesc = 
            ResourceSetDescription(
                resourceLayout,
                [|
                    (modelViewProjectionUniformBuffer: BindableResource)
                |]
            )
        defaultResourceSet <- factory.CreateResourceSet(resourceSetDesc)
        //
        //

        window

    CreateMesh(meshDesc: MeshDescription): Mesh =
        let vertices = meshDesc.Vertices
        let indices  = meshDesc.Indices
    
        let vertexCount = uint32(vertices.Length)
        let indexCount  = uint32(indices.Length)
    
        let vertexBuffer = factory.CreateBuffer(BufferDescription(vertexCount * ((4: uint32) * 3), BufferUsage.VertexBuffer))
        let indexBuffer = factory.CreateBuffer(BufferDescription(indexCount * 2 /* sizeof<uint16> */, BufferUsage.IndexBuffer))
    
        graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertices)
        graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)
    
        Mesh(vertexBuffer, indexBuffer, indexCount)
    
    private CreateShaderState(shaderDesc: ShaderDescription): ShaderState =
        let vertexLayouts      = shaderDesc.VertexLayouts
        let vertexShaderDesc   = shaderDesc.VertexShader
        let fragmentShaderDesc = shaderDesc.FragmentShader
        let resourceLayouts    = [|DefaultResourceLayoutDescription|]
    
        let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)
    
        let mutable pipelineDesc = default: GraphicsPipelineDescription
        pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend
    
        pipelineDesc.DepthStencilState <-
            let mutable desc = default: DepthStencilStateDescription
            desc.DepthTestEnabled <- true
            desc.DepthWriteEnabled <- true
            desc.DepthComparison <- ComparisonKind.LessEqual
            desc
    
        pipelineDesc.RasterizerState <-
            let mutable desc = default: RasterizerStateDescription
            desc.CullMode <- FaceCullMode.Back
            desc.FillMode <- PolygonFillMode.Solid
            desc.FrontFace <- FrontFace.Clockwise
            desc.DepthClipEnabled <- true
            desc.ScissorTestEnabled <- false
            desc
    
        pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleStrip
        pipelineDesc.ResourceLayouts <-
            map(resourceLayouts, desc -> factory.CreateResourceLayout(desc))

        pipelineDesc.ShaderSet <-
            let mutable desc = default: ShaderSetDescription
            desc.VertexLayouts <- vertexLayouts
            desc.Shaders <- shaders
            desc
    
        pipelineDesc.Outputs <- graphicsDevice.SwapchainFramebuffer.OutputDescription
        let pipeline = factory.CreateGraphicsPipeline(pipelineDesc)
    
        ShaderState(shaders[0], shaders[1], pipeline)

    CreateShader(shaderDesc: ShaderDescription): Shader =
        Shader(CreateShaderState(shaderDesc))

    UpdateShader(shader: Shader, shaderDesc: ShaderDescription): () =
        let newState = CreateShaderState(shaderDesc)
        let oldState = Interlocked.Exchange(&shader.State, newState)
        oldState.Pipeline.Dispose()
        oldState.FragmentShader.Dispose()
        oldState.VertexShader.Dispose()

    private createDynamicUniformBuffer(value: Matrix4x4, slot: uint32): DeviceBuffer =
        let buffer = factory.CreateBuffer(BufferDescription(64, toEnum(fromEnum(BufferUsage.UniformBuffer) | fromEnum(BufferUsage.Dynamic))))
        graphicsDevice.UpdateBuffer(buffer, 0, value)
        buffer

    SetModelViewProjection(value: Matrix4x4): () =
        graphicsDevice.UpdateBuffer(modelViewProjectionUniformBuffer, 0, value)

    CreateInstances(transforms: Matrix4x4[||]): Instances =
        let transformBuffer = factory.CreateBuffer(BufferDescription(uint32(transforms.Length) * 64, BufferUsage.VertexBuffer))  
        graphicsDevice.UpdateBuffer(transformBuffer, 0, transforms)

        let instances = Instances(transformBuffer)
        instances.Count <- transforms.Length
        instances

    private delayed: ConcurrentQueue<() -> ()> = ConcurrentQueue()

    Draw(drawCmds: DrawCommand[]): () =
        // Begin() must be called before commands can be issued
        commandList.Begin()

        let mutable f = unchecked default
        while (delayed.TryDequeue(&f))
            f()
    
        // We want to render directly to the output window.
        commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
        commandList.ClearColorTarget(0, RgbaFloat.Black)

        let mutable currentPipeline = unchecked default
        let mutable curerentResourceSet = unchecked default

        // Set all relevant state to draw our quad
        let mutable i = 0
        let length = getLength(drawCmds)
        while (i < length)
            match (drawCmds[i])
            | DrawCommand.DrawMesh(mesh, shader, instances) =>
                let instanceCount = uint32(instances.Count)

                if (instanceCount > 0)   
                    let pipeline = shader.State.Pipeline
                    if (pipeline !== currentPipeline)
                        commandList.SetPipeline(pipeline)
                        if (defaultResourceSet !== curerentResourceSet)
                            commandList.SetGraphicsResourceSet(0, defaultResourceSet)
                            curerentResourceSet <- defaultResourceSet
                        currentPipeline <- pipeline

                    let transformBuffer = instances.TransformBuffer
                    let vertexBuffer    = mesh.VertexBuffer
                    let indexBuffer     = mesh.IndexBuffer
                    let indexCount      = mesh.IndexCount

                    commandList.SetVertexBuffer(0, vertexBuffer)
                    commandList.SetVertexBuffer(1, transformBuffer)
                    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt16)
            
                    commandList.DrawIndexed(
                        indexCount,     /* indexCount */
                        instanceCount,  /* instanceCount */
                        0,              /* indexStart */
                        0,              /* vertexOffset */
                        0               /* instanceStart */
                    )
            | _ =>
                ()
    
            i <- i + 1
    
        // End() must be called before commands can be submitted for execution.
        commandList.End()
        graphicsDevice.SubmitCommands(commandList)
    
        // Once commands have been submitted, the rendered image can be presented to the application window.
        graphicsDevice.SwapBuffers()

    DestroyWindow(): () =
        // TODO: Use a lock, but we need to implement try-catch in Oly.
        if (window === unchecked default)
            fail("Window not created. Unable to destroy window.")

        window.Close()
        window <- unchecked default
        commandList.Dispose()
        graphicsDevice.Dispose()
