#target "dotnet: net7"

#load "*.oly"

#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.ImGui,5.89.2-ga121087cad" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.ImageSharp,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "BepuPhysics,2.4.0"

open System.Text
open System.Numerics
open Evergreen.Graphics
open Evergreen.Graphics.UI
open Evergreen.Physics
open System.Runtime.InteropServices

DefaultVertexCode: string = System.IO.File.ReadAllText("GameExample/default.vert")

DefaultFragmentCode: string = System.IO.File.ReadAllText("GameExample/default.frag")

DefaultComputeCode: string = System.IO.File.ReadAllText("GameExample/transform_rotation.comp")

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

clamp(min: float32, max: float32, value: float32): float32 =
    if (max <= min)
        throw (System.ArgumentException("Invalid Min Max"))

    if (value < min)
        min
    else if (value > max)
        max
    else
        value

struct ViewProjection =
    mutable View: Matrix4x4
    mutable Projection: Matrix4x4

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            View = Matrix4x4.Identity
            Projection = Matrix4x4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
        }

    new(fov: float32, width: int32, height: int32) =
        ViewProjection(fov, width, height, 0.01, 1000000)

    Position: Vector3 get() = this.View.Translation
    Rotation: Quaternion get() = Quaternion.CreateFromRotationMatrix(this.View)

    InvertedView: ViewProjection 
        get() =
            let mutable invertedView = Matrix4x4.Identity
            let result = Matrix4x4.Invert(this.View, &invertedView)
            let mutable viewProj = this
            viewProj.View <- invertedView
            viewProj

    SetPosition(position: Vector3): ViewProjection =
        let mutable view = this.View
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetRotation(rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- this.Position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetPositionRotation(position: Vector3, rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

sealed class ShaderFileEventChanged =

    private invoke: (object, System.IO.FileSystemEventArgs) -> ()
    new(invoke: (object, System.IO.FileSystemEventArgs) -> ()) = 
        {
            invoke = invoke
        }

    Invoke(sender: object, e: System.IO.FileSystemEventArgs): () =
        this.invoke(sender, e)

main(): () =
    let physics = Physics.Init()

    //System.Environment.SetEnvironmentVariable("VK_INSTANCE_LAYERS", "VK_LAYER_LUNARG_monitor")
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")
    window.HideCursor()
    print("Graphics Device: " + Graphics.DeviceName + "\n")

    let staticBoxHandle = physics.AddStaticBox(100, 100, 1, Vector3(0, 0, -5))

    #[StructLayout(LayoutKind.Sequential)]
    struct CubeInstance =
        mutable Transform: Matrix4x4
        mutable Scale: Vector3
        mutable Padding: float32

        new(transform: Matrix4x4) =
            {
                Transform = transform
                Scale = Vector3.One
                Padding = 0
            }

    let cubes = System.Collections.Generic.List<CubeInstance>()
    let addCube(info) =
        cubes.Add(CubeInstance(info))

    let mutable i = 1
    while (i <= 10)
        addCube(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 10)
            addCube(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), -float32(j * 2), 0)))
            addCube(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 10)
        addCube(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 10)
            addCube(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), -float32(j * 2), 0)))
            addCube(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let cubes = cubes.ToArray()

    print("Cube Count: ")
    print(cubes.Length)
    print("\n")

    let cubePhysics = OlyArray.ZeroCreate(cubes.Length)
    let mutable i = 0
    while (i < cubes.Length)
        cubePhysics[i] <- physics.AddDynamicBox(1, 1, 1, cubes[i].Transform.Translation)
        i <- i + 1

    let meshDesc   = MeshDescription.CreateCube()
    let shaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let mesh   = Graphics.CreateMesh(meshDesc)

    let instances = Graphics.CreateInstances(cubes)
    let tex = Graphics.CreateTex2D("GameExample/Textures/flats/aqf068.png")
    let shader = Graphics.CreateShader(shaderDesc, tex, instances)
    let drawCmd = DrawCommand.CreateDrawMesh(mesh, shader, instances)

    let delayed = System.Collections.Concurrent.ConcurrentQueue<() -> ()>()

    let fileLookup = System.Collections.Generic.Dictionary<string, System.DateTime>()

    let mutable currentVertexShaderBytes = Encoding.UTF8.GetBytes(DefaultVertexCode)
    let mutable currentFragmentShaderBytes = Encoding.UTF8.GetBytes(DefaultFragmentCode)
    let handleVertexShaderFile(e: System.IO.FileSystemEventArgs, filePath: string): () =
        if (e.FullPath.EndsWith(filePath))
            let lastWriteTime = System.IO.File.GetLastWriteTimeUtc(filePath)
            let mutable prevLastWriteTime = System.DateTime.MinValue
            if (fileLookup.TryGetValue(filePath, &prevLastWriteTime) && (lastWriteTime != prevLastWriteTime))
                fileLookup[filePath] <- lastWriteTime
                match (e.ChangeType)
                | System.IO.WatcherChangeTypes.Changed =>
                    currentVertexShaderBytes <- Encoding.UTF8.GetBytes(System.IO.File.ReadAllText(filePath))
                    let shaderDesc = 
                        ShaderDescription.CreateMeshShader(
                            currentVertexShaderBytes, 
                            currentFragmentShaderBytes
                        )
                    delayed.Enqueue(
                        () ->
                            try
                                Graphics.UpdateShader(shader, tex, shaderDesc, instances)
                                print("Updated ")
                                print(filePath)
                                print("\n")
                            catch (ex: System.Exception) =>
                                ()
                    )
                | _ =>
                    ()

    let handleFragmentShaderFile(e: System.IO.FileSystemEventArgs, filePath: string): () =
        if (e.FullPath.EndsWith(filePath))
            let lastWriteTime = System.IO.File.GetLastWriteTimeUtc(filePath)
            let mutable prevLastWriteTime = System.DateTime.MinValue
            if (fileLookup.TryGetValue(filePath, &prevLastWriteTime) && (lastWriteTime != prevLastWriteTime))
                fileLookup[filePath] <- lastWriteTime
                match (e.ChangeType)
                | System.IO.WatcherChangeTypes.Changed =>
                    currentFragmentShaderBytes <- Encoding.UTF8.GetBytes(System.IO.File.ReadAllText(filePath))
                    let shaderDesc = 
                        ShaderDescription.CreateMeshShader(
                            currentVertexShaderBytes, 
                            currentFragmentShaderBytes
                        )
                    delayed.Enqueue(
                        () ->
                            try
                                Graphics.UpdateShader(shader, tex, shaderDesc, instances)
                                print("Updated ")
                                print(filePath)
                                print("\n")
                            catch (ex: System.Exception) =>
                                ()
                    )
                | _ =>
                    ()

    fileLookup["GameExample/default.frag"] <- System.IO.File.GetLastWriteTimeUtc("GameExample/default.frag")
    fileLookup["GameExample/default.vert"] <- System.IO.File.GetLastWriteTimeUtc("GameExample/default.vert")
    
    let handler = 
        ShaderFileEventChanged(         
            (sender, e) ->
                handleFragmentShaderFile(e, "GameExample/default.frag")
                handleVertexShaderFile(e, "GameExample/default.vert")
        )
    let fileSystemWatcher = System.IO.FileSystemWatcher()
    let handler = System.IO.FileSystemEventHandler(handler, UnsafeCast(__oly_load_function_ptr(handler.Invoke)))
    fileSystemWatcher.Path <- "C:/work/Oly/vscode/examples/GameExample/"
   // fileSystemWatcher.NotifyFilter <- System.IO.NotifyFilters.LastWrite
    fileSystemWatcher.add_Changed(handler)
    fileSystemWatcher.EnableRaisingEvents <- true

    let mutable staticCubeInstance = CubeInstance(Matrix4x4.CreateTranslation(Vector3(0, 0, -5)))
    staticCubeInstance.Scale <- Vector3(100, 100, 1)
    let staticCubes = [|staticCubeInstance|]
    let staticInstances = Graphics.CreateInstances(staticCubes)
    let tex = Graphics.CreateTex2D("GameExample/Textures/flats/floor7_2.png")
    let staticShader = Graphics.CreateShader(shaderDesc, tex, staticInstances)
    let staticDrawCmd = DrawCommand.CreateDrawMesh(mesh, staticShader, staticInstances)

    // ----
    let computeShaderDesc =
        ComputeShaderDescription.CreateMeshLayout(Encoding.UTF8.GetBytes(DefaultComputeCode))
    let computeShader = 
        Graphics.CreateComputeShader(computeShaderDesc, instances)
    let spinHexagonsCmd = DrawCommand.CreateRunComputeShader(computeShader, uint32(cubes.Length))

    let drawCmds = [spinHexagonsCmd;drawCmd;staticDrawCmd]

    let defaultCameraRotation = Quaternion.CreateFromAxisAngle(Vector3.UnitX, radians(90))

    let mutable viewProj = ViewProjection(70, 1280, 720, 1, 1000000)
    let mutable viewProjLerp = viewProj
    Graphics.SetModel(Matrix4x4.Identity)
    Graphics.SetView(viewProj.View)
    Graphics.SetProjection(viewProj.Projection)
    Graphics.SetNormalMatrix(Matrix4x4.Identity)
    Graphics.SetDeltaTime(0)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable esc_toggle = false

        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]

                match (keyEvent.Key)
                | Key.W =>
                    is_w_pressed <- keyEvent.Down
                | Key.A =>
                    is_a_pressed <- keyEvent.Down
                | Key.S =>
                    is_s_pressed <- keyEvent.Down
                | Key.D =>
                    is_d_pressed <- keyEvent.Down
                | Key.Escape when (keyEvent.Down) =>
                    esc_toggle <- true
                | _ =>
                    ()

                i <- i + 1

            if (esc_toggle)
                esc_toggle <- false
                if (window.IsCursorVisible)
                    window.HideCursor()
                else
                    window.ShowCursor()

    let checkMotion(deltaTime: float32, rotation: Quaternion) =
        let mutable acc = Vector3.Zero
                       
        if (!window.IsCursorVisible)
            if (is_w_pressed)
                let v = Vector3.Transform(-Vector3.UnitZ, rotation)
                acc <- Vector3(v.X, v.Y, v.Z)

            if (is_s_pressed)
                let v = Vector3.Transform(Vector3.UnitZ, rotation)
                acc <- acc + Vector3(v.X, v.Y, v.Z)

            if (is_a_pressed)
                let v = Vector3.Transform(-Vector3.UnitX, rotation)
                acc <- acc + Vector3(v.X, v.Y, v.Z)

            if (is_d_pressed)
                let v = Vector3.Transform(Vector3.UnitX, rotation)
                acc <- acc + Vector3(v.X, v.Y, v.Z)
        else
            ()

        acc <-
            if (acc != Vector3.Zero)
                Vector3.Normalize(acc) * (deltaTime * 20)
            else
                acc

        acc

    let uiNode =
        UI.Window("Main Menu",
            [
                UI.Button("New Game", () -> ());
                UI.Button("Quit", () -> window.Close());
                UI.TextBox("IP Address")
            ],
            Vector2(512, 512),
            Vector2(100, 100)
        )

    let mutable cameraPosition = Vector3.Zero
    let mutable cameraPositionLerp = cameraPosition
    let mutable cameraRotation = defaultCameraRotation
    let mutable cameraYaw = 0.0: float32
    let mutable cameraPitch = 0.0: float32
    let updateInput(dt: float64) =
        let inputState = window.GetInputState()

        keyEventQueue.Enqueue(inputState)

        if (!window.IsCursorVisible)
            let mousePosition = inputState.MouseDelta

            let yawAcc =
                mousePosition.X * 0.0025

            let pitchAcc =
                mousePosition.Y * 0.0025

            cameraYaw <- cameraYaw + yawAcc
            cameraPitch <- cameraPitch + pitchAcc

            cameraRotation <- defaultCameraRotation * Quaternion.CreateFromYawPitchRoll(-cameraYaw, -cameraPitch, 0)

            let mutable obj = default
            let mutable dir = Vector3.Transform(-Vector3.UnitZ, cameraRotation)
            if (physics.TryRayCast(cameraPosition, dir, 500, &obj))
                match (obj)
                | DynamicObject(objId) =>
                    physics.ApplyImpulse(objId, Vector3.Multiply(dir, 0.0002))
                | _ =>
                    ()

        else
            UI.Update(dt, inputState, uiNode)

    let fixedUpdate(mutable interval: float64) =

        let mutable work = () -> ()
        while (delayed.TryDequeue(&work))
            work()

        let interval = float32(interval)
        processKeyEventQueue()
        cameraPositionLerp <- cameraPosition
        cameraPosition <- cameraPosition + checkMotion(interval, cameraRotation)

        physics.Update(interval)

        let mutable i = 0
        while (i < cubes.Length)
            let mutable m = cubes[i]
            let mutable position = Vector3.Zero
            let mutable orientation = Quaternion.Identity
            physics.GetPositionAndOrientation(cubePhysics[i], &position, &orientation)
            let mutable m = Matrix4x4.CreateFromQuaternion(orientation)
            m.Translation <- position
            cubes[i] <- CubeInstance(m)
            i <- i + 1

        Graphics.UpdateInstances(instances, cubes)

    let update(dt: float64) =
        ()

    let render(deltaTime, alpha) =
        let cameraPostionFinal = Vector3.Lerp(cameraPositionLerp, cameraPosition, alpha)
        let mutable view = Matrix4x4.CreateFromQuaternion(cameraRotation)
        view.Translation <- cameraPostionFinal
        let projection = viewProj.Projection
        let result = Matrix4x4.Invert(view, &view)
        Graphics.SetView(view)
        Graphics.SetDeltaTime(deltaTime)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

   // Graphics.SetVSync(true)
    //window.SetFullscreen(true)
    window.ShowCursor()

    GameLoop.Start(
        dt ->
            updateInput(dt),
        dt ->
            fixedUpdate(dt)
            // Uncomment to test perf.
            // let mutable m = Matrix4x4.Identity
            // let mutable i = 0
            // while (i < 400000)
            //     m <- m * m
            //     i <- i + 1
            !window.Exists,
        dt ->
            update(dt)
            !window.Exists,
        (dt, alpha) ->
            render(float32(dt), float32(alpha))
    )

    Graphics.DestroyWindow()