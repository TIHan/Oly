#target "dotnet: net6"

#load "*.oly"

#reference "../Evergreen/src/Client/Evergreen.Client.Graphics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.

open System.Text
open System.Numerics
open Evergreen.Client.Graphics

DefaultVertexCode: string = "#version 450

layout(location = 0) in vec3 Position;
layout(location = 1) in mat4 Transform;

layout(location = 0) out vec4 fsin_Color;

layout(set = 0, binding = 0) uniform _ModelViewProjection
{
    mat4 ModelViewProjection;
};

void main()
{
    gl_Position = ModelViewProjection * Transform * vec4(Position, 1);
    fsin_Color = vec4(Position.x, Position.y, 1, 1);
}"

DefaultFragmentCode: string = "#version 450

layout(location = 0) in vec4 fsin_Color;
layout(location = 0) out vec4 fsout_Color;

void main()
{
    fsout_Color = fsin_Color;
}"

// TODO: This is a hack, we should fix enum equality work in the language.
#[intrinsic("equal")]
(==)(Key, Key): bool

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

clamp(min: float32, max: float32, value: float32): float32 =
    if (max <= min)
        throw (System.ArgumentException("Invalid Min Max"))

    if (value < min)
        min
    else if (value > max)
        max
    else
        value

main(): () =
    //System.Environment.SetEnvironmentVariable("VK_INSTANCE_LAYERS", "VK_LAYER_LUNARG_monitor")
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")
    window.HideCursor()
    print("Graphics Device: " + Graphics.DeviceName + "\n")

    let meshDesc   = MeshDescription.CreateHexagon()
    let shaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let mesh   = Graphics.CreateMesh(meshDesc)
    let shader = Graphics.CreateShader(shaderDesc)
    let shader2 = Graphics.CreateShader(shaderDesc)

    let hexagons = System.Collections.Generic.List<Matrix4x4>()

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let hexagons = hexagons.ToArray()

    print("Hexagon Count: ")
    print(hexagons.Length)
    print("\n")

    let instances = Graphics.CreateInstances(hexagons)
    let drawCmd   = DrawCommand.CreateDrawMesh(mesh, shader, instances)

    let drawCmds = [drawCmd]

    let defaultCameraRotation = Quaternion.CreateFromAxisAngle(Vector3.UnitX, 90 * float32(System.Math.PI / 180))

    let mutable projection = Matrix4x4.CreatePerspectiveFieldOfView((90: float32) * 0.017453, (1280.0: float32) / 720, 0.1, 100)
    let mutable view = Matrix4x4.Identity
    let mutable viewProjection = view * projection
    Graphics.SetModelViewProjection(viewProjection)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]
                if (fromEnum(keyEvent.Key) == fromEnum(Key.W))
                    if (keyEvent.Down)
                        is_w_pressed <- true
                    else
                        is_w_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.A))
                    if (keyEvent.Down)
                        is_a_pressed <- true
                    else
                        is_a_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.S))
                    if (keyEvent.Down)
                        is_s_pressed <- true
                    else
                        is_s_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.D))
                    if (keyEvent.Down)
                        is_d_pressed <- true
                    else
                        is_d_pressed <- false

                i <- i + 1

    let mutable prevCameraPosition = Vector3.Zero
    let mutable cameraPosition = Vector3(0, -4, 0)
    let mutable cameraRotation = Quaternion.Identity

    let mutable motion = Vector3.Zero
    let checkMotion(interval: float32) =
        let mutable acc = Vector3.Zero
                                
        if (is_w_pressed)
            let v = Vector3.Transform(Vector3.UnitZ, cameraRotation)
            acc <- Vector3(v.X, v.Y, v.Z)

        if (is_s_pressed)
            let v = Vector3.Transform(-Vector3.UnitZ, cameraRotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_a_pressed)
            let v = Vector3.Transform(Vector3.UnitX, cameraRotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_d_pressed)
            let v = Vector3.Transform(-Vector3.UnitX, cameraRotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        // acc <-
        //     if (acc != Vector3.Zero)
        //         Vector3.Multiply(Vector3.Normalize(acc), 1)
        //     else
        //         acc

        motion <- acc

    let mutable yaw = 0.0: float32
    let mutable pitch = 0.0: float32
    let update() =
        let inputState = window.GetInputState()
        keyEventQueue.Enqueue(inputState)

        let mousePosition = inputState.MouseDelta

        let yawAcc =
            mousePosition.X * 0.0025

        let pitchAcc =
            mousePosition.Y * 0.0025

        yaw <- yaw + yawAcc
        pitch <- pitch + pitchAcc

        cameraRotation <- defaultCameraRotation
        cameraRotation <- cameraRotation * Quaternion.CreateFromYawPitchRoll(0, pitch, -yaw)

    let fixedUpdate(mutable interval: float64) =
        let interval = float32(interval)
        processKeyEventQueue()
        checkMotion(interval)
        prevCameraPosition <- cameraPosition
        cameraPosition <- cameraPosition + motion  
        //System.GC.Collect(2, System.GCCollectionMode.Forced, true)

    let render(alpha) =
        let newCameraPosition = Vector3.Lerp(prevCameraPosition, cameraPosition, alpha)
        let mutable newView = Matrix4x4.CreateFromQuaternion(cameraRotation)
        newView.Translation <- newCameraPosition
        let viewProjection = newView * projection
        Graphics.SetModelViewProjection(viewProjection)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

   // Graphics.SetVSync(true)
    //window.SetFullscreen(true)

    GameLoop.Start(
        20,
        60,
        () ->
            update(),
        (intervalTime, dt) ->
            fixedUpdate(dt)
            !window.Exists,
        (alpha) ->
            render(float32(alpha))
    )

    Graphics.DestroyWindow()