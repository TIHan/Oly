#target "dotnet: net7"

#reference "../core/prelude.olyx"
#package "Veldrid,4.9.0"
#package "Veldrid.StartupUtilities,4.9.0"
#package "Veldrid.SPIRV,1.0.15"
#package "BepuPhysics,2.5.0-beta.10"

open System
open System.Text
open System.Numerics
open Veldrid
open Veldrid.Sdl2
open Veldrid.StartupUtilities
open Veldrid.SPIRV

mutable graphicsDevice: GraphicsDevice = null
mutable commandList: CommandList = null
mutable vertexBuffer: DeviceBuffer = null
mutable indexBuffer: DeviceBuffer = null
mutable shaders: Shader[||] = [||]
mutable pipeline: Pipeline = null

VertexCode: string = "#version 450

layout(location = 0) in vec2 Position;
layout(location = 1) in vec4 Color;

layout(location = 0) out vec4 fsin_Color;

void main()
{
    gl_Position = vec4(Position, 0, 1);
    fsin_Color = Color;
}"

FragmentCode: string = "#version 450

layout(location = 0) in vec4 fsin_Color;
layout(location = 0) out vec4 fsout_Color;

void main()
{
    fsout_Color = fsin_Color;
}"

struct VertexPositionColor =
    Position: Vector2
    Color: RgbaFloat

    new(position: Vector2, color: RgbaFloat) =
        {
            Position = position
            Color = color
        }

    static SizeInBytes: uint32 = 24

init(): () =
    // We must set these variables otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
    Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")

    let windowCreateInfo = WindowCreateInfo(100, 100, 960, 540, WindowState.Normal, "Oly Game Example")
    let window = VeldridStartup.CreateWindow(windowCreateInfo)

    let mutable options = default: GraphicsDeviceOptions
    options.PreferStandardClipSpaceYDirection <- true
    options.PreferDepthRangeZeroToOne <- true

    graphicsDevice <- VeldridStartup.CreateGraphicsDevice(window, options, GraphicsBackend.Vulkan)

    print("Graphics Device: " + graphicsDevice.DeviceName + "\n")

    createResources()

    while (window.Exists)
        let snapshot = window.PumpEvents()

        if (window.Exists)
            draw()

    disposeResources()

struct MeshDescription =
    mutable Vertices: Vector3[||]
    mutable Indices:  uint16[||]

    new(vertices: Vector3[||], indices: uint16[||]) =
        {
            Vertices = vertices;
            Indices = indices
        }

    static CreateQuad(): MeshDescription =
        let vertices =
            [|
                Vector3(-0.75, 0.75, 0);
                Vector3(0.75, 0.75, 0);
                Vector3(-0.75, -0.75, 0);
                Vector3(0.75, -0.75, 0)
            |]
    
        let indices = [| 0: uint16; 1; 2; 3 |]

        MeshDescription(vertices, indices)

struct Mesh =
    implements IDisposable

    VertexBuffer: DeviceBuffer
    IndexBuffer: DeviceBuffer

    new(vertexBuffer: DeviceBuffer, indexBuffer: DeviceBuffer) =
        {
            VertexBuffer = vertexBuffer;
            IndexBuffer = indexBuffer
        }

    Dispose(): () =
        this.VertexBuffer.Dispose()
        this.IndexBuffer.Dispose()

struct MaterialDescription =
    mutable VertexLayout:   VertexLayoutDescription
    mutable VertexShader:   ShaderDescription
    mutable FragmentShader: ShaderDescription

    private new(vertexLayout: VertexLayoutDescription, vertexShader: ShaderDescription, fragmentShader: ShaderDescription) =
        {
            VertexLayout = vertexLayout;
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    static Create(): MaterialDescription =
        let vertexLayout =
            VertexLayoutDescription(
                [|
                    VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float3);
                    VertexElementDescription("Color", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4)
                |]
            )
    
        let vertexShader =
            ShaderDescription(
                ShaderStages.Vertex,
                Encoding.UTF8.GetBytes(VertexCode),
                "main"
            )
    
        let fragmentShader =
            ShaderDescription(
                ShaderStages.Fragment,
                Encoding.UTF8.GetBytes(FragmentCode),
                "main"
            )

        MaterialDescription(vertexLayout, vertexShader, fragmentShader)

struct Material =
    implements IDisposable

    VertexShader: Shader
    FragmentShader: Shader

    new(vertexShader: Shader, fragmentShader: Shader) =
        {
            VertexShader = vertexShader;
            FragmentShader = fragmentShader
        }

    Dispose(): () =
        this.VertexShader.Dispose()
        this.FragmentShader.Dispose()

createMesh(meshDesc: MeshDescription): Mesh =
    let vertices = meshDesc.Vertices
    let indices  = meshDesc.Indices
    let factory  = graphicsDevice.ResourceFactory

    let count = uint32(vertices.Length)

    vertexBuffer <- factory.CreateBuffer(BufferDescription(count * ((4: uint32) * 3), BufferUsage.VertexBuffer))
    indexBuffer <- factory.CreateBuffer(BufferDescription(count * 2 /* sizeof<uint16> */, BufferUsage.IndexBuffer))

    graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertices)
    graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)

    Mesh(vertexBuffer, indexBuffer)

createMaterial(materialDesc: MaterialDescription): Material =
    let vertexShaderDesc   = materialDesc.VertexShader
    let fragmentShaderDesc = materialDesc.FragmentShader
    let factory            = graphicsDevice.ResourceFactory

    let shaders = ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)

    Material(shaders[0], shaders[1])

createResources(): () =
    let factory = graphicsDevice.ResourceFactory

    let vertices =
        [|
            VertexPositionColor(Vector2(-0.75, 0.75), RgbaFloat.Red);
            VertexPositionColor(Vector2(0.75, 0.75), RgbaFloat.Green);
            VertexPositionColor(Vector2(-0.75, -0.75), RgbaFloat.Blue);
            VertexPositionColor(Vector2(0.75, -0.75), RgbaFloat.Yellow)
        |]

    let indices = [| 0: uint16; 1; 2; 3 |]

    vertexBuffer <- factory.CreateBuffer(BufferDescription(4 * VertexPositionColor.SizeInBytes, BufferUsage.VertexBuffer))
    indexBuffer <- factory.CreateBuffer(BufferDescription((4: uint32) * 2 /* sizeof<uint16> */, BufferUsage.IndexBuffer))

    graphicsDevice.UpdateBuffer(vertexBuffer, 0, vertices)
    graphicsDevice.UpdateBuffer(indexBuffer, 0, indices)

    let vertexLayout =
        VertexLayoutDescription(
            [|
                VertexElementDescription("Position", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float2);
                VertexElementDescription("Color", VertexElementSemantic.TextureCoordinate, VertexElementFormat.Float4)
            |]
        )

    let vertexShaderDesc =
        ShaderDescription(
            ShaderStages.Vertex,
            Encoding.UTF8.GetBytes(VertexCode),
            "main"
        )

    let fragmentShaderDesc =
        ShaderDescription(
            ShaderStages.Fragment,
            Encoding.UTF8.GetBytes(FragmentCode),
            "main"
        )

    shaders <- ResourceFactoryExtensions.CreateFromSpirv(factory, vertexShaderDesc, fragmentShaderDesc)

    let mutable pipelineDesc = default: GraphicsPipelineDescription
    pipelineDesc.BlendState <- BlendStateDescription.SingleOverrideBlend

    pipelineDesc.DepthStencilState <-
        let mutable desc = default: DepthStencilStateDescription
        desc.DepthTestEnabled <- true
        desc.DepthWriteEnabled <- true
        desc.DepthComparison <- ComparisonKind.LessEqual
        desc

    pipelineDesc.RasterizerState <-
        let mutable desc = default: RasterizerStateDescription
        desc.CullMode <- FaceCullMode.Back
        desc.FillMode <- PolygonFillMode.Solid
        desc.FrontFace <- FrontFace.Clockwise
        desc.DepthClipEnabled <- true
        desc.ScissorTestEnabled <- false
        desc

    pipelineDesc.PrimitiveTopology <- PrimitiveTopology.TriangleStrip
    pipelineDesc.ResourceLayouts <- [||]

    pipelineDesc.ShaderSet <-
        let mutable desc = default: ShaderSetDescription
        desc.VertexLayouts <- [|vertexLayout|]
        desc.Shaders <- shaders
        desc

    pipelineDesc.Outputs <- graphicsDevice.SwapchainFramebuffer.OutputDescription
    pipeline <- factory.CreateGraphicsPipeline(pipelineDesc)

    commandList <- factory.CreateCommandList()

disposeResources(): () =
    pipeline.Dispose()
    shaders[0].Dispose()
    shaders[1].Dispose()
    commandList.Dispose()
    vertexBuffer.Dispose()
    indexBuffer.Dispose()
    graphicsDevice.Dispose()

draw(): () =
    // Begin() must be called before commands can be issued
    commandList.Begin()

    // We want to render directly to the output window.
    commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer)
    commandList.ClearColorTarget(0, RgbaFloat.Black)

    // Set all relevant state to draw our quad
    commandList.SetVertexBuffer(0, vertexBuffer)
    commandList.SetIndexBuffer(indexBuffer, IndexFormat.UInt16)
    commandList.SetPipeline(pipeline)

    //Issue a Draw command for a single instance with 4 indices.
    commandList.DrawIndexed(
        4, /* indexCount */
        1, /* instanceCount */
        0, /* indexStart */
        0, /* vertexOffset */
        0  /* instanceStart */
    )

    // End() must be called before commands can be submitted for execution.
    commandList.End()
    graphicsDevice.SubmitCommands(commandList)

    // Once commands have been submitted, the rendered image can be presented to the application window.
    graphicsDevice.SwapBuffers()

main(): () =
    init()
