#target "dotnet: net6"

#load "*.oly"

#reference "../Evergreen/src/Client/Evergreen.Client.Graphics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.

open System.Text
open System.Numerics
open Evergreen.Client.Graphics

DefaultVertexCode: string = "#version 450

layout(location = 0) in vec3 Position;
layout(location = 1) in mat4 Transform;

layout(location = 0) out vec4 fsin_Color;

layout(set = 0, binding = 0) uniform _ModelViewProjection
{
    mat4 ModelViewProjection;
};

void main()
{
    gl_Position = ModelViewProjection * Transform * vec4(Position, 1);
    fsin_Color = vec4(Position.x, Position.y, 1, 1);
}"

DefaultFragmentCode: string = "#version 450

layout(location = 0) in vec4 fsin_Color;
layout(location = 0) out vec4 fsout_Color;

void main()
{
    fsout_Color = fsin_Color;
}"

// TODO: This is a hack, we should fix enum equality work in the language.
#[intrinsic("equal")]
(==)(Key, Key): bool

sealed class SyncData =
    PreviousView: Matrix4x4
    View: Matrix4x4

    new(prevView: Matrix4x4, view: Matrix4x4) =
        {
            PreviousView = prevView;
            View = view
        }

main(): () =
    System.Environment.SetEnvironmentVariable("VK_INSTANCE_LAYERS", "VK_LAYER_LUNARG_monitor")
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")

    print("Graphics Device: " + Graphics.DeviceName + "\n")

    let meshDesc   = MeshDescription.CreateHexagon()
    let shaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let mesh   = Graphics.CreateMesh(meshDesc)
    let shader = Graphics.CreateShader(shaderDesc)
    let shader2 = Graphics.CreateShader(shaderDesc)

    let hexagons = System.Collections.Generic.List<Matrix4x4>()

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let hexagons = hexagons.ToArray()

    print("Hexagon Count: ")
    print(hexagons.Length)
    print("\n")

    let instances = Graphics.CreateInstances(hexagons)
    let drawCmd   = DrawCommand.CreateDrawMesh(mesh, shader, instances)

    let drawCmds = [drawCmd]

    let mutable projection = Matrix4x4.CreatePerspectiveFieldOfView((90: float32) * 0.017453, (1280.0: float32) / 720, 0.1, 100)
    let mutable view = Matrix4x4.CreateLookAt(Vector3(0, 0, 5), Vector3.Zero, Vector3(0, 1, 0))
    let mutable prevView = view
    let mutable newView = view
    let mutable viewProjection = view * projection
    Graphics.SetModelViewProjection(viewProjection)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]
                if (fromEnum(keyEvent.Key) == fromEnum(Key.W))
                    if (keyEvent.Down)
                        is_w_pressed <- true
                    else
                        is_w_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.A))
                    if (keyEvent.Down)
                        is_a_pressed <- true
                    else
                        is_a_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.S))
                    if (keyEvent.Down)
                        is_s_pressed <- true
                    else
                        is_s_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.D))
                    if (keyEvent.Down)
                        is_d_pressed <- true
                    else
                        is_d_pressed <- false

                i <- i + 1

    let mutable motion = Vector3.Zero
    let checkMotion(interval: float32) =
        let mutable z = 0: float32
        if (is_w_pressed)
            z <- z + (interval * 5)

        if (is_s_pressed)
            z <- z + (-interval * 5)

        let mutable x = 0: float32
        if (is_a_pressed)
            x <- x + (interval * 5)

        if (is_d_pressed)
            x <- x + (-interval * 5)

        motion <- Vector3(x, motion.Y, z)


    let mutable syncData = SyncData(prevView, view)

    let mutable prevCameraPosition = view.Translation

    let update() =
        let inputState = window.GetInputState()
        keyEventQueue.Enqueue(inputState)

    let fixedUpdate(mutable interval: float64) =
        let interval = float32(interval)
        processKeyEventQueue()
        checkMotion(interval)
        prevCameraPosition <- view.Translation
        view.Translation <- view.Translation + motion
        syncData <- SyncData(prevView, view)
        
        //System.GC.Collect(2, System.GCCollectionMode.Forced, true)

    let render(alpha) =
        let syncData = syncData
        newView <- syncData.View
        newView.Translation <- Vector3.Lerp(prevCameraPosition, newView.Translation, alpha)
        //newView <- Matrix4x4.Lerp(syncData.PreviousView, syncData.View, alpha)
        let viewProjection = newView * projection
        Graphics.SetModelViewProjection(viewProjection)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

    GameLoop.Start(
        30,
        () ->
            update(),
        (intervalTime, dt) ->
            fixedUpdate(dt)
           // System.Threading.Thread.Sleep(14)
            let mutable x = Matrix4x4.Identity
            let mutable i = 0
            while (i < 900000)
                x <- x * x
                i <- i + 1
            !window.Exists,
        (alpha) ->
            render(float32(alpha))
    )

    Graphics.DestroyWindow()
