#target "dotnet: net7"

#load "*.oly"

#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Physics/Evergreen.Physics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.ImGui,5.89.2-ga121087cad" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.ImageSharp,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "BepuPhysics,2.4.0" // TODO: Remove this when we fix transitive packages.

open System.Text
open System.Numerics
open Evergreen.Graphics
open Evergreen.Graphics.UI
open Evergreen.Physics
open System.Runtime.InteropServices

DefaultVertexCode: string = System.IO.File.ReadAllText("GameExample/default.vert")

DefaultFragmentCode: string = System.IO.File.ReadAllText("GameExample/default.frag")

DefaultComputeCode: string = System.IO.File.ReadAllText("GameExample/transform_rotation.comp")

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

clamp(min: float32, max: float32, value: float32): float32 =
    if (max <= min)
        throw (System.ArgumentException("Invalid Min Max"))

    if (value < min)
        min
    else if (value > max)
        max
    else
        value

struct Camera =
    mutable Transform: Transform
    mutable Projection: Matrix4x4

    private mutable yaw: float32
    private mutable pitch: float32

    private static get DefaultRotation: Quaternion = Quaternion.CreateFromAxisAngle(Vector3.UnitX, radians(90))

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            Transform = Transform(Matrix4x4.CreateFromQuaternion(Camera.DefaultRotation))
            Projection = Matrix4x4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
            yaw = 0
            pitch = 0
        }

    Yaw: float32
        get() = this.yaw
        
    Pitch: float32
        get() = this.pitch

    mutable SetYawPitch(yaw: float32, pitch: float32): () =
        this.yaw <- yaw
        this.pitch <- pitch
        let position = this.Transform.Position
        let rotation = Camera.DefaultRotation * Quaternion.CreateFromYawPitchRoll(-yaw, -pitch, 0)
        this.Transform <- Transform.Create(position, rotation, Vector3.One)

#[open]
extension Vector3Extensions =
    inherits Vector3

    static Forward: Vector3 get() = -Vector3.UnitZ
    static Back: Vector3 get() = Vector3.UnitZ
    static Left: Vector3 get() = -Vector3.UnitX
    static Right: Vector3 get() = Vector3.UnitX

(*)(v: Vector3, s: float32): Vector3 = Vector3.Multiply(v, s)

#[StructLayout(LayoutKind.Sequential)]
struct Transform =
    mutable Matrix: Matrix4x4

    new(matrix: Matrix4x4) = { Matrix = matrix }

    Position: Vector3
        get() = this.Matrix.Translation
        set(value) = this.Matrix.Translation <- value

    Rotation: Quaternion
        get() = Quaternion.CreateFromRotationMatrix(this.Matrix)

    Forward: Vector3
        get() = Vector3.Transform(Vector3.Forward, this.Rotation)

    Back: Vector3
        get() = Vector3.Transform(Vector3.Back, this.Rotation)

    Left: Vector3
        get() = Vector3.Transform(Vector3.Left, this.Rotation)

    Right: Vector3
        get() = Vector3.Transform(Vector3.Right, this.Rotation)

    WorldToLocalMatrix: Matrix4x4
        get() =
            let mutable inverted = Matrix4x4.Identity
            let didSucceed = Matrix4x4.Invert(this.Matrix, &inverted)
            inverted

    static Create(position: Vector3, rotation: Quaternion, scale: Vector3): Transform =
        let rotationMatrix = Matrix4x4.CreateFromQuaternion(rotation)
        let mutable scaleMatrix = Matrix4x4.CreateScale(scale)
        scaleMatrix.Translation <- position
        Transform(rotationMatrix * scaleMatrix)

newtype PhysicsBoxId =
    Value: int32

struct PhysicsBox =
    mutable Count: int32 = 0

    Transforms:       Transform[||]       = OlyArray.ZeroCreate(1024)
    DynamicObjectIds: DynamicObjectId[||] = OlyArray.ZeroCreate(1024)

    mutable Add(transform: Transform, dynamicObjId: DynamicObjectId): PhysicsBoxId =
        let index = this.Count
        this.Transforms[index] <- transform
        this.DynamicObjectIds[index] <- dynamicObjId
        this.Count <- this.Count + 1
        PhysicsBoxId(index)

newtype StaticBoxId =
    Value: int32

struct StaticBox =
    mutable Count: int32 = 0

    Transforms:      Transform[||]      = OlyArray.ZeroCreate(4096)
    StaticObjectIds: StaticObjectId[||] = OlyArray.ZeroCreate(4096)

    mutable Add(transform: Transform, staticObjId: StaticObjectId): StaticBoxId =
        let index = this.Count
        this.Transforms[index] <- transform
        this.StaticObjectIds[index] <- staticObjId
        this.Count <- this.Count + 1
        StaticBoxId(index)

sealed class World =

    mutable PhysicsBoxes: PhysicsBox = PhysicsBox()
    mutable StaticBoxes: StaticBox  = StaticBox()

main(): () =
    let world = World()
    let physics = Physics.Init()
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")
    window.HideCursor()
    print("Graphics Device: " + Graphics.DeviceName + "\n")

    // -------------------------------------

    let updateWorldPhysics(dt) =
        physics.Update(dt)

        let physicsBoxes = world.PhysicsBoxes
        let physicsBoxCount = physicsBoxes.Count
        let physicsBoxTransforms = physicsBoxes.Transforms
        let physicsBoxDynamicObjectIds = physicsBoxes.DynamicObjectIds

        let mutable i = 0
        while (i < physicsBoxCount)
            let mutable m = physicsBoxTransforms[i]
            let mutable position = Vector3.Zero
            let mutable orientation = Quaternion.Identity
            physics.GetPositionAndOrientation(physicsBoxDynamicObjectIds[i], &position, &orientation)
            let mutable m = Matrix4x4.CreateFromQuaternion(orientation)
            m.Translation <- position
            physicsBoxTransforms[i] <- Transform(m)
            i <- i + 1

    let defaultShaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let boxMesh   = Graphics.CreateMesh(MeshDescription.CreateCube())

    let addStaticBoxRenderCommand() =
        let staticBoxes = world.StaticBoxes
        let staticInstances = Graphics.CreateInstances(staticBoxes.Transforms)
        let texture = Graphics.CreateTexture2D("GameExample/Textures/flats/floor7_2.png")
        let staticShader = Graphics.CreateShader(defaultShaderDesc, texture, staticInstances)
        let drawCmd = DrawCommand.CreateDrawMesh(boxMesh, staticShader, staticInstances)
        staticInstances.Count <- staticBoxes.Count
        drawCmd

    let mutable physicsBoxInstances = unchecked default
    let addPhysicsBoxRenderCommand() =
        let boxes = world.PhysicsBoxes
        physicsBoxInstances <- Graphics.CreateInstances(boxes.Transforms)
        let texture = Graphics.CreateTexture2D("GameExample/Textures/flats/aqf068.png")
        let shader = Graphics.CreateShader(defaultShaderDesc, texture, physicsBoxInstances)
        let drawCmd = DrawCommand.CreateDrawMesh(boxMesh, shader, physicsBoxInstances)
        physicsBoxInstances.Count <- boxes.Count
        drawCmd

    let drawCmd = addPhysicsBoxRenderCommand()

    let spawnStaticBox(position, rotation, scale) =
        // server
        let objId = physics.AddStaticBox(position, rotation, scale)
        let transform = Transform.Create(position, rotation, scale)
        let staticBox = world.StaticBoxes.Add(transform, objId)

        // client
        // TODO: ...

    let spawnPhysicsBox(position, rotation, scale) =
        // server
        let objId = physics.AddBox(position, rotation, scale)
        let transform = Transform.Create(position, rotation, scale)
        let physicsBox = world.PhysicsBoxes.Add(transform, objId)

        // client
        physicsBoxInstances.Count <- physicsBoxInstances.Count + 1

    spawnStaticBox(Vector3(0, 0, -5), Quaternion.Identity, Vector3(50, 100, 1))
    let staticDrawCmd = addStaticBoxRenderCommand()

    let addCube(position) =
        let result = spawnPhysicsBox(position, Quaternion.Identity, Vector3.One)

    let mutable i = 1
    while (i <= 10)
        addCube(Vector3(-float32(i * 2), 0, 0))
        let mutable j = 1
        while (j <= 10)
            addCube(Vector3(-float32(i * 2), -float32(j * 2), 0))
            addCube(Vector3(-float32(i * 2), float32(j * 2), 0))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 10)
        addCube(Vector3(float32(i * 2), 0, 0))
        let mutable j = 1
        while (j <= 10)
            addCube(Vector3(float32(i * 2), -float32(j * 2), 0))
            addCube(Vector3(float32(i * 2), float32(j * 2), 0))
            j <- j + 1
        i <- i + 1

    print("Initial Physics Box Count: ")
    print(world.PhysicsBoxes.Count)
    print("\n")

    // ----

    let quadMesh = 
        let desc = MeshDescription.CreateQuad(1)
        Graphics.CreateMesh(desc)

    let quadInstances = 
        let transform = Transform.Create(Vector3(0, 0, 0), Quaternion.Identity, Vector3.One)
        Graphics.CreateInstances([|transform|])

    let renderTarget = Graphics.CreateRenderTarget(1280, 720)

    let renderQuadCmd =
        let desc = 
            ShaderDescription.CreateMeshShader(
                Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.vert")), 
                Encoding.UTF8.GetBytes(System.IO.File.ReadAllText("GameExample/quad.frag"))
            )
        let shader = Graphics.CreateShader(desc, renderTarget.Texture, quadInstances)
        DrawCommand.CreateDrawMesh(quadMesh, shader, quadInstances)

    let drawCmds =
        match (drawCmd)
        | DrawCommand.DrawMesh(mesh, shader, instances) =>
            let computeShaderDesc =
                ComputeShaderDescription.CreateMeshLayout(Encoding.UTF8.GetBytes(DefaultComputeCode))
            let computeShader = 
                Graphics.CreateComputeShader(computeShaderDesc, instances)
            let spinHexagonsCmd = DrawCommand.CreateRunComputeShader(computeShader, instances)

            [
                DrawCommand.CreateSetRenderTarget(renderTarget);
                staticDrawCmd;
                DrawCommand.CreateSetWindowTarget();
                spinHexagonsCmd;
                drawCmd;
                renderQuadCmd;
                DrawCommand.CreateDrawUI()
            ]
        | _ =>
            fail("Unexpected")

    let mutable camera = Camera(70, 1280, 720, 1, 1000000)
    Graphics.SetModel(Matrix4x4.Identity)
    Graphics.SetView(camera.Transform.Matrix)
    Graphics.SetProjection(camera.Projection)
    Graphics.SetNormalMatrix(Matrix4x4.Identity)
    Graphics.SetDeltaTime(0)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable esc_toggle = false

        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]

                match (keyEvent.Key)
                | Key.W =>
                    is_w_pressed <- keyEvent.Down
                | Key.A =>
                    is_a_pressed <- keyEvent.Down
                | Key.S =>
                    is_s_pressed <- keyEvent.Down
                | Key.D =>
                    is_d_pressed <- keyEvent.Down
                | Key.Escape when (keyEvent.Down) =>
                    esc_toggle <- true
                | _ =>
                    ()

                i <- i + 1

            if (esc_toggle)
                esc_toggle <- false
                if (window.IsCursorVisible)
                    window.HideCursor()
                else
                    window.ShowCursor()

    let updateWorldCamera(dt: float32) =
        let mutable acc = Vector3.Zero
                       
        if (!window.IsCursorVisible)
            if (is_w_pressed)
                let v = camera.Transform.Forward
                acc <- Vector3(v.X, v.Y, v.Z)

            if (is_s_pressed)
                let v = camera.Transform.Back
                acc <- acc + Vector3(v.X, v.Y, v.Z)

            if (is_a_pressed)
                let v = camera.Transform.Left
                acc <- acc + Vector3(v.X, v.Y, v.Z)

            if (is_d_pressed)
                let v = camera.Transform.Right
                acc <- acc + Vector3(v.X, v.Y, v.Z)
        else
            ()

        acc <-
            if (acc != Vector3.Zero)
                Vector3.Normalize(acc) * (dt * 20)
            else
                acc

        camera.Transform.Position <- camera.Transform.Position + acc

    let uiNode =
        UI.Window("Main Menu",
            [
                UI.Button("Spawn Box", () -> 
                                           let position = camera.Transform.Position + (camera.Transform.Forward * 2)
                                           spawnPhysicsBox(position, camera.Transform.Rotation, Vector3.One)
                );
                UI.Button("Quit", () -> window.Close());
                UI.TextBox("Example text")
            ],
            Vector2(512, 512),
            Vector2(100, 100)
        )

    let updateInput(dt: float64) =
        let inputState = window.GetInputState()

        keyEventQueue.Enqueue(inputState)

        if (!window.IsCursorVisible)
            let mousePosition = inputState.MouseDelta

            let yawAcc =
                mousePosition.X * 0.0025

            let pitchAcc =
                mousePosition.Y * 0.0025

            camera.SetYawPitch(camera.Yaw + yawAcc, camera.Pitch + pitchAcc)

            let mutable obj = default
            let mutable dir = camera.Transform.Forward
            if (physics.TryRayCast(camera.Transform.Position, dir, 500, &obj))
                match (obj)
                | DynamicObject(objId) =>
                    physics.ApplyImpulse(objId, dir * 0.0002)
                | _ =>
                    ()

        else
            UI.Update(dt, inputState, uiNode)

    let fixedUpdate(dt: float64) =
        let dt = float32(dt)
        processKeyEventQueue()
        updateWorldCamera(dt)
        updateWorldPhysics(dt)

        Graphics.UpdateInstances(physicsBoxInstances, world.PhysicsBoxes.Transforms)

    let update(dt: float64) =
        ()

    let render(deltaTime, alpha) =
        Graphics.SetView(camera.Transform.WorldToLocalMatrix)
        Graphics.SetDeltaTime(deltaTime)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

   // Graphics.SetVSync(true)
    //window.SetFullscreen(true)
    window.ShowCursor()

    GameLoop.Start(
        dt ->
            updateInput(dt),
        dt ->
            fixedUpdate(dt)
            !window.Exists,
        dt ->
            update(dt)
            !window.Exists,
        (dt, alpha) ->
            render(float32(dt), float32(alpha))
    )

    Graphics.DestroyWindow()