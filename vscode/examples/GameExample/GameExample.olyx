#target "dotnet: net6"

#load "*.oly"

#reference "../Evergreen/src/Client/Evergreen.Client.Graphics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.

open System.Text
open System.Numerics
open Evergreen.Client.Graphics

DefaultVertexCode: string = "#version 450

layout(location = 0) in vec3 Position;
layout(location = 1) in mat4 Transform;

layout(location = 0) out vec4 fsin_Color;

layout(set = 0, binding = 0) uniform _ModelViewProjection
{
    mat4 ModelViewProjection;
};

void main()
{
    gl_Position = ModelViewProjection * vec4(Position + Transform[3].xyz, 1);
    fsin_Color = vec4(Position.x, Position.y, 1, 1);
}"

DefaultFragmentCode: string = "#version 450

layout(location = 0) in vec4 fsin_Color;
layout(location = 0) out vec4 fsout_Color;

void main()
{
    fsout_Color = fsin_Color;
}"

// TODO: This is a hack, we should fix enum equality work in the language.
#[intrinsic("equal")]
(==)(Key, Key): bool

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

clamp(min: float32, max: float32, value: float32): float32 =
    if (max <= min)
        throw (System.ArgumentException("Invalid Min Max"))

    if (value < min)
        min
    else if (value > max)
        max
    else
        value

struct ViewProjection =
    mutable View: Matrix4x4
    mutable Projection: Matrix4x4

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            View = Matrix4x4.Identity
            Projection = Matrix4x4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
        }

    new(fov: float32, width: int32, height: int32) =
        ViewProjection(fov, width, height, 0.1, 1000000)

    Position: Vector3 get() = this.View.Translation
    Rotation: Quaternion get() = Quaternion.CreateFromRotationMatrix(this.View)

    InvertedView: ViewProjection 
        get() =
            let mutable invertedView = Matrix4x4.Identity
            let result = Matrix4x4.Invert(this.View, &invertedView)
            let mutable viewProj = this
            viewProj.View <- invertedView
            viewProj

    SetPosition(position: Vector3): ViewProjection =
        let mutable view = this.View
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetRotation(rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- this.Position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetPositionRotation(position: Vector3, rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

main(): () =
    //System.Environment.SetEnvironmentVariable("VK_INSTANCE_LAYERS", "VK_LAYER_LUNARG_monitor")
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")
    window.HideCursor()
    print("Graphics Device: " + Graphics.DeviceName + "\n")

    let meshDesc   = MeshDescription.CreateHexagon()
    let shaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let mesh   = Graphics.CreateMesh(meshDesc)
    let shader = Graphics.CreateShader(shaderDesc)
    let shader2 = Graphics.CreateShader(shaderDesc)

    let hexagons = System.Collections.Generic.List<Matrix4x4>()

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let hexagons = hexagons.ToArray()

    print("Hexagon Count: ")
    print(hexagons.Length)
    print("\n")

    let instances = Graphics.CreateInstances(hexagons)
    let drawCmd   = DrawCommand.CreateDrawMesh(mesh, shader, instances)

    let drawCmds = [drawCmd]

    let defaultCameraRotation = Quaternion.CreateFromAxisAngle(Vector3.UnitX, radians(90))

    let mutable viewProj = ViewProjection(70, 1280, 720, 0.01, 1000000)
    viewProj <- viewProj.SetPosition(Vector3(0, 4, 0))
    let mutable viewProjLerp = viewProj
    Graphics.SetModelViewProjection(viewProj.View * viewProj.Projection)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]
                if (fromEnum(keyEvent.Key) == fromEnum(Key.W))
                    if (keyEvent.Down)
                        is_w_pressed <- true
                    else
                        is_w_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.A))
                    if (keyEvent.Down)
                        is_a_pressed <- true
                    else
                        is_a_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.S))
                    if (keyEvent.Down)
                        is_s_pressed <- true
                    else
                        is_s_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.D))
                    if (keyEvent.Down)
                        is_d_pressed <- true
                    else
                        is_d_pressed <- false

                i <- i + 1

    let checkMotion(interval: float32) =
        let mutable acc = Vector3.Zero
                                
        if (is_w_pressed)
            let v = Vector3.UnitZ
            acc <- Vector3(v.X, v.Y, v.Z)

        if (is_s_pressed)
            let v = -Vector3.UnitZ
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_a_pressed)
            let v = Vector3.UnitX
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_d_pressed)
            let v = -Vector3.UnitX
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        acc <-
            if (acc != Vector3.Zero)
                Vector3.Multiply(Vector3.Normalize(acc), 1)
            else
                acc

        acc

    let mutable yaw = 0.0: float32
    let mutable pitch = 0.0: float32
    let update() =
        let inputState = window.GetInputState()
        keyEventQueue.Enqueue(inputState)

        let mousePosition = inputState.MouseDelta

        let yawAcc =
            mousePosition.X * 0.0025

        let pitchAcc =
            mousePosition.Y * 0.0025

        yaw <- yaw + yawAcc
        pitch <- pitch + pitchAcc

        viewProj <- viewProj.SetRotation(defaultCameraRotation * Quaternion.CreateFromYawPitchRoll(0, pitch, -yaw))

    let fixedUpdate(mutable interval: float64) =
        let interval = float32(interval)
        processKeyEventQueue()
        let motion = checkMotion(interval)
        viewProjLerp <- viewProj
        viewProj <- viewProj.SetPosition(viewProj.Position + motion)
        //System.GC.Collect(2, System.GCCollectionMode.Forced, true)

    let render(alpha) =
        let projection = viewProj.Projection
        let mutable view = Matrix4x4.CreateFromQuaternion(viewProj.Rotation)
        view.Translation <- Vector3.Lerp(viewProjLerp.View.Translation, viewProj.View.Translation, alpha)

        let mutable newView = view
        newView.Translation <- Vector3(newView.Translation.X, -newView.Translation.Y, newView.Translation.Z)
        Graphics.SetModelViewProjection(newView * projection)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

   // Graphics.SetVSync(true)
    //window.SetFullscreen(true)

    GameLoop.Start(
        20,
        60,
        () ->
            update(),
        (intervalTime, dt) ->
            fixedUpdate(dt)
            !window.Exists,
        (alpha) ->
            render(float32(alpha))
    )

    Graphics.DestroyWindow()