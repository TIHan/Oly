#target "dotnet: net6"

#load "*.oly"

#reference "../Evergreen/src/Client/Evergreen.Client.Graphics.olyx"
#package "Veldrid,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.StartupUtilities,4.9.0" // TODO: Remove this when we fix transitive packages.
#package "Veldrid.SPIRV,1.0.15" // TODO: Remove this when we fix transitive packages.

open System.Text
open System.Numerics
open Evergreen.Client.Graphics

DefaultVertexCode: string = "#version 450

layout(location = 0) in vec3 Position;
layout(location = 1) in mat4 Transform;

layout(location = 0) out vec4 fsin_Color;

layout(set = 0, binding = 0) uniform _ModelViewProjection
{
    mat4 ModelViewProjection;
    float DeltaTime;
};

layout(set = 1, binding = 0) readonly buffer _Transforms
{
    mat4[] Transforms;
};

void main()
{
    mat4 Transform = Transforms[gl_InstanceIndex];
    gl_Position = ModelViewProjection * vec4(Position + Transform[3].xyz, 1);
    fsin_Color = vec4(Position.x, Position.y, 1, 1);
}"

DefaultFragmentCode: string = "#version 450

layout(location = 0) in vec4 fsin_Color;
layout(location = 0) out vec4 fsout_Color;

void main()
{
    fsout_Color = fsin_Color;
}"

DefaultComputeCode: string = "#version 450

layout(set = 0, binding = 0) uniform _Global
{
    mat4 ModelViewProjection;
    float DeltaTime;
};
    
layout(set = 1, binding = 0) buffer _Transforms
{
    mat4[] Transforms;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index > 10240)
    {
        return;
    }

    mat4 transform = Transforms[index];

    transform[3].xyz = transform[3].xyz + (vec3(5) * DeltaTime);

    Transforms[index] = transform;
}"

// TODO: This is a hack, we should fix enum equality work in the language.
#[intrinsic("equal")]
(==)(Key, Key): bool

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

clamp(min: float32, max: float32, value: float32): float32 =
    if (max <= min)
        throw (System.ArgumentException("Invalid Min Max"))

    if (value < min)
        min
    else if (value > max)
        max
    else
        value

struct ViewProjection =
    mutable View: Matrix4x4
    mutable Projection: Matrix4x4

    new(fov: float32, width: int32, height: int32, nearPlaneDistance: float32, farPlaneDistance: float32) =
        {
            View = Matrix4x4.Identity
            Projection = Matrix4x4.CreatePerspectiveFieldOfView(radians(fov), float32(width) / float32(height), nearPlaneDistance, farPlaneDistance)
        }

    new(fov: float32, width: int32, height: int32) =
        ViewProjection(fov, width, height, 0.1, 1000000)

    Position: Vector3 get() = this.View.Translation
    Rotation: Quaternion get() = Quaternion.CreateFromRotationMatrix(this.View)

    InvertedView: ViewProjection 
        get() =
            let mutable invertedView = Matrix4x4.Identity
            let result = Matrix4x4.Invert(this.View, &invertedView)
            let mutable viewProj = this
            viewProj.View <- invertedView
            viewProj

    SetPosition(position: Vector3): ViewProjection =
        let mutable view = this.View
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetRotation(rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- this.Position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

    SetPositionRotation(position: Vector3, rotation: Quaternion): ViewProjection =
        let mutable view = Matrix4x4.CreateFromQuaternion(rotation)
        view.Translation <- position
        let mutable viewProj = this
        viewProj.View <- view
        viewProj

main(): () =
    //System.Environment.SetEnvironmentVariable("VK_INSTANCE_LAYERS", "VK_LAYER_LUNARG_monitor")
    let window = Graphics.CreateWindow(100, 100, 1280, 720, "Evergreen Engine")
    window.HideCursor()
    print("Graphics Device: " + Graphics.DeviceName + "\n")

    let hexagons = System.Collections.Generic.List<Matrix4x4>()

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(-float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let mutable i = 1
    while (i <= 100)
        hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), 0, 0)))
        let mutable j = 1
        while (j <= 1000)
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), -float32(j * 2), 0)))
            hexagons.Add(Matrix4x4.CreateTranslation(Vector3(float32(i * 2), float32(j * 2), 0)))
            j <- j + 1
        i <- i + 1

    let hexagons = hexagons.ToArray()

    print("Hexagon Count: ")
    print(hexagons.Length)
    print("\n")

    let instances = Graphics.CreateInstances(hexagons)

    let meshDesc   = MeshDescription.CreateHexagon()
    let shaderDesc = 
        ShaderDescription.CreateMeshShader(
            Encoding.UTF8.GetBytes(DefaultVertexCode), 
            Encoding.UTF8.GetBytes(DefaultFragmentCode)
        )

    let mesh   = Graphics.CreateMesh(meshDesc)
    let shader = Graphics.CreateShader(shaderDesc, instances)

    let drawCmd   = DrawCommand.CreateDrawMesh(mesh, shader, instances)

    // ----
    let computeShaderDesc =
        ComputeShaderDescription.CreateMeshLayout(Encoding.UTF8.GetBytes(DefaultComputeCode))
    let computeShader = 
        Graphics.CreateComputeShader(computeShaderDesc, instances)
    let spinHexagonsCmd = DrawCommand.CreateRunComputeShader(computeShader, uint32(hexagons.Length))

    let drawCmds = [spinHexagonsCmd;drawCmd]

    let defaultCameraRotation = Quaternion.CreateFromAxisAngle(Vector3.UnitX, radians(90))

    let mutable viewProj = ViewProjection(70, 1280, 720, 0.01, 1000000)
    let mutable viewProjLerp = viewProj
    Graphics.SetModelViewProjection(viewProj.View * viewProj.Projection)

    let mutable is_w_pressed = false
    let mutable is_a_pressed = false
    let mutable is_s_pressed = false
    let mutable is_d_pressed = false

    let keyEventQueue = System.Collections.Concurrent.ConcurrentQueue<InputState>()
    let processKeyEventQueue() =
        let mutable inputState = unchecked default
        while (keyEventQueue.TryDequeue(&inputState))
            let keyEvents = inputState.KeyEvents
            let mutable i = 0
            while (i < keyEvents.Length)
                let mutable keyEvent = keyEvents[i]
                if (fromEnum(keyEvent.Key) == fromEnum(Key.W))
                    if (keyEvent.Down)
                        is_w_pressed <- true
                    else
                        is_w_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.A))
                    if (keyEvent.Down)
                        is_a_pressed <- true
                    else
                        is_a_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.S))
                    if (keyEvent.Down)
                        is_s_pressed <- true
                    else
                        is_s_pressed <- false

                if (fromEnum(keyEvent.Key) == fromEnum(Key.D))
                    if (keyEvent.Down)
                        is_d_pressed <- true
                    else
                        is_d_pressed <- false

                i <- i + 1

    let checkMotion(deltaTime: float32, rotation: Quaternion) =
        let mutable acc = Vector3.Zero
                                
        if (is_w_pressed)
            let v = Vector3.Transform(-Vector3.UnitZ, rotation)
            acc <- Vector3(v.X, v.Y, v.Z)

        if (is_s_pressed)
            let v = Vector3.Transform(Vector3.UnitZ, rotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_a_pressed)
            let v = Vector3.Transform(-Vector3.UnitX, rotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        if (is_d_pressed)
            let v = Vector3.Transform(Vector3.UnitX, rotation)
            acc <- acc + Vector3(v.X, v.Y, v.Z)

        acc <-
            if (acc != Vector3.Zero)
                Vector3.Normalize(acc) * (deltaTime * 20)
            else
                acc

        acc

    let mutable cameraPosition = Vector3.Zero
    let mutable cameraPositionLerp = cameraPosition
    let mutable cameraRotation = Quaternion.Identity
    let mutable cameraYaw = 0.0: float32
    let mutable cameraPitch = 0.0: float32
    let update() =
        let inputState = window.GetInputState()
        keyEventQueue.Enqueue(inputState)

        let mousePosition = inputState.MouseDelta

        let yawAcc =
            mousePosition.X * 0.0025

        let pitchAcc =
            mousePosition.Y * 0.0025

        cameraYaw <- cameraYaw + yawAcc
        cameraPitch <- cameraPitch + pitchAcc

        cameraRotation <- defaultCameraRotation * Quaternion.CreateFromYawPitchRoll(-cameraYaw, -cameraPitch, 0)

    let fixedUpdate(mutable interval: float64) =
        let interval = float32(interval)
        processKeyEventQueue()
        cameraPositionLerp <- cameraPosition
        cameraPosition <- cameraPosition + checkMotion(interval, cameraRotation)
        System.GC.Collect(2, System.GCCollectionMode.Forced, true)

    let render(deltaTime, alpha) =
        let cameraPostionFinal = Vector3.Lerp(cameraPositionLerp, cameraPosition, alpha)
        let mutable view = Matrix4x4.CreateFromQuaternion(cameraRotation)
        view.Translation <- cameraPostionFinal
        let projection = viewProj.Projection
        let result = Matrix4x4.Invert(view, &view)
        Graphics.SetModelViewProjection(view * projection)
        Graphics.SetDeltaTime(deltaTime)

        let windowExists = window.Exists
        if (windowExists)
            Graphics.Draw(drawCmds)

   // Graphics.SetVSync(true)
    //window.SetFullscreen(true)

    GameLoop.Start(
        30,
        60,
        () ->
            update(),
        (dt) ->
            fixedUpdate(dt)
            !window.Exists,
        (dt, alpha) ->
            render(float32(dt), float32(alpha))
    )

    Graphics.DestroyWindow()