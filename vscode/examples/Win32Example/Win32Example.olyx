#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"

open System
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open Evergreen.Window

private alias vk = Evergreen.Graphics.Backend.Vulkan

main(): () =
    let window = IWindow.CreateWin32("Vulkan Example")

    let vulkanAppOptions = vk.VulkanApplicationOptions()
    vulkanAppOptions.ValidationEnabled <- true
    let vulkanApp = vk.Initialize(window.HWND, window.HINSTANCE, vulkanAppOptions)

    printLine(vulkanApp.GetDeviceName())

    let vertexShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/vert.spv")
    let fragmentShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/frag.spv")

    let vertexShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(vertexShaderByteCode))
    let fragmentShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(fragmentShaderByteCode))

    let pipelineLayout = vk.CreatePipelineLayout(vulkanApp)
    let commandPool = vk.CreateGraphicsCommandPool(vulkanApp)

    let recordCommands(commandBuffer: vk.VulkanCommandBuffer, graphicsPipeline, renderPass, framebuffer, extent, viewport, scissor) =
        vk.ResetCommandBuffer(vulkanApp, commandBuffer)

        commandBuffer.Begin()
        commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

        commandBuffer.BindPipeline(graphicsPipeline, vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
        commandBuffer.SetViewport(viewport)
        commandBuffer.SetScissor(scissor)
        commandBuffer.Draw(3, 1)

        commandBuffer.EndRenderPass()
        commandBuffer.End()

    let commandBuffers =
        let commandBuffers = Array.ZeroCreate(vulkanApp.MaxFramesInFlight)
        let mutable i = 0
        while (i < commandBuffers.Length)
            commandBuffers[i] <- vk.CreateCommandBuffer(vulkanApp, commandPool)
            i <- i + 1
        commandBuffers

    let mutable swapChain = unchecked default
    let mutable graphicsPipeline = unchecked default
    let mutable renderPass = unchecked default
    let mutable swapChainFramebuffers = unchecked default
    let recreateSwapChain() =
        vk.ResetCurrentFrame(vulkanApp)
        swapChain <- vk.CreateSwapChain(vulkanApp)
        renderPass <- vk.CreateRenderPass(vulkanApp, swapChain)
        swapChainFramebuffers <- vk.CreateSwapChainFramebuffers(vulkanApp, swapChain, renderPass)
        graphicsPipeline <- vk.CreateGraphicsPipeline(vulkanApp, swapChain, pipelineLayout, renderPass, vertexShaderModule, fragmentShaderModule)

    let cleanupSwapChain() =
        if (swapChain !== unchecked default)
            vk.DestroyPipeline(vulkanApp, graphicsPipeline)
            vk.DestroyFramebuffers(vulkanApp, ReadOnlySpan(swapChainFramebuffers))   
            vk.DestroyRenderPass(vulkanApp, renderPass)
            vk.DestroySwapChain(vulkanApp, swapChain)
            swapChain <- unchecked default

    recreateSwapChain()
    window.Show()

    let draw() =
        try
            vk.Draw(vulkanApp, swapChain, 
                (imageIndex, frame) -> 
                    let commandBuffer = commandBuffers[frame]
                    let framebuffer = swapChainFramebuffers[imageIndex]

                    recordCommands(commandBuffer, graphicsPipeline, renderPass, framebuffer, swapChain.Extent, swapChain.Viewport, swapChain.Scissor)
                    commandBuffer
            )
        catch (ex: vk.VulkanSwapChainOutOfDateException) =>
            vk.WaitForIdle(vulkanApp)
            cleanupSwapChain()
            try
                recreateSwapChain()
            catch (ex: vk.VulkanSwapChainCreationFailedException) =>
                // swap-chain failed to create, bail out of application
                ()
    draw()

    // --- BEGIN LOOP

    while (!window.IsClosed)
        let inputSnapshot = window.PumpEvents()
        let keyEvents = inputSnapshot.KeyEvents

        let mutable i = 0
        while (i < keyEvents.Length)
            let keyEvent = keyEvents[i]
            if (keyEvent.IsDown && !keyEvent.IsRepeat)
                printLine(keyEvent)
            i <- i + 1

        draw()

    // --- END LOOP

    vk.WaitForIdle(vulkanApp)

    cleanupSwapChain()

    vk.DestroyCommandPool(vulkanApp, commandPool)
    vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

    vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
    vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

    vk.Destroy(vulkanApp)
