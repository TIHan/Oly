#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open Evergreen
open Evergreen.Window
open Evergreen.Graphics.Backend.Vulkan
open Evergreen.UI
open Evergreen.Game

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

class ExternalProcess =
    implements IDisposable

    field p: Process

    // TODO: Runtime error, fix this.
  //  new(filePath: string, args: string) =
    //    ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            field f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, UnsafeCast(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, UnsafeCast(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception("Failed process")

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

struct Vertex =
    public field Position: Vector3
    public field TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    public mutable field Model: Matrix4x4 = Matrix4x4.Identity
    public mutable field View: Matrix4x4 = Matrix4x4.Identity
    public mutable field Projection: Matrix4x4 = Matrix4x4.Identity

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

compileShaderByFile(path: string): ReadOnlyMemory<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path, Environment.CurrentDirectory)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlyMemory(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createImage(vulkanApp: VulkanApplication, filePath: string): VulkanImage =
    let image = Image.Load<Rgba32>(File.ReadAllBytes(filePath))
    let width = uint32(image.Width)
    let height = uint32(image.Height)
    let format = VkFormat.VK_FORMAT_R8G8B8A8_UNORM

    let mutable imageSpan = default
    if (!image.TryGetSinglePixelSpan(&imageSpan))
        fail("Invalid image.")

    let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
    let imageSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
    let vulkanImage = Vk.CreateImage(vulkanApp, width, height, format)
    Vk.UpdateImage(vulkanApp, vulkanImage, imageSpan)
    image.Dispose()

    vulkanImage

createVertexBuffer(vulkanApp: VulkanApplication, vertices: Vertex[||]): VulkanBuffer =
    let buffer = 
        Vk.CreateBuffer(
            vulkanApp, 
            65536, 
            VkBufferUsageFlags.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
           // VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
        )
    Vk.UpdateBuffer(vulkanApp, buffer, vertices)
    buffer

createIndexBuffer(vulkanApp: VulkanApplication, indices: uint32[||]): VulkanBuffer =
    let buffer = 
        Vk.CreateBuffer(
            vulkanApp, 
            65536, 
            VkBufferUsageFlags.VK_BUFFER_USAGE_INDEX_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
            // VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
        )
    Vk.UpdateBuffer(vulkanApp, buffer, indices)
    buffer

createUI(): UINode =
    let windowViewModel = UI.WindowModel("Oly Window", Vector2.Zero, Vector2.Zero)
    let inputTextViewModel = UI.TextInputModel("Oly Input Text", "")
    let buttonViewModel = UI.ButtonModel("Oly Button")
    UI.Window(windowViewModel, 
        [
            UI.TextInput(inputTextViewModel, vm -> printLine(vm.Text));
            UI.Button(buttonViewModel, vm -> printLine("Clicked!"))
        ]
    )

main(): () =
    let options = GameClientOptions()
    let game = GameClient.Create(options)

    let uiNode = createUI()
    game.Gpu.Draw(uiNode, [])

    let globals =
        GpuSharedArray<_>.Initialize(GpuArrayKind.Uniform, 1,
            i ->
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
        )

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices = 
        GpuSharedArray<_>.Initialize(GpuArrayKind.Vertex, quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )

    let indices =
        GpuSharedArray<_>.Initialize(GpuArrayKind.Index, quad.Indices.Length,
            i -> quad.Indices[i]
        )

    let image = GpuImage("GameExample/Textures/flats/aqf068.png")

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")
    let gpuProgram = GpuProgram()
    gpuProgram.AddGlobalInput(GpuProgramInputKind.Array, GpuProgramStageFlags.Vertex)
    gpuProgram.AddGlobalInput(GpuProgramInputKind.Image, GpuProgramStageFlags.Fragment)
    gpuProgram.VertexCode <- vertexShaderByteCode
    gpuProgram.FragmentCode <- fragmentShaderByteCode

    let gpuProgramGlobalInputs = GpuProgramGlobalInputs(gpuProgram)
    gpuProgramGlobalInputs.Add(GpuProgramInput.CreateArray(globals))
    gpuProgramGlobalInputs.Add(GpuProgramInput.CreateImage(image))

    let executions =
        Array.Initialize(1000,
            i ->
                let gpuProgramExecution = GpuProgramExecution(gpuProgramGlobalInputs)
                gpuProgramExecution.SetVertexInput<Vertex>(vertices)
                gpuProgramExecution.SetIndexInput(indices)
                gpuProgramExecution.DrawIndexCount <- quad.Indices.Length
                gpuProgramExecution
        )

    let mutable pos = Vector3(2, 2, 2)

    game.Window.Show()
    while (!game.Window.IsClosed)
        let inputSnapshot = game.Window.PumpEvents()

        // TODO

        let size = game.Window.Size
        if (!game.Window.IsClosed && !game.Window.IsHidden && size.X != 0 && size.Y != 0)
            let mutable result = globals.AsSpan()
            let mutable x = &result[0]
            pos <- Vector3(2, 2, pos.Z + 0.01)

            x.View <- Matrix4x4.CreateLookAt(pos, Vector3(0, 0, 0), Vector3(0, 0, 1))
            gpuProgram.FragmentCode <- fragmentShaderByteCode
            game.Gpu.Draw(uiNode, executions)

    game.Dispose()

defaultMain(): () =
    // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
    Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")
    
    let window = IWindow.CreateWin32("Vulkan Example", Vector2(0, 0), Vector2(1280, 720))

    let vulkanAppOptions = VulkanApplicationOptions()
    vulkanAppOptions.ValidationEnabled <- true
    vulkanAppOptions.MaxFramesInFlight <- 2
    let vulkanApp = Vk.Initialize(window.HWND, window.HINSTANCE, vulkanAppOptions)

    let testImage = createImage(vulkanApp, "GameExample/Textures/flats/aqf068.png")
    let testImageView = Vk.CreateImageView(vulkanApp, testImage, VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT)
    let testSampler = Vk.CreateSampler(vulkanApp)

    printLine(vulkanApp.GetDeviceName())

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices =
        Array.InitializeMutable(quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )
    
    let vertexBuffer = createVertexBuffer(vulkanApp, vertices)
    let indexBuffer = createIndexBuffer(vulkanApp, quad.Indices)

    let mutable vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let mutable fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")

    let vertexShaderModule = Vk.CreateShaderModule(vulkanApp, vertexShaderByteCode.Span)
    let fragmentShaderModule = Vk.CreateShaderModule(vulkanApp, fragmentShaderByteCode.Span)

    let globals =
        [
            (
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
            )
        ]

    let globalBuffers =
        Array.Initialize(vulkanApp.MaxFramesInFlight, 
            i ->
                let buffer =
                    Vk.CreateBuffer(
                        vulkanApp,
                        uint64(sizeof<Globals>),
                        VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                        VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
                    )
                Vk.UpdateBuffer(vulkanApp, buffer, [globals[0]])
                buffer
        )
    let globalBuffers = UnsafeCast<VulkanBuffer[]>(globalBuffers)

    let bindingInfos =
        [
            VulkanDescriptorBindingInfo(0, VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT);
            VulkanDescriptorBindingInfo(1, VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT)
        ]       
    let bindingInfos =
        ReadOnlySpan(UnsafeCast<_[||]>(bindingInfos))

    let descriptorTypes =
        [
            VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
        ]
    let mutable descriptorTypes =
        ReadOnlySpan(UnsafeCast<_[||]>(descriptorTypes))

    let setLayout = Vk.CreateDescriptorSetLayout(vulkanApp, bindingInfos)
    let descriptorPool = Vk.CreateDescriptorPool(vulkanApp, descriptorTypes, uint32(vulkanApp.MaxFramesInFlight))
    let descriptorSets = Vk.CreateDescriptorSets(vulkanApp, descriptorPool, uint32(vulkanApp.MaxFramesInFlight), setLayout)

    let mutable i = 0
    while (i < vulkanApp.MaxFramesInFlight)
        Vk.UpdateDescriptorSet(vulkanApp, 0, descriptorSets[i], globalBuffers[i], descriptorTypes[0])
        Vk.UpdateDescriptorSet(vulkanApp, 1, descriptorSets[i], VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, testImageView, testSampler, descriptorTypes[1])
        i <- i + 1

    let pipelineLayout = Vk.CreatePipelineLayout(vulkanApp, [setLayout])

    let commandBuffers =
        let commandBuffers = Array.ZeroCreate(vulkanApp.MaxFramesInFlight)
        let mutable i = 0
        while (i < commandBuffers.Length)
            commandBuffers[i] <- Vk.CreateGraphicsCommandBuffer(vulkanApp)
            i <- i + 1
        commandBuffers

    let mutable imguiContext = unchecked default

    let recordCommands(frame: int32, graphicsPipeline, renderPass, framebuffer, extent, viewport, scissor) =
        let commandBuffer = commandBuffers[frame]
        let descriptorSet = descriptorSets[frame]

        Vk.ResetCommandBuffer(vulkanApp, commandBuffer)

        commandBuffer.Begin()
        commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

        commandBuffer.BindPipeline(graphicsPipeline, VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
        commandBuffer.SetViewport(viewport)
        commandBuffer.SetScissor(scissor)
        commandBuffer.BindDescriptorSet(VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, descriptorSet)
        commandBuffer.BindVertexBuffer(vertexBuffer)
        commandBuffer.BindIndexBuffer(indexBuffer)
        commandBuffer.DrawIndexed(uint32(quad.Indices.Length), 1)

        ImGui.Draw(imguiContext, commandBuffer, TerraFX.Interop.Vulkan.VkPipeline.NULL)

        commandBuffer.EndRenderPass()
        commandBuffer.End()

        commandBuffer

    let mutable swapChain = unchecked default
    let mutable graphicsPipeline = unchecked default
    let mutable renderPass = unchecked default
    let mutable swapChainFramebuffers = unchecked default
    let mutable fontHandle = default
    
    let recreateSwapChain() =
        Vk.ResetCurrentFrame(vulkanApp)
        swapChain <- Vk.CreateSwapChain(vulkanApp, VkFormat.VK_FORMAT_B8G8R8A8_UNORM)
        renderPass <- Vk.CreateRenderPass(vulkanApp, swapChain)
        swapChainFramebuffers <- Vk.CreateSwapChainFramebuffers(vulkanApp, swapChain, renderPass)
        imguiContext <- ImGui.CreateContext(window, vulkanApp, swapChain, renderPass)

        let fullPath = Path.Combine(Environment.CurrentDirectory, "Win32Example/bin/dotnet/Win32Example.olyx/DroidSans.ttf")

        // Must do this first before NewFrame!
        let fontSize =
            let size = window.Size
            let ratio = (size.Y / 720)
            ratio * 16
        fontHandle <- ImGui.AddFont(imguiContext, fullPath, fontSize)
        ImGui.UploadFonts(imguiContext, vulkanApp.GraphicsCommandPool, commandBuffers[0])

        let bindingDescs = [Vk.CreateVertexBindingDescription<Vertex>(0, false)]
        let attrDescs = Vk.CreateVertexAttributeDescriptions<Vertex>(0)
        graphicsPipeline <- 
            Vk.CreateGraphicsPipeline(
                vulkanApp, 
                swapChain, 
                bindingDescs, 
                attrDescs, 
                pipelineLayout, 
                renderPass, 
                VkCullModeFlags.VK_CULL_MODE_BACK_BIT, 
                VkFrontFace.VK_FRONT_FACE_CLOCKWISE, 
                vertexShaderModule, 
                fragmentShaderModule
            )

        GC.Collect(2, GCCollectionMode.Forced)

    let cleanupSwapChain() =
        if (swapChain !== unchecked default)
            ImGui.DestroyContext(imguiContext)
            Vk.DestroyPipeline(vulkanApp, graphicsPipeline)
            Vk.DestroyFramebuffers(vulkanApp, swapChainFramebuffers)   
            Vk.DestroyRenderPass(vulkanApp, renderPass)
            Vk.DestroySwapChain(vulkanApp, swapChain)
            swapChain <- unchecked default

    recreateSwapChain()
    window.Show()

    let textBuffer = Array.ZeroCreate<byte>(1024)

    let mutable forceQuit = false

    let windowViewModel = Evergreen.UI.UI.WindowModel("Oly Window", Vector2.Zero, Vector2.Zero)
    let inputTextViewModel = Evergreen.UI.UI.TextInputModel("Oly Input Text", "")
    let buttonViewModel = Evergreen.UI.UI.ButtonModel("Oly Button")
    let windowView = 
        Evergreen.UI.UI.Window(windowViewModel, 
            [
                Evergreen.UI.UI.TextInput(inputTextViewModel, vm -> printLine(vm.Text));
                Evergreen.UI.UI.Button(buttonViewModel, vm -> printLine("Clicked!"))
            ]
        )

    let draw() =
        try
            UI.Update(imguiContext, windowView)
            // ImGui.NewFrame(imguiContext)
            // if (ImGui.Begin(imguiContext, "Oly Window"))
            //     if (ImGui.InputText(imguiContext, "Oly Label Λλ", Span(textBuffer)))
            //         ()
            //     let size = window.Size
            //     ImGui.LabelText(imguiContext, "Size", size.ToString())
            //     let pos = window.Position
            //     ImGui.LabelText(imguiContext, "Position", pos.ToString())
            //     ImGui.End(imguiContext)
            // ImGui.ShowDemoWindow(imguiContext)

            Vk.Draw(vulkanApp, swapChain, 
                (framebufferIndex, frame) -> 
                    let framebuffer = swapChainFramebuffers[framebufferIndex]
                    recordCommands(frame, graphicsPipeline, renderPass, framebuffer, swapChain.Extent, swapChain.Viewport, swapChain.Scissor)
            )
        catch (ex: VulkanSwapChainOutOfDateException) =>
            let size = window.Size
            if (!window.IsClosed && size.X != 0 && size.Y != 0)
                Vk.WaitForIdle(vulkanApp)
                cleanupSwapChain()
                try
                    recreateSwapChain()
                catch (ex: VulkanSwapChainCreationFailedException) =>
                    // swap-chain failed to create, bail out of application
                    ()
    draw()

    // --- BEGIN LOOP

    while (!window.IsClosed)
        let inputSnapshot = window.PumpEvents()
        let keyEvents = inputSnapshot.KeyEvents

        let mutable i = 0
        while (i < keyEvents.Length)
            let keyEvent = keyEvents[i]
            if (keyEvent.IsDown && !keyEvent.IsRepeat)

                match (keyEvent.Key)
                | Key.Esc =>
                    window.Close()
                | Key.Tilde =>
                    window.Minimize()
                | _ => 
                    ()

                printLine(keyEvent)
            i <- i + 1

        let size = window.Size
        if (!window.IsClosed && !window.IsHidden && size.X != 0 && size.Y != 0)
            draw()

    // --- END LOOP

    Vk.WaitForIdle(vulkanApp)

    Vk.DestroyBuffer(vulkanApp, vertexBuffer)
    Vk.DestroyBuffer(vulkanApp, indexBuffer)

    let mutable i = 0
    while (i < globalBuffers.Length)
        Vk.DestroyBuffer(vulkanApp, globalBuffers[i])
        i <- i + 1

    cleanupSwapChain()

    Vk.DestroyDescriptorSetLayout(vulkanApp, setLayout)
    
    Vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

    Vk.DestroyDescriptorPool(vulkanApp, descriptorPool)

    Vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
    Vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

    Vk.DestroySampler(vulkanApp, testSampler)
    Vk.DestroyImageView(vulkanApp, testImageView)
    Vk.DestroyImage(vulkanApp, testImage)

    Vk.Destroy(vulkanApp)

    window.Dispose()
