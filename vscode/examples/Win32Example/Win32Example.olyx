#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"
#reference "../Evergreen/src/Window/Evergreen.Window.olyx"

open System
open System.IO
open System.Numerics
open System.Diagnostics
open System.Runtime.InteropServices
open Evergreen.Window

open SixLabors.ImageSharp
open SixLabors.ImageSharp.Advanced
open SixLabors.ImageSharp.PixelFormats
open SixLabors.ImageSharp.Processing

sealed class ExternalProcess =
    implements IDisposable

    private p: Process

    // TODO: Runtime error, fix this.
  //  new(filePath: string, args: string) =
    //    ExternalProcess(filePath, args, Environment.CurrentDirectory)

    new(filePath: string, args: string, workingDirectory: string) =
        let startInfo = ProcessStartInfo()
        startInfo.FileName <- filePath
        startInfo.Arguments <- args
        startInfo.RedirectStandardError <- true
        startInfo.RedirectStandardOutput <- true
        startInfo.WorkingDirectory <- workingDirectory
        startInfo.UseShellExecute <- false
        startInfo.CreateNoWindow <- true

        {
            p =
                let p = Process()
                p.StartInfo <- startInfo
                p
        }

    RunAsync(ct: System.Threading.CancellationToken): System.Threading.Tasks.Task<(output: string, errors: string)> =
        class DataReceived =

            private f: DataReceivedEventArgs -> ()
            new(f: DataReceivedEventArgs -> ()) =
                {
                    f  = f
                }

            Invoke(sender: object, e: DataReceivedEventArgs): () =
                this.f(e)

        let work =
            () ->
                let output = System.Text.StringBuilder()
                let error = System.Text.StringBuilder()
                let outputWaitHandle = System.Threading.AutoResetEvent(false)
                let errorWaitHandle = System.Threading.AutoResetEvent(false)

                let outputDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = outputWaitHandle.Set()
                            else
                                let result = output.AppendLine(e.Data)

                    )
                this.p.add_OutputDataReceived(
                    DataReceivedEventHandler(outputDataReceived, UnsafeCast(&&outputDataReceived.Invoke))
                )

                let errorDataReceived = 
                    DataReceived(
                        e ->
                            if (e.Data === unchecked default)
                                let result = errorWaitHandle.Set()
                            else
                                let result = error.AppendLine(e.Data)

                    )
                this.p.add_ErrorDataReceived(
                    DataReceivedEventHandler(errorDataReceived, UnsafeCast(&&errorDataReceived.Invoke))
                )

                let result = this.p.Start()

                this.p.BeginOutputReadLine()
                this.p.BeginErrorReadLine()

                this.p.WaitForExit() // TODO: We should use the async version
                let result = outputWaitHandle.WaitOne()
                let result = errorWaitHandle.WaitOne()
                let output = output.ToString()
                let errors = error.ToString()
                if (this.p.ExitCode != 0)
                    throw Exception("Failed process")

                (output, errors)

        System.Threading.Tasks.Task.Run(work)

    Dispose(): () =
        this.p.Dispose()

// **********************************************************************************************************************************

private alias vk = Evergreen.Graphics.Backend.Vulkan
private alias VkBufferUsageFlags = TerraFX.Interop.Vulkan.VkBufferUsageFlags
private alias VmaAllocationCreateFlags = Evergreen.Graphics.Backend.Interop.VulkanMemoryAllocator.VmaAllocationCreateFlags
private alias VkDescriptorType = TerraFX.Interop.Vulkan.VkDescriptorType
private alias VkShaderStageFlags = TerraFX.Interop.Vulkan.VkShaderStageFlags
private alias VkDescriptorSet = TerraFX.Interop.Vulkan.VkDescriptorSet
private alias VkCullModeFlags = TerraFX.Interop.Vulkan.VkCullModeFlags
private alias VkFrontFace = TerraFX.Interop.Vulkan.VkFrontFace
private alias VkFormat = TerraFX.Interop.Vulkan.VkFormat
private alias VkImageAspectFlags = TerraFX.Interop.Vulkan.VkImageAspectFlags

struct Vertex =
    Position: Vector3
    TexCoord: Vector2

    new(position: Vector3, texCoord: Vector2) =
        {
            Position = position
            TexCoord = texCoord
        }

    overrides ToString(): string = 
        "(Position = " + this.Position.ToString() + ")"

struct Globals =
    mutable Model: Matrix4x4 = Matrix4x4.Identity
    mutable View: Matrix4x4 = Matrix4x4.Identity
    mutable Projection: Matrix4x4 = Matrix4x4.Identity

radians(degrees: float64): float64 = degrees * System.Math.PI / 180
radians(degrees: float32): float32 = float32(radians(float64(degrees)))

compileShaderByFile(path: string): ReadOnlySpan<byte> =
    let outputPath = Path.ChangeExtension(path, ".spv")
    let p = ExternalProcess("glslangValidator", "--target-env vulkan1.3 -o " + outputPath + " " + path, Environment.CurrentDirectory)
    let task = p.RunAsync(System.Threading.CancellationToken.None)

    let results = task.Result
    let code = ReadOnlySpan(System.IO.File.ReadAllBytes(outputPath))
    try File.Delete(outputPath)
    catch (ex: Exception) => ()
    p.Dispose()
    code

createImage(vulkanApp: vk.VulkanApplication, filePath: string): vk.VulkanImage =
    let image = Image.Load<Rgba32>(File.ReadAllBytes(filePath))
    let width = uint32(image.Width)
    let height = uint32(image.Height)
    let format = VkFormat.VK_FORMAT_R8G8B8A8_SRGB

    let mutable imageSpan = default
    if (!image.TryGetSinglePixelSpan(&imageSpan))
        fail("Invalid image.")

    let mutable imageSpan = Span<Rgba32>.op_Implicit(imageSpan)
    let imageSpan = System.Runtime.InteropServices.MemoryMarshal.Cast<Rgba32, byte>(imageSpan)
    let vulkanImage = vk.CreateImage(vulkanApp, width, height, format, imageSpan)
    image.Dispose()

    vulkanImage

createVertexBuffer(vulkanApp: vk.VulkanApplication, vertices: Vertex[||]): vk.VulkanBuffer =
    let buffer = 
        vk.CreateBuffer(
            vulkanApp, 
            65536, 
            VkBufferUsageFlags.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
           // VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
        )
    vk.UpdateBuffer(vulkanApp, buffer, vertices)
    buffer

createIndexBuffer(vulkanApp: vk.VulkanApplication, indices: uint32[||]): vk.VulkanBuffer =
    let buffer = 
        vk.CreateBuffer(
            vulkanApp, 
            65536, 
            VkBufferUsageFlags.VK_BUFFER_USAGE_INDEX_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
            // VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_MAPPED_BIT
        )
    vk.UpdateBuffer(vulkanApp, buffer, indices)
    buffer

main(): () =
    // We must set this variable otherwise some multi-gpu setups will fail with integrated AMD and discrete NVIDIA cards.
    Environment.SetEnvironmentVariable("DISABLE_LAYER_AMD_SWITCHABLE_GRAPHICS_1", "1")
    
    let window = IWindow.CreateWin32("Vulkan Example")

    let vulkanAppOptions = vk.VulkanApplicationOptions()
    vulkanAppOptions.ValidationEnabled <- true
    vulkanAppOptions.MaxFramesInFlight <- 2
    let vulkanApp = vk.Initialize(window.HWND, window.HINSTANCE, vulkanAppOptions)

    let testImage = createImage(vulkanApp, "GameExample/Textures/flats/aqf068.png")
    let testImageView = vk.CreateImageView(vulkanApp, testImage, VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT)
    let testSampler = vk.CreateSampler(vulkanApp)

    printLine(vulkanApp.GetDeviceName())

    let quad = Evergreen.Graphics.MeshDescription.CreateQuad(1)
    let vertices =
        Array.InitializeMutable(quad.Vertices.Length,
            i -> Vertex(quad.Vertices[i], quad.TexCoords[i])
        )
    
    let vertexBuffer = createVertexBuffer(vulkanApp, vertices)
    let indexBuffer = createIndexBuffer(vulkanApp, quad.Indices)

    let vertexShaderByteCode = compileShaderByFile("Win32Example/default_vert.vert")
    let fragmentShaderByteCode = compileShaderByFile("Win32Example/default_frag.frag")

    let vertexShaderModule = vk.CreateShaderModule(vulkanApp, vertexShaderByteCode)
    let fragmentShaderModule = vk.CreateShaderModule(vulkanApp, fragmentShaderByteCode)

    let globals =
        [
            (
                let mutable globals = Globals()
                globals.Projection <- Matrix4x4.CreatePerspectiveFieldOfView(radians(45), 1, 0.1, 10)
                globals.View <- Matrix4x4.CreateLookAt(Vector3(2, 2, 2), Vector3(0, 0, 0), Vector3(0, 0, 1))
                globals.Model <- Matrix4x4.Identity
                globals
            )
        ]

    let globalBuffers =
        Array.Initialize(vulkanApp.MaxFramesInFlight, 
            i ->
                let buffer =
                    vk.CreateBuffer(
                        vulkanApp,
                        uint64(sizeof<Globals>),
                        VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                        VmaAllocationCreateFlags.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
                    )
                vk.UpdateBuffer(vulkanApp, buffer, [globals[0]])
                buffer
        )
    let globalBuffers = UnsafeCast<vk.VulkanBuffer[]>(globalBuffers)

    let bindingInfos =
        [
            vk.VulkanDescriptorBindingInfo(0, VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT);
            vk.VulkanDescriptorBindingInfo(1, VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT)
        ]       
    let bindingInfos =
        ReadOnlySpan(UnsafeCast<_[||]>(bindingInfos))

    let descriptorTypes =
        [
            VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
        ]
    let mutable descriptorTypes =
        ReadOnlySpan(UnsafeCast<_[||]>(descriptorTypes))

    let setLayout = vk.CreateDescriptorSetLayout(vulkanApp, bindingInfos)
    let descriptorPool = vk.CreateDescriptorPool(vulkanApp, descriptorTypes, uint32(vulkanApp.MaxFramesInFlight))
    let descriptorSets = vk.CreateDescriptorSets(vulkanApp, descriptorPool, uint32(vulkanApp.MaxFramesInFlight), setLayout)

    let mutable i = 0
    while (i < vulkanApp.MaxFramesInFlight)
        vk.UpdateDescriptorSet(vulkanApp, 0, descriptorSets[i], globalBuffers[i], descriptorTypes[0])
        vk.UpdateDescriptorSet(vulkanApp, 1, descriptorSets[i], vk.VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, testImageView, testSampler, descriptorTypes[1])
        i <- i + 1

    let pipelineLayout = vk.CreatePipelineLayout(vulkanApp, [setLayout])

    let commandBuffers =
        let commandBuffers = Array.ZeroCreate(vulkanApp.MaxFramesInFlight)
        let mutable i = 0
        while (i < commandBuffers.Length)
            commandBuffers[i] <- vk.CreateGraphicsCommandBuffer(vulkanApp)
            i <- i + 1
        commandBuffers

    let recordCommands(frame: int32, graphicsPipeline, renderPass, framebuffer, extent, viewport, scissor) =
        let commandBuffer = commandBuffers[frame]
        let descriptorSet = descriptorSets[frame]

        vk.ResetCommandBuffer(vulkanApp, commandBuffer)

        commandBuffer.Begin()
        commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

        commandBuffer.BindPipeline(graphicsPipeline, vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
        commandBuffer.SetViewport(viewport)
        commandBuffer.SetScissor(scissor)
        commandBuffer.BindDescriptorSet(vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, descriptorSet)
        commandBuffer.BindVertexBuffer(vertexBuffer)
        commandBuffer.BindIndexBuffer(indexBuffer)
        commandBuffer.DrawIndexed(uint32(quad.Indices.Length), 1)

        commandBuffer.EndRenderPass()
        commandBuffer.End()

        commandBuffer

    let mutable swapChain = unchecked default
    let mutable graphicsPipeline = unchecked default
    let mutable renderPass = unchecked default
    let mutable swapChainFramebuffers = unchecked default
    let recreateSwapChain() =
        vk.ResetCurrentFrame(vulkanApp)
        swapChain <- vk.CreateSwapChain(vulkanApp)
        renderPass <- vk.CreateRenderPass(vulkanApp, swapChain)
        swapChainFramebuffers <- vk.CreateSwapChainFramebuffers(vulkanApp, swapChain, renderPass)

        let bindingDescs = [vk.CreateVertexBindingDescription<Vertex>(0, false)]
        let attrDescs = vk.CreateVertexAttributeDescriptions<Vertex>(0)
        graphicsPipeline <- 
            vk.CreateGraphicsPipeline(
                vulkanApp, 
                swapChain, 
                bindingDescs, 
                attrDescs, 
                pipelineLayout, 
                renderPass, 
                VkCullModeFlags.VK_CULL_MODE_BACK_BIT, 
                VkFrontFace.VK_FRONT_FACE_CLOCKWISE, 
                vertexShaderModule, 
                fragmentShaderModule
            )

    let cleanupSwapChain() =
        if (swapChain !== unchecked default)
            vk.DestroyPipeline(vulkanApp, graphicsPipeline)
            vk.DestroyFramebuffers(vulkanApp, swapChainFramebuffers)   
            vk.DestroyRenderPass(vulkanApp, renderPass)
            vk.DestroySwapChain(vulkanApp, swapChain)
            swapChain <- unchecked default

    recreateSwapChain()
    window.Show()

    let mutable forceQuit = false
    let draw() =
        try
            vk.Draw(vulkanApp, swapChain, 
                (framebufferIndex, frame) -> 
                    let framebuffer = swapChainFramebuffers[framebufferIndex]
                    recordCommands(frame, graphicsPipeline, renderPass, framebuffer, swapChain.Extent, swapChain.Viewport, swapChain.Scissor)
            )
        catch (ex: vk.VulkanSwapChainOutOfDateException) =>
            if (!window.IsClosed && window.Height != 0 && window.Width != 0)
                vk.WaitForIdle(vulkanApp)
                cleanupSwapChain()
                try
                    recreateSwapChain()
                catch (ex: vk.VulkanSwapChainCreationFailedException) =>
                    // swap-chain failed to create, bail out of application
                    ()
    draw()

    // --- BEGIN LOOP

    while (!window.IsClosed)
        let inputSnapshot = window.PumpEvents()
        let keyEvents = inputSnapshot.KeyEvents

        let mutable i = 0
        while (i < keyEvents.Length)
            let keyEvent = keyEvents[i]
            if (keyEvent.IsDown && !keyEvent.IsRepeat)

                match (keyEvent.Key)
                | Key.Esc =>
                    window.Close()
                | Key.Tilde =>
                    window.Minimize()
                | _ => 
                    ()

                printLine(keyEvent)
            i <- i + 1

        if (!window.IsClosed && !window.IsHidden && window.Height != 0 && window.Width != 0)
            draw()

    // --- END LOOP

    vk.WaitForIdle(vulkanApp)

    vk.DestroyBuffer(vulkanApp, vertexBuffer)
    vk.DestroyBuffer(vulkanApp, indexBuffer)

    let mutable i = 0
    while (i < globalBuffers.Length)
        vk.DestroyBuffer(vulkanApp, globalBuffers[i])
        i <- i + 1

    cleanupSwapChain()

    vk.DestroyDescriptorSetLayout(vulkanApp, setLayout)
    
    vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

    vk.DestroyDescriptorPool(vulkanApp, descriptorPool)

    vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
    vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

    vk.DestroySampler(vulkanApp, testSampler)
    vk.DestroyImageView(vulkanApp, testImageView)
    vk.DestroyImage(vulkanApp, testImage)

    vk.Destroy(vulkanApp)

    window.Dispose()
