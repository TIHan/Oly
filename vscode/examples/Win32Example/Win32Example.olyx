#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"

open System
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open static TerraFX.Interop.Windows.Windows
open static TerraFX.Interop.Windows.CS
open static TerraFX.Interop.Windows.GWLP
open static TerraFX.Interop.Windows.PM
open static TerraFX.Interop.Windows.WM
open static TerraFX.Interop.Windows.WS
open static TerraFX.Interop.Windows.SW

alias vk = Evergreen.Graphics.Backend.Vulkan

class Marker

enum Win32WindowEvent =
    | WindowResized

mutable win32WindowEvents: System.Collections.Generic.List<Win32WindowEvent> = System.Collections.Generic.List<Win32WindowEvent>()

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>()])]
wndProc(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT =
    match (int32(msg))
    | WM_DESTROY =>
        print("Quitting...\n")
        PostQuitMessage(0)
        default
    | WM_SIZE =>
        win32WindowEvents.Add(Win32WindowEvent.WindowResized)
        DefWindowProc(hWnd, msg, wParam, lParam)
    | _ =>
        DefWindowProc(hWnd, msg, wParam, lParam)

createWindow(): (HWND, HINSTANCE) =
    let m = typeof<Marker>().Module
    let hInstance = HINSTANCE.op_Explicit(Marshal.GetHINSTANCE(m))
    let mutable wc = default: WNDCLASSW

    let mutable example = "Hello World Class"
    let mutable windowName = "\U0001F47D"
    let mutable gc = GCHandle.Alloc(example, GCHandleType.Pinned)
    let mutable gc2 = GCHandle.Alloc(windowName, GCHandleType.Pinned)
    let addr = ToPtr(gc.AddrOfPinnedObject())
    let addr2 = ToPtr(gc2.AddrOfPinnedObject())
    wc.hInstance <- hInstance
    wc.lpfnWndProc <- __oly_load_function_ptr(wndProc)
    wc.lpszClassName <- addr

    let result = RegisterClass(&&wc)
    if (result == 0)
        (HWND.NULL, hInstance)
    else
        let hwnd =
            CreateWindowEx(
                0, 
                wc.lpszClassName, 
                addr2,
                uint32(WS_OVERLAPPEDWINDOW),
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                HWND.NULL, 
                HMENU.NULL, 
                hInstance, 
                default
            )

        gc.Free()
        gc2.Free()
        (hwnd, hInstance)

showWindow(hwnd: HWND): () =
    let result = ShowWindow(hwnd, SW_SHOW)
    let result = UpdateWindow(hwnd)
    let result = SetFocus(hwnd)

main(): () =
    match (createWindow())
    | (hwnd, hinstance) when (hwnd == HWND.NULL) =>
        fail("Failed to create window.")
    | (hwnd, hinstance) =>
        let vulkanAppOptions = vk.VulkanApplicationOptions()
        let vulkanApp = vk.Initialize(nint(hwnd.Value), nint(hinstance.Value), vulkanAppOptions)

        let vertexShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/vert.spv")
        let fragmentShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/frag.spv")

        let vertexShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(vertexShaderByteCode))
        let fragmentShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(fragmentShaderByteCode))

        let pipelineLayout = vk.CreatePipelineLayout(vulkanApp)
        let commandPool = vk.CreateGraphicsCommandPool(vulkanApp)

        let recordCommands(commandBuffer: vk.VulkanCommandBuffer, graphicsPipeline, renderPass, framebuffer, extent, viewport, scissor) =
            commandBuffer.Begin()
            commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

            commandBuffer.BindPipeline(graphicsPipeline, vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
            commandBuffer.SetViewport(viewport)
            commandBuffer.SetScissor(scissor)
            commandBuffer.Draw(3, 1)

            commandBuffer.EndRenderPass()
            commandBuffer.End()

        let mutable swapChain = unchecked default
        let mutable commandBuffers = unchecked default
        let mutable graphicsPipeline = unchecked default
        let mutable renderPass = unchecked default
        let mutable swapChainFramebuffers = unchecked default
        let recreateSwapChain() =
            vk.ResetCurrentFrame(vulkanApp)
            swapChain <- vk.CreateSwapChain(vulkanApp)
            renderPass <- vk.CreateRenderPass(vulkanApp, swapChain)

            swapChainFramebuffers <- vk.CreateSwapChainFramebuffers(vulkanApp, swapChain, renderPass)

            graphicsPipeline <- vk.CreateGraphicsPipeline(vulkanApp, swapChain, pipelineLayout, renderPass, vertexShaderModule, fragmentShaderModule)

            commandBuffers <- 
                let commandBuffers = Array.ZeroCreate(swapChainFramebuffers.Length)
                let mutable i = 0
                while (i < commandBuffers.Length)
                    commandBuffers[i] <- vk.CreateCommandBuffer(vulkanApp, commandPool)
                    i <- i + 1
                commandBuffers

            let mutable i = 0
            while (i < swapChain.Images.Length)
                recordCommands(commandBuffers[i], graphicsPipeline, renderPass, swapChainFramebuffers[i], swapChain.Extent, swapChain.Viewport, swapChain.Scissor)
                i <- i + 1

        let cleanupSwapChain() =
            if (swapChain !== unchecked default)
                vk.DestroyPipeline(vulkanApp, graphicsPipeline)
                vk.DestroyFramebuffers(vulkanApp, ReadOnlySpan(swapChainFramebuffers))   
                vk.DestroyRenderPass(vulkanApp, renderPass)
                vk.DestroySwapChain(vulkanApp, swapChain)
                swapChain <- unchecked default

        recreateSwapChain()
        showWindow(hwnd)

        let mutable quit = false
        let draw() =
            try
                vk.Draw(vulkanApp, swapChain, index -> commandBuffers[index])
            catch (ex: vk.VulkanSwapChainOutOfDateException) =>
                vk.WaitForIdle(vulkanApp)
                cleanupSwapChain()
                try
                    recreateSwapChain()
                catch (ex: vk.VulkanSwapChainCreationFailedException) =>
                    // swap-chain failed to create, bail out of application
                    quit <- true
        draw()

        // --- BEGIN LOOP

        let mutable msg = default: MSG
        while (!quit)
            while (PeekMessage(&&msg, hwnd, 0, 0, uint32(PM_REMOVE)) == BOOL.TRUE)
                let result = TranslateMessage(&&msg)
                let result = DispatchMessage(&&msg)

                // if (msg.wParam.Value == nuint(WM_DESTROY) || msg.wParam.Value == nuint(WM_QUIT))
                //     quit <- true

            if (!quit)
                System.Threading.Thread.Sleep(100)
                draw()

        // --- END LOOP

        vk.WaitForIdle(vulkanApp)

        cleanupSwapChain()

        vk.DestroyCommandPool(vulkanApp, commandPool)
        vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

        vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
        vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

        vk.Destroy(vulkanApp)
    | _ =>
        fail("Should not happen, fix language as this should be exhaustive.")
