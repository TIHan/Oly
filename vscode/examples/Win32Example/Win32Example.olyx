#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"

open System
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open static TerraFX.Interop.Windows.Windows
open static TerraFX.Interop.Windows.CS
open static TerraFX.Interop.Windows.GWLP
open static TerraFX.Interop.Windows.PM
open static TerraFX.Interop.Windows.WM
open static TerraFX.Interop.Windows.WS
open static TerraFX.Interop.Windows.SW

alias vk = Evergreen.Graphics.Backend.Vulkan

class Marker

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>()])]
wndProc(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT =
    if(msg == 2 /* WM_DESTROY - need conversions */)
        print("Quitting...\n")
        PostQuitMessage(0)
        default
    else
        DefWindowProc(hWnd, msg, wParam, lParam)

createWindow(): (HWND, HINSTANCE) =
    let m = typeof<Marker>().Module
    let hInstance = HINSTANCE.op_Explicit(Marshal.GetHINSTANCE(m))
    let mutable wc = default: WNDCLASSW

    let mutable example = "Hello World Class"
    let mutable windowName = "\U0001F47D"
    let mutable gc = GCHandle.Alloc(example, GCHandleType.Pinned)
    let mutable gc2 = GCHandle.Alloc(windowName, GCHandleType.Pinned)
    let addr = ToPtr(gc.AddrOfPinnedObject())
    let addr2 = ToPtr(gc2.AddrOfPinnedObject())
    wc.hInstance <- hInstance
    wc.lpfnWndProc <- __oly_load_function_ptr(wndProc)
    wc.lpszClassName <- addr

    let result = RegisterClass(&&wc)
    if (result == 0)
        (HWND.NULL, hInstance)
    else
        let hwnd =
            CreateWindowEx(
                0, 
                wc.lpszClassName, 
                addr2,
                uint32(WS_OVERLAPPEDWINDOW),
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                HWND.NULL, 
                HMENU.NULL, 
                hInstance, 
                default
            )

        gc.Free()
        gc2.Free()
        (hwnd, hInstance)

showWindow(hwnd: HWND): () =
    let result = ShowWindow(hwnd, SW_SHOW)
    let result = UpdateWindow(hwnd)
    let result = SetFocus(hwnd)

runWindowMessage(hwnd: HWND): () =
    let mutable msg = default: MSG
    while (GetMessage(&&msg, hwnd, 0, 0) == BOOL.TRUE)
        let result = TranslateMessage(&&msg)
        let result = DispatchMessage(&&msg)
    // static let loop(hwnd, mutable msg): () =
    //     if(GetMessage(&&msg, hwnd, 0, 0) == BOOL.TRUE)
    //         let result = TranslateMessage(&&msg)
    //         let result = DispatchMessage(&&msg)
    //         loop(hwnd, default)
    // loop(hwnd, default)

main(): () =
    match (createWindow())
    | (hwnd, hinstance) when (hwnd == HWND.NULL) =>
        fail("Failed to create window.")
    | (hwnd, hinstance) =>
        let vulkanAppOptions = vk.VulkanApplicationOptions()
        vulkanAppOptions.PreferredMaxFramesInFlight <- 2
        let vulkanApp = vk.Initialize(nint(hwnd.Value), nint(hinstance.Value), vulkanAppOptions)

        let vertexShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/vert.spv")
        let fragmentShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/frag.spv")

        let vertexShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(vertexShaderByteCode))
        let fragmentShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(fragmentShaderByteCode))

        let pipelineLayout = vk.CreatePipelineLayout(vulkanApp)
        let renderPass = vk.CreateRenderPass(vulkanApp)

        let swapChainFramebuffers = vk.CreateSwapChainFramebuffers(vulkanApp, renderPass)

        let graphicsPipeline = vk.CreateGraphicsPipeline(vulkanApp, pipelineLayout, renderPass, vertexShaderModule, fragmentShaderModule)

        let commandPool = vk.CreateGraphicsCommandPool(vulkanApp)

        let commandBuffers = 
            let commandBuffers = Array.ZeroCreate(swapChainFramebuffers.Length)
            let mutable i = 0
            while (i < commandBuffers.Length)
                commandBuffers[i] <- vk.CreateCommandBuffer(vulkanApp, commandPool)
                i <- i + 1
            commandBuffers

        let recordCommands(commandBuffer: vk.VulkanCommandBuffer, framebuffer, extent, viewport, scissor) =
            commandBuffer.Begin()
            commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

            commandBuffer.BindPipeline(graphicsPipeline, vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
            commandBuffer.SetViewport(viewport)
            commandBuffer.SetScissor(scissor)
            commandBuffer.Draw(3, 1)

            commandBuffer.EndRenderPass()
            commandBuffer.End()

        let mutable i = 0
        while (i < vulkanApp.MaxFramesInFlight)
            recordCommands(commandBuffers[i], swapChainFramebuffers[i], vulkanApp.SwapChain.Extent, vulkanApp.SwapChain.Viewport, vulkanApp.SwapChain.Scissor)
            i <- i + 1

        showWindow(hwnd)

        vk.Draw(vulkanApp, index -> commandBuffers[index])

        runWindowMessage(hwnd)

        vk.WaitForIdle(vulkanApp)

        vk.DestroyCommandPool(vulkanApp, commandPool)

        vk.DestroyPipeline(vulkanApp, graphicsPipeline)

        vk.DestroyFramebuffers(vulkanApp, ReadOnlySpan(swapChainFramebuffers))

        vk.DestroyRenderPass(vulkanApp, renderPass)
        vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

        vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
        vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

        vk.Destroy(vulkanApp)
    | _ =>
        fail("Should not happen, fix language as this should be exhaustive.")
