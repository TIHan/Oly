#target "dotnet: net7"

#load "*.oly"

#reference "../core/prelude.olyx"
#reference "../Evergreen/src/Graphics/Evergreen.Graphics.olyx"

open System
open System.Runtime.InteropServices
open System.Runtime.CompilerServices
open TerraFX.Interop.Windows
open static TerraFX.Interop.Windows.Windows
open static TerraFX.Interop.Windows.CS
open static TerraFX.Interop.Windows.GWLP
open static TerraFX.Interop.Windows.PM
open static TerraFX.Interop.Windows.WM
open static TerraFX.Interop.Windows.WS
open static TerraFX.Interop.Windows.SW

alias vk = Evergreen.Graphics.Backend.Vulkan

class Marker

enum Win32WindowEvent =
    | WindowResized

mutable win32WindowEvents: System.Collections.Generic.List<Win32WindowEvent> = System.Collections.Generic.List<Win32WindowEvent>()

#[blittable]
#[UnmanagedCallersOnly(CallConvs = [typeof<CallConvCdecl>()])]
wndProc(hWnd: HWND, msg: uint32, wParam: WPARAM, lParam: LPARAM): LRESULT =
    match (int32(msg))
    | WM_DESTROY =>
        print("Quitting...\n")
        PostQuitMessage(0)
        default
    | WM_SIZE =>
        win32WindowEvents.Add(Win32WindowEvent.WindowResized)
        DefWindowProc(hWnd, msg, wParam, lParam)
    | _ =>
        DefWindowProc(hWnd, msg, wParam, lParam)

createWindow(): (HWND, HINSTANCE) =
    let m = typeof<Marker>().Module
    let hInstance = HINSTANCE.op_Explicit(Marshal.GetHINSTANCE(m))
    let mutable wc = default: WNDCLASSW

    let mutable example = "Hello World Class"
    let mutable windowName = "\U0001F47D"
    let mutable gc = GCHandle.Alloc(example, GCHandleType.Pinned)
    let mutable gc2 = GCHandle.Alloc(windowName, GCHandleType.Pinned)
    let addr = ToPtr(gc.AddrOfPinnedObject())
    let addr2 = ToPtr(gc2.AddrOfPinnedObject())
    wc.hInstance <- hInstance
    wc.lpfnWndProc <- __oly_load_function_ptr(wndProc)
    wc.lpszClassName <- addr

    let result = RegisterClass(&&wc)
    if (result == 0)
        (HWND.NULL, hInstance)
    else
        let hwnd =
            CreateWindowEx(
                0, 
                wc.lpszClassName, 
                addr2,
                uint32(WS_OVERLAPPEDWINDOW),
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                HWND.NULL, 
                HMENU.NULL, 
                hInstance, 
                default
            )

        gc.Free()
        gc2.Free()
        (hwnd, hInstance)

showWindow(hwnd: HWND): () =
    let result = ShowWindow(hwnd, SW_SHOW)
    let result = UpdateWindow(hwnd)
    let result = SetFocus(hwnd)

main(): () =
    match (createWindow())
    | (hwnd, hinstance) when (hwnd == HWND.NULL) =>
        fail("Failed to create window.")
    | (hwnd, hinstance) =>
        let vulkanAppOptions = vk.VulkanApplicationOptions()
        let vulkanApp = vk.Initialize(nint(hwnd.Value), nint(hinstance.Value), vulkanAppOptions)

        let vertexShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/vert.spv")
        let fragmentShaderByteCode = System.IO.File.ReadAllBytes("Win32Example/frag.spv")

        let vertexShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(vertexShaderByteCode))
        let fragmentShaderModule = vk.CreateShaderModule(vulkanApp, ReadOnlySpan(fragmentShaderByteCode))

        let pipelineLayout = vk.CreatePipelineLayout(vulkanApp)
        let renderPass = vk.CreateRenderPass(vulkanApp)

        let swapChainFramebuffers = vk.CreateSwapChainFramebuffers(vulkanApp, renderPass)

        let graphicsPipeline = vk.CreateGraphicsPipeline(vulkanApp, pipelineLayout, renderPass, vertexShaderModule, fragmentShaderModule)

        let commandPool = vk.CreateGraphicsCommandPool(vulkanApp)

        let commandBuffers = 
            let commandBuffers = Array.ZeroCreate(swapChainFramebuffers.Length)
            let mutable i = 0
            while (i < commandBuffers.Length)
                commandBuffers[i] <- vk.CreateCommandBuffer(vulkanApp, commandPool)
                i <- i + 1
            commandBuffers

        let recordCommands(commandBuffer: vk.VulkanCommandBuffer, framebuffer, extent, viewport, scissor) =
            commandBuffer.Begin()
            commandBuffer.BeginRenderPass(renderPass, framebuffer, extent)

            commandBuffer.BindPipeline(graphicsPipeline, vk.VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS)
            commandBuffer.SetViewport(viewport)
            commandBuffer.SetScissor(scissor)
            commandBuffer.Draw(3, 1)

            commandBuffer.EndRenderPass()
            commandBuffer.End()

        let mutable i = 0
        while (i < vulkanApp.MaxFramesInFlight)
            recordCommands(commandBuffers[i], swapChainFramebuffers[i], vulkanApp.SwapChain.Extent, vulkanApp.SwapChain.Viewport, vulkanApp.SwapChain.Scissor)
            i <- i + 1

        showWindow(hwnd)

        vk.Draw(vulkanApp, index -> commandBuffers[index])

        // --- BEGIN LOOP

        let mutable quit = false
        let mutable msg = default: MSG
        while (!quit)
            while (PeekMessage(&&msg, hwnd, 0, 0, uint32(PM_REMOVE)) == BOOL.TRUE)
                let result = TranslateMessage(&&msg)
                let result = DispatchMessage(&&msg)

                if (msg.wParam.Value == nuint(WM_DESTROY))
                    quit <- true

            if (!quit)
                System.Threading.Thread.Sleep(100)
                vk.Draw(vulkanApp, index -> commandBuffers[index])

        // --- END LOOP

        vk.WaitForIdle(vulkanApp)

        vk.DestroyCommandPool(vulkanApp, commandPool)

        vk.DestroyPipeline(vulkanApp, graphicsPipeline)

        vk.DestroyFramebuffers(vulkanApp, ReadOnlySpan(swapChainFramebuffers))

        vk.DestroyRenderPass(vulkanApp, renderPass)
        vk.DestroyPipelineLayout(vulkanApp, pipelineLayout)

        vk.DestroyShaderModule(vulkanApp, vertexShaderModule)
        vk.DestroyShaderModule(vulkanApp, fragmentShaderModule)

        vk.Destroy(vulkanApp)
    | _ =>
        fail("Should not happen, fix language as this should be exhaustive.")
